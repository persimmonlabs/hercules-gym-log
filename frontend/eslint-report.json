[{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\.expo\\types\\router.d.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'T' is defined but never used.","line":8,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":32,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\app.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\app\\(tabs)\\_layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\app\\(tabs)\\browse-programs.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExperienceLevel' is defined but never used.","line":16,"column":44,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":59}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useMemo, useState, useCallback, useEffect, Component, type ErrorInfo, type ReactNode } from 'react';\r\nimport { StyleSheet, FlatList, Pressable, View, BackHandler } from 'react-native';\r\nimport { useRouter, useLocalSearchParams } from 'expo-router';\r\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { Button } from '@/components/atoms/Button';\r\nimport { ProgramCard } from '@/components/molecules/ProgramCard';\r\nimport { WorkoutFilters, type WorkoutFilterState } from '@/components/molecules/WorkoutFilters';\r\nimport { IconSymbol } from '@/components/ui/icon-symbol';\r\nimport { colors, spacing, radius, sizing } from '@/constants/theme';\r\nimport { useProgramsStore } from '@/store/programsStore';\r\nimport { usePlansStore } from '@/store/plansStore';\r\nimport { usePremiumStatus } from '@/hooks/usePremiumStatus';\r\nimport type { PremadeProgram, UserProgram, ExperienceLevel, PremadeWorkout } from '@/types/premadePlan';\r\n\r\ninterface ErrorBoundaryState {\r\n  hasError: boolean;\r\n  error: Error | null;\r\n}\r\n\r\nclass BrowseErrorBoundary extends Component<{ children: ReactNode; onReset: () => void }, ErrorBoundaryState> {\r\n  constructor(props: { children: ReactNode; onReset: () => void }) {\r\n    super(props);\r\n    this.state = { hasError: false, error: null };\r\n  }\r\n\r\n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\r\n    return { hasError: true, error };\r\n  }\r\n\r\n  componentDidCatch(error: Error, errorInfo: ErrorInfo) {\r\n    console.error('[BrowseProgramsScreen] Error caught by boundary:', error, errorInfo);\r\n  }\r\n\r\n  render() {\r\n    if (this.state.hasError) {\r\n      return (\r\n        <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', padding: 20, backgroundColor: colors.primary.bg }}>\r\n          <Text variant=\"heading3\" color=\"primary\" style={{ marginBottom: 12 }}>Something went wrong</Text>\r\n          <Text variant=\"body\" color=\"secondary\" style={{ marginBottom: 20, textAlign: 'center' }}>\r\n            {this.state.error?.message || 'An unexpected error occurred'}\r\n          </Text>\r\n          <Button label=\"Go Back\" onPress={this.props.onReset} />\r\n        </View>\r\n      );\r\n    }\r\n    return this.props.children;\r\n  }\r\n}\r\n\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    flex: 1,\r\n    backgroundColor: colors.primary.bg,\r\n  },\r\n  header: {\r\n    flexDirection: 'row',\r\n    alignItems: 'flex-start',\r\n    justifyContent: 'space-between',\r\n    paddingHorizontal: spacing.md,\r\n    paddingTop: spacing.xl,\r\n    paddingBottom: spacing.lg,\r\n    gap: spacing.sm,\r\n  },\r\n  backButton: {\r\n    padding: spacing.sm,\r\n    paddingTop: spacing.xs,\r\n    borderRadius: radius.full,\r\n  },\r\n  titleContainer: {\r\n    flex: 1,\r\n  },\r\n  titleWrapper: {\r\n    paddingBottom: spacing.xs,\r\n  },\r\n    listContent: {\r\n    paddingBottom: spacing['2xl'],\r\n    gap: spacing.md,\r\n  },\r\n  emptyState: {\r\n    flex: 1,\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n    paddingTop: spacing['2xl'],\r\n    gap: spacing.md,\r\n  },\r\n});\r\n\r\nfunction BrowseProgramsScreen() {\r\n  const router = useRouter();\r\n  const insets = useSafeAreaInsets();\r\n  const { mode } = useLocalSearchParams<{ mode?: 'program' | 'workout' }>();\r\n  const modeString = Array.isArray(mode) ? mode[0] : mode;\r\n  const isWorkoutMode = modeString === 'workout';\r\n\r\n  const { premadePrograms, premadeWorkouts, userPrograms } = useProgramsStore();\r\n  const { plans } = usePlansStore();\r\n  const { isPremium } = usePremiumStatus();\r\n\r\n  const [filters, setFilters] = useState<WorkoutFilterState>({\r\n    experienceLevel: 'all',\r\n    equipment: 'all',\r\n    goal: 'all',\r\n    workoutType: 'all',\r\n    duration: 'all',\r\n  });\r\n\r\n  const filteredItems = useMemo(() => {\r\n    try {\r\n      if (isWorkoutMode) {\r\n        let filtered = premadeWorkouts || [];\r\n\r\n        // Apply experience level filter\r\n        if (filters.experienceLevel !== 'all') {\r\n          filtered = filtered.filter(p => p?.metadata?.experienceLevel === filters.experienceLevel);\r\n        }\r\n\r\n        // Apply equipment filter\r\n        if (filters.equipment !== 'all') {\r\n          filtered = filtered.filter(p => p?.metadata?.equipment === filters.equipment);\r\n        }\r\n\r\n        // Apply goal filter\r\n        if (filters.goal !== 'all') {\r\n          filtered = filtered.filter(p => p?.metadata?.goal === filters.goal);\r\n        }\r\n\r\n        // Filter out workouts that have been added to My Workouts\r\n        // Compare by name (case-insensitive) since premade workouts get new IDs when added\r\n        const safePlans = (plans || []).filter(plan => plan && typeof plan.name === 'string');\r\n        const addedWorkoutNames = new Set(\r\n          safePlans\r\n            .filter(plan => plan.source === 'premade' || plan.source === 'library' || plan.source === 'recommended')\r\n            .map(plan => plan.name.trim().toLowerCase())\r\n        );\r\n        filtered = filtered.filter(w => w?.name && !addedWorkoutNames.has(w.name.trim().toLowerCase()));\r\n\r\n        // Sort: free workouts first, then premium workouts\r\n        filtered.sort((a, b) => {\r\n          const aIsFree = (a as any).isFree || false;\r\n          const bIsFree = (b as any).isFree || false;\r\n          \r\n          // Free items come first\r\n          if (aIsFree && !bIsFree) return -1;\r\n          if (!aIsFree && bIsFree) return 1;\r\n          return 0;\r\n        });\r\n\r\n        return filtered;\r\n      } else {\r\n        let filtered = premadePrograms || [];\r\n\r\n        // Apply experience level filter\r\n        if (filters.experienceLevel !== 'all') {\r\n          filtered = filtered.filter(p => p?.metadata?.experienceLevel === filters.experienceLevel);\r\n        }\r\n\r\n        // Apply equipment filter\r\n        if (filters.equipment !== 'all') {\r\n          filtered = filtered.filter(p => p?.metadata?.equipment === filters.equipment);\r\n        }\r\n\r\n        // Apply goal filter\r\n        if (filters.goal !== 'all') {\r\n          filtered = filtered.filter(p => p?.metadata?.goal === filters.goal);\r\n        }\r\n\r\n        // Filter out already-added plans\r\n        const safeUserPrograms = (userPrograms || []).filter(up => up && up.sourceId);\r\n        const addedSourceIds = new Set(safeUserPrograms.map(up => up.sourceId));\r\n        filtered = filtered.filter(p => p?.id && !addedSourceIds.has(p.id));\r\n\r\n        // Sort: free plans first, then premium plans\r\n        filtered.sort((a, b) => {\r\n          const aIsFree = (a as any).isFree || false;\r\n          const bIsFree = (b as any).isFree || false;\r\n          \r\n          // Free items come first\r\n          if (aIsFree && !bIsFree) return -1;\r\n          if (!aIsFree && bIsFree) return 1;\r\n          return 0;\r\n        });\r\n\r\n        return filtered;\r\n      }\r\n    } catch (error) {\r\n      console.error('[BrowseProgramsScreen] Error filtering items:', error);\r\n      return [];\r\n    }\r\n  }, [premadePrograms, premadeWorkouts, filters, isWorkoutMode, userPrograms, plans]);\r\n\r\n  const handleBack = useCallback(() => {\r\n    triggerHaptic('selection');\r\n    router.back();\r\n  }, [router]);\r\n\r\n  // Handle Android hardware back button\r\n  useEffect(() => {\r\n    const backAction = () => {\r\n      handleBack();\r\n      return true;\r\n    };\r\n\r\n    const backHandler = BackHandler.addEventListener('hardwareBackPress', backAction);\r\n    return () => backHandler.remove();\r\n  }, [handleBack]);\r\n\r\n  const handleUnlock = useCallback(() => {\r\n    triggerHaptic('selection');\r\n    router.push('/premium');\r\n  }, [router]);\r\n\r\n  const handleProgramPress = useCallback((item: PremadeProgram | UserProgram | PremadeWorkout) => {\r\n    triggerHaptic('selection');\r\n\r\n    // Ensure ID is a string, not an object\r\n    const itemId = typeof item?.id === 'string' ? item.id : String(item?.id || '');\r\n    if (!itemId) {\r\n      console.error('[BrowseProgramsScreen] Invalid item ID:', item);\r\n      return;\r\n    }\r\n\r\n    if (isWorkoutMode) {\r\n      // Navigate to workout preview (take-it-or-leave-it style, like program-details)\r\n      router.push({\r\n        pathname: '/(tabs)/workout-preview',\r\n        params: { workoutId: itemId, from: 'browse' }\r\n      });\r\n    } else {\r\n      router.push({\r\n        pathname: '/(tabs)/program-details',\r\n        params: { programId: itemId, from: 'browse' }\r\n      });\r\n    }\r\n  }, [router, isWorkoutMode]);\r\n\r\n\r\n  return (\r\n    <View style={[styles.container, { paddingTop: insets.top }]}>\r\n      <FlatList\r\n        data={filteredItems as any}\r\n        contentContainerStyle={[styles.listContent, { paddingBottom: insets.bottom + sizing.tabBarHeight + spacing.md }]}\r\n        keyExtractor={(item, index) => item?.id || `item-${index}`}\r\n        ListHeaderComponent={\r\n          <>\r\n            {/* Header */}\r\n            <View style={styles.header}>\r\n              <View style={styles.titleContainer}>\r\n                <Text variant=\"heading2\" color=\"primary\">\r\n                  {isWorkoutMode ? 'Browse Workouts' : 'Browse Plans'}\r\n                </Text>\r\n                <Text variant=\"body\" color=\"secondary\">\r\n                  {isWorkoutMode ? 'Find a session that fits your goals' : 'Find a plan that fits your goals'}\r\n                </Text>\r\n              </View>\r\n              <Pressable onPress={handleBack} style={styles.backButton} hitSlop={8}>\r\n                <IconSymbol name=\"arrow-back\" size={24} color={colors.text.primary} />\r\n              </Pressable>\r\n            </View>\r\n\r\n            {/* Filters */}\r\n            <WorkoutFilters\r\n              filters={filters}\r\n              onFiltersChange={setFilters}\r\n              showDurationFilter={false}\r\n              showWorkoutTypeFilter={false}\r\n            />\r\n          </>\r\n        }\r\n        renderItem={({ item }) => {\r\n          // Skip rendering if item is invalid\r\n          if (!item || !item.metadata) {\r\n            return null;\r\n          }\r\n          \r\n          // Check if this is a premium workout that should be locked\r\n          const isWorkout = item.metadata && 'durationMinutes' in item.metadata;\r\n          const isLocked = isWorkout && !(item as any).isFree && !isPremium;\r\n          \r\n          return (\r\n            <View style={{ paddingHorizontal: spacing.md }}>\r\n              <ProgramCard\r\n                program={item}\r\n                onPress={handleProgramPress}\r\n                isLocked={isLocked}\r\n                onUnlock={handleUnlock}\r\n              />\r\n            </View>\r\n          );\r\n        }}\r\n        ListEmptyComponent={\r\n          <View style={styles.emptyState}>\r\n            <IconSymbol name=\"search\" size={48} color={colors.neutral.gray400} />\r\n            <Text variant=\"body\" color=\"secondary\">\r\n              {Object.values(filters).filter(v => v !== 'all').length > 0 \r\n                ? `No ${isWorkoutMode ? 'workouts' : 'programs'} found matching your filters.` \r\n                : `No ${isWorkoutMode ? 'workouts' : 'programs'} found.`}\r\n            </Text>\r\n          </View>\r\n        }\r\n      />\r\n    </View>\r\n  );\r\n}\r\n\r\nexport default function BrowseProgramsScreenWithErrorBoundary() {\r\n  const router = useRouter();\r\n  \r\n  const handleReset = useCallback(() => {\r\n    router.replace('/(tabs)/plans');\r\n  }, [router]);\r\n\r\n  return (\r\n    <BrowseErrorBoundary onReset={handleReset}>\r\n      <BrowseProgramsScreen />\r\n    </BrowseErrorBoundary>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\app\\(tabs)\\calendar.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'LinearGradient' is defined but never used.","line":6,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'markersSet' is assigned a value but never used.","line":73,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":73,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useCallback, useMemo, useState, useRef, useEffect } from 'react';\nimport { View, StyleSheet, Pressable, ScrollView, BackHandler } from 'react-native';\nimport { useFocusEffect, useScrollToTop } from '@react-navigation/native';\nimport { useRouter } from 'expo-router';\nimport { triggerHaptic } from '@/utils/haptics';\nimport { LinearGradient } from 'expo-linear-gradient';\n\nimport { SurfaceCard } from '@/components/atoms/SurfaceCard';\nimport { Text } from '@/components/atoms/Text';\nimport { MonthlyCalendar } from '@/components/molecules/MonthlyCalendar';\nimport { ScreenHeader } from '@/components/molecules/ScreenHeader';\nimport { TabSwipeContainer } from '@/components/templates/TabSwipeContainer';\nimport { spacing } from '@/constants/theme';\nimport { useTheme } from '@/hooks/useTheme';\nimport { formatDateToLocalISO, getDeviceCurrentDate, parseLocalISODate } from '@/utils/date';\nimport { formatWorkoutTitle, getWorkoutSummary } from '@/utils/workout';\nimport { useWorkoutSessionsStore, type WorkoutSessionsState } from '@/store/workoutSessionsStore';\nimport { usePlansStore, type PlansState } from '@/store/plansStore';\n\nconst getWorkoutLocalISO = (workout: WorkoutSessionsState['workouts'][number]): string | null => {\n  if (workout.startTime) {\n    return formatDateToLocalISO(new Date(workout.startTime));\n  }\n\n  if (workout.date) {\n    return formatDateToLocalISO(new Date(workout.date));\n  }\n\n  return null;\n};\n\nconst CalendarScreen: React.FC = () => {\n  const { theme } = useTheme();\n  const router = useRouter();\n  const scrollRef = useRef<ScrollView>(null);\n  useScrollToTop(scrollRef);\n\n  useFocusEffect(\n    useCallback(() => {\n      scrollRef.current?.scrollTo({ y: 0, animated: false });\n    }, [])\n  );\n\n  // Handle Android hardware back button - navigate to Dashboard\n  useEffect(() => {\n    const backAction = () => {\n      router.replace('/(tabs)');\n      return true;\n    };\n\n    const backHandler = BackHandler.addEventListener('hardwareBackPress', backAction);\n    return () => backHandler.remove();\n  }, [router]);\n\n  const [selectedDate, setSelectedDate] = useState<string>(() => formatDateToLocalISO(getDeviceCurrentDate()));\n  const [currentMonth, setCurrentMonth] = useState<string>(() => formatDateToLocalISO(getDeviceCurrentDate()));\n\n  const workouts = useWorkoutSessionsStore((state: WorkoutSessionsState) => state.workouts);\n  const hydrateWorkouts = useWorkoutSessionsStore((state: WorkoutSessionsState) => state.hydrateWorkouts);\n  const plans = usePlansStore((state: PlansState) => state.plans);\n\n  const markers = useMemo<string[]>(() => {\n    const unique = new Set<string>();\n    workouts.forEach((workout) => {\n      const workoutISO = getWorkoutLocalISO(workout);\n      if (workoutISO) {\n        unique.add(workoutISO);\n      }\n    });\n    return Array.from(unique).sort();\n  }, [workouts]);\n\n  const markersSet = useMemo(() => new Set(markers), [markers]);\n\n  const friendlyFormatter = useMemo(\n    () => new Intl.DateTimeFormat('en-US', { weekday: 'long', month: 'long', day: 'numeric' }),\n    []\n  );\n\n  const friendlyDateLabel = useMemo(() => {\n    const date = parseLocalISODate(selectedDate);\n    return friendlyFormatter.format(date);\n  }, [friendlyFormatter, selectedDate]);\n\n  const planNameLookup = useMemo(() => {\n    const lookup = new Map<string, string>();\n    plans.forEach((plan) => {\n      lookup.set(plan.id, plan.name);\n    });\n    return lookup;\n  }, [plans]);\n\n  const selectedWorkouts = useMemo(() => {\n    return workouts\n      .filter((workout) => getWorkoutLocalISO(workout) === selectedDate)\n      .slice()\n      .sort((a, b) => {\n        const getTimestamp = (workout: WorkoutSessionsState['workouts'][number]): number => {\n          return workout.endTime ?? workout.startTime ?? new Date(workout.date).getTime();\n        };\n\n        return getTimestamp(b) - getTimestamp(a);\n      });\n  }, [selectedDate, workouts]);\n\n  const selectedWorkoutSummaries = useMemo(\n    () =>\n      selectedWorkouts.map((workout) => {\n        const planName = workout.planId ? planNameLookup.get(workout.planId) ?? null : null;\n\n        return {\n          workout,\n          title: formatWorkoutTitle(workout, planName),\n          summary: getWorkoutSummary(workout),\n        };\n      }),\n    [planNameLookup, selectedWorkouts],\n  );\n\n  const hasWorkouts = selectedWorkoutSummaries.length > 0;\n\n  const handleSelectDate = useCallback((isoDate: string) => {\n    setSelectedDate(isoDate);\n  }, []);\n\n  const handleDayLongPress = useCallback((isoDate: string) => {\n    setSelectedDate(isoDate);\n  }, []);\n\n  useFocusEffect(\n    useCallback(() => {\n      const today = formatDateToLocalISO(getDeviceCurrentDate());\n      setSelectedDate(today);\n      setCurrentMonth(today);\n      void hydrateWorkouts();\n\n      return () => {\n        // Reset to current date when leaving the screen to prevent flash on return\n        const endToday = formatDateToLocalISO(getDeviceCurrentDate());\n        setSelectedDate(endToday);\n        setCurrentMonth(endToday);\n      };\n    }, [hydrateWorkouts])\n  );\n\n  const handleViewWorkout = useCallback(\n    (workoutId: string) => {\n      triggerHaptic('selection');\n      router.push({ pathname: '/(tabs)/workout-detail', params: { workoutId, from: 'calendar' } });\n    },\n    [router],\n  );\n\n  return (\n    <TabSwipeContainer ref={scrollRef} contentContainerStyle={[styles.contentContainer, { backgroundColor: theme.primary.bg }]}>\n      <ScreenHeader\n        title=\"Calendar\"\n        subtitle=\"Visualize your training consistency.\"\n      />\n\n      <View style={styles.calendarSection}>\n        <MonthlyCalendar\n          selectedDate={selectedDate}\n          onSelectDate={handleSelectDate}\n          markers={markers}\n          onDayLongPress={handleDayLongPress}\n          currentMonth={currentMonth}\n          onCurrentMonthChange={setCurrentMonth}\n        />\n      </View>\n\n      <View style={styles.summarySection}>\n        <Text variant=\"heading3\" color=\"primary\">\n          {friendlyDateLabel}\n        </Text>\n\n        {hasWorkouts ? (\n          <View style={styles.workoutList}>\n            {selectedWorkoutSummaries.map(({ workout, title, summary }) => (\n              <Pressable\n                key={workout.id}\n                style={styles.summaryPressable}\n                accessibilityRole=\"button\"\n                accessibilityLabel=\"View workout details\"\n                onPress={() => handleViewWorkout(workout.id)}\n              >\n                <SurfaceCard tone=\"card\" padding=\"lg\" showAccentStripe={false} style={styles.workoutCard}>\n                  <View style={styles.workoutHeader}>\n                    <Text variant=\"bodySemibold\" color=\"primary\">\n                      {title}\n                    </Text>\n                    <Text variant=\"caption\" color=\"secondary\">\n                      {summary}\n                    </Text>\n                  </View>\n                </SurfaceCard>\n              </Pressable>\n            ))}\n          </View>\n        ) : (\n          <SurfaceCard tone=\"card\" padding=\"xl\" showAccentStripe={false} style={styles.noWorkoutCard}>\n            <Text variant=\"body\" color=\"secondary\">\n              No session logged.\n            </Text>\n          </SurfaceCard>\n        )}\n      </View>\n    </TabSwipeContainer>\n  );\n};\n\nexport default CalendarScreen;\n\nconst styles = StyleSheet.create({\n  contentContainer: {\n    flexGrow: 1,\n    paddingTop: spacing.xl,\n    paddingHorizontal: spacing.md,\n    paddingBottom: spacing.sm,\n    gap: spacing.xl,\n  },\n  calendarSection: {\n    width: '100%',\n  },\n  summarySection: {\n    width: '100%',\n    gap: spacing.md,\n  },\n  summaryPressable: {\n    width: '100%',\n  },\n  workoutList: {\n    width: '100%',\n    gap: spacing.md,\n  },\n  workoutCard: {\n    gap: spacing.sm,\n    position: 'relative',\n  },\n  workoutHeader: {\n    gap: spacing.xs,\n  },\n  noWorkoutCard: {\n    gap: spacing.xs,\n  },\n});\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\app\\(tabs)\\create-plan.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\app\\(tabs)\\create-program.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\app\\(tabs)\\create-workout.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has missing dependencies: 'hasSaved', 'isEditing', and 'resetSession'. Either include them or remove the dependency array.","line":164,"column":6,"nodeType":"ArrayExpression","endLine":164,"endColumn":39,"suggestions":[{"desc":"Update the dependencies array to be: [isEditing, hasSaved, decodedReturnTo, planId, resetSession, router]","fix":{"range":[4825,4858],"text":"[isEditing, hasSaved, decodedReturnTo, planId, resetSession, router]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useCallback, useEffect, useMemo, useState, useLayoutEffect } from 'react';\r\nimport { Pressable, StyleSheet, View, BackHandler, ActivityIndicator } from 'react-native';\r\nimport { useLocalSearchParams, useRouter } from 'expo-router';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\r\nimport { KeyboardAwareScrollView } from 'react-native-keyboard-aware-scroll-view';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { IconSymbol } from '@/components/ui/icon-symbol';\r\nimport { WorkoutBuilderCard } from '@/components/molecules/WorkoutBuilderCard';\r\nimport { PremiumLimitModal } from '@/components/molecules/PremiumLimitModal';\r\nimport { usePlanBuilderContext } from '@/providers/PlanBuilderProvider';\r\nimport { colors, radius, spacing, sizing } from '@/constants/theme';\r\nimport type { Exercise } from '@/constants/exercises';\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    ...StyleSheet.absoluteFillObject,\r\n    backgroundColor: colors.primary.bg,\r\n  },\r\n  scrollContent: {\r\n    flexGrow: 1,\r\n    gap: spacing.md,\r\n    paddingTop: spacing.lg,\r\n    paddingHorizontal: spacing.md,\r\n    paddingBottom: spacing['2xl'] * 4,\r\n  },\r\n  headerRow: {\r\n    flexDirection: 'row',\r\n    alignItems: 'flex-start',\r\n    justifyContent: 'space-between',\r\n    gap: spacing.md,\r\n  },\r\n  headerContent: {\r\n    flex: 1,\r\n    gap: spacing.xs,\r\n  },\r\n  headerTitle: {\r\n    textAlign: 'left',\r\n  },\r\n  headerSubtitle: {\r\n    textAlign: 'left',\r\n  },\r\n  backButton: {\r\n    padding: spacing.sm,\r\n    paddingTop: spacing.xs,\r\n    borderRadius: radius.full,\r\n  },\r\n  loadingContainer: {\r\n    flex: 1,\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n    gap: spacing.md,\r\n    backgroundColor: colors.primary.bg,\r\n  },\r\n  loadingText: {\r\n    textAlign: 'center',\r\n  },\r\n});\r\n\r\n/**\r\n * CreateWorkoutScreen\r\n * Screen for creating/editing a Workout (collection of exercises).\r\n * \r\n * Uses the new unified WorkoutBuilderCard for an effortless, \r\n * one-screen workout creation experience.\r\n */\r\nconst CreateWorkoutScreen: React.FC = () => {\r\n  const router = useRouter();\r\n  const insets = useSafeAreaInsets();\r\n  const [showLimitModal, setShowLimitModal] = useState(false);\r\n  const [hasSaved, setHasSaved] = useState(false);\r\n  const { planId, returnTo } = useLocalSearchParams<{ \r\n    planId?: string; \r\n    returnTo?: string; \r\n  }>();\r\n  \r\n  // Compute editingPlanId from URL params\r\n  const editingPlanId = useMemo(() => {\r\n    if (planId) {\r\n      const id = Array.isArray(planId) ? planId[0] : planId;\r\n      if (id) return id;\r\n    }\r\n    return null;\r\n  }, [planId]);\r\n\r\n  const {\r\n    planName,\r\n    setPlanName,\r\n    selectedExercises,\r\n    isSaving,\r\n    isEditing,\r\n    isLoading,\r\n    isSaveDisabled,\r\n    saveLabel,\r\n    handleAddExercise,\r\n    handleRemoveExercise,\r\n    handleReorderExercises,\r\n    handleSavePlan,\r\n    setEditingPlanId,\r\n    setIsLoading,\r\n    resetSession,\r\n  } = usePlanBuilderContext();\r\n\r\n  // Dynamic header text\r\n  const headerTitle = isEditing ? 'Edit Workout' : 'Create Workout';\r\n  const headerSubtitle = isEditing \r\n    ? 'Update your workout template' \r\n    : 'Build your custom workout';\r\n\r\n  useLayoutEffect(() => {\r\n    // Set editing plan ID immediately on mount\r\n    setEditingPlanId(editingPlanId);\r\n    // Hide loading after mount\r\n    setIsLoading(false);\r\n    // Fresh session flag on mount\r\n    setHasSaved(false);\r\n\r\n    return () => {\r\n      // Always fully reset builder state when this screen unmounts\r\n      resetSession();\r\n      setHasSaved(false);\r\n    };\r\n  }, [editingPlanId, resetSession, setEditingPlanId, setIsLoading]);\r\n\r\n  // Decode returnTo if provided\r\n  const decodedReturnTo = useMemo(() => {\r\n    if (!returnTo) return null;\r\n    const rawReturnTo = Array.isArray(returnTo) ? returnTo[0] : returnTo;\r\n    try {\r\n      return decodeURIComponent(rawReturnTo);\r\n    } catch {\r\n      return rawReturnTo;\r\n    }\r\n  }, [returnTo]);\r\n\r\n  const handleBackPress = useCallback(() => {\r\n    triggerHaptic('selection');\r\n\r\n    // If this is a new (unsaved) workout, clear any stale builder state\r\n    if (!isEditing && !hasSaved) {\r\n      resetSession();\r\n    }\r\n\r\n    // If returnTo is specified, use it for navigation\r\n    if (decodedReturnTo) {\r\n      router.replace(decodedReturnTo as any);\r\n      return;\r\n    }\r\n\r\n    if (planId) {\r\n      // If this is a nested program workout, just go back\r\n      const idStr = Array.isArray(planId) ? planId[0] : planId;\r\n      if (idStr && (idStr.startsWith('program:') || idStr.includes('%3A'))) {\r\n        router.back();\r\n        return;\r\n      }\r\n      // If editing, go to Plans tab\r\n      router.push('/(tabs)/plans');\r\n    } else {\r\n      // If creating, go to Programs tab\r\n      router.push('/(tabs)/plans');\r\n    }\r\n  }, [router, planId, decodedReturnTo]);\r\n\r\n  // Handle Android hardware back button\r\n  useEffect(() => {\r\n    const backAction = () => {\r\n      handleBackPress();\r\n      return true;\r\n    };\r\n\r\n    const backHandler = BackHandler.addEventListener('hardwareBackPress', backAction);\r\n    return () => backHandler.remove();\r\n  }, [handleBackPress]);\r\n\r\n  const handleSavePress = useCallback(() => {\r\n    void (async () => {\r\n      try {\r\n        const result = await handleSavePlan();\r\n\r\n        if (result === 'success') {\r\n          setHasSaved(true);\r\n          if (decodedReturnTo) {\r\n            router.replace(decodedReturnTo);\r\n            return;\r\n          }\r\n          handleBackPress();\r\n        }\r\n      } catch (error: any) {\r\n        if (error?.message === 'FREE_LIMIT_REACHED') {\r\n          setShowLimitModal(true);\r\n        }\r\n      }\r\n    })();\r\n  }, [handleSavePlan, router, decodedReturnTo, handleBackPress]);\r\n\r\n  // Handle adding exercise from inline search\r\n  const handleAddExerciseFromSearch = useCallback((exercise: Exercise) => {\r\n    handleAddExercise(exercise);\r\n  }, [handleAddExercise]);\r\n\r\n  // Handle browse all exercises - navigate to full add-exercises screen\r\n  const handleBrowseAllExercises = useCallback(() => {\r\n    triggerHaptic('selection');\r\n    router.push('/add-exercises');\r\n  }, [router]);\r\n\r\n  return (\r\n    <>\r\n      <PremiumLimitModal\r\n        visible={showLimitModal}\r\n        onClose={() => setShowLimitModal(false)}\r\n        limitType=\"workout\"\r\n      />\r\n      <View style={[styles.container, { paddingTop: insets.top }]}>\r\n        {isLoading ? (\r\n          <View style={styles.loadingContainer}>\r\n            <ActivityIndicator size=\"large\" color={colors.accent.primary} />\r\n            <Text variant=\"body\" color=\"secondary\" style={styles.loadingText}>\r\n              {isEditing ? 'Loading workout...' : 'Preparing...'}\r\n            </Text>\r\n          </View>\r\n        ) : (\r\n          <KeyboardAwareScrollView\r\n            contentContainerStyle={styles.scrollContent}\r\n            showsVerticalScrollIndicator={false}\r\n            keyboardShouldPersistTaps=\"handled\"\r\n            keyboardDismissMode=\"on-drag\"\r\n            enableOnAndroid\r\n            extraScrollHeight={spacing['2xl'] * 2}\r\n            keyboardOpeningTime={0}\r\n          >\r\n            {/* Header */}\r\n            <View style={styles.headerRow}>\r\n              <View style={styles.headerContent}>\r\n                <Text variant=\"heading2\" color=\"primary\" style={styles.headerTitle} fadeIn>\r\n                  {headerTitle}\r\n                </Text>\r\n                <Text variant=\"body\" color=\"secondary\" style={styles.headerSubtitle} fadeIn>\r\n                  {headerSubtitle}\r\n                </Text>\r\n              </View>\r\n            <Pressable\r\n                accessibilityRole=\"button\"\r\n                accessibilityLabel=\"Go Back\"\r\n                onPress={handleBackPress}\r\n                style={styles.backButton}\r\n              >\r\n                <IconSymbol name=\"arrow-back\" size={sizing.iconMD} color={colors.text.primary} />\r\n              </Pressable>\r\n            </View>\r\n\r\n            {/* Unified Workout Builder Card */}\r\n            <WorkoutBuilderCard\r\n              workoutName={planName}\r\n              onWorkoutNameChange={setPlanName}\r\n              namePlaceholder=\"e.g. Push Day, Leg Day\"\r\n              exercises={selectedExercises}\r\n              onAddExercise={handleAddExerciseFromSearch}\r\n              onRemoveExercise={handleRemoveExercise}\r\n              onReorderExercises={handleReorderExercises}\r\n              onSave={handleSavePress}\r\n              saveLabel={saveLabel}\r\n              isSaving={isSaving}\r\n              isSaveDisabled={isSaveDisabled}\r\n              onBrowseAllExercises={handleBrowseAllExercises}\r\n            />\r\n          </KeyboardAwareScrollView>\r\n        )}\r\n      </View>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default CreateWorkoutScreen;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\app\\(tabs)\\distribution-analytics.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\app\\(tabs)\\edit-plan.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\app\\(tabs)\\index.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'friScale', 'monScale', 'satScale', 'sunScale', 'thuScale', 'tueScale', and 'wedScale'. Either include them or remove the dependency array.","line":415,"column":6,"nodeType":"ArrayExpression","endLine":415,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [friScale, monScale, satScale, sunScale, thuScale, tueScale, wedScale]","fix":{"range":[11361,11363],"text":"[friScale, monScale, satScale, sunScale, thuScale, tueScale, wedScale]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useMemo has an unnecessary dependency: 'activeRotation'. Either exclude it or remove the dependency array.","line":720,"column":6,"nodeType":"ArrayExpression","endLine":720,"endColumn":254,"suggestions":[{"desc":"Update the dependencies array to be: [activeSchedule, getTodayWorkout, planNameLookup, plans.length, todayKey, todayLabel, userPrograms, workouts, activePlanId, isSessionActive, currentSession, activeScheduleRule, activeScheduleResult, getWorkoutName, getExerciseCount]","fix":{"range":[21574,21822],"text":"[activeSchedule, getTodayWorkout, planNameLookup, plans.length, todayKey, todayLabel, userPrograms, workouts, activePlanId, isSessionActive, currentSession, activeScheduleRule, activeScheduleResult, getWorkoutName, getExerciseCount]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useCallback, useEffect, useMemo, useState, useRef } from 'react';\nimport { View, StyleSheet, Pressable, ScrollView } from 'react-native';\nimport { useRouter } from 'expo-router';\nimport { useScrollToTop, useFocusEffect } from '@react-navigation/native';\nimport type { ViewStyle } from 'react-native';\nimport { LinearGradient } from 'expo-linear-gradient';\nimport Animated, {\n  Easing,\n  useAnimatedStyle,\n  useSharedValue,\n  withDelay,\n  withSpring,\n  withTiming,\n  type AnimatedStyle,\n} from 'react-native-reanimated';\n\nimport { SurfaceCard } from '@/components/atoms/SurfaceCard';\nimport { Text } from '@/components/atoms/Text';\nimport { Button } from '@/components/atoms/Button';\nimport { GradientText } from '@/components/atoms/GradientText';\nimport { ScreenHeader } from '@/components/molecules/ScreenHeader';\nimport { TabSwipeContainer } from '@/components/templates/TabSwipeContainer';\nimport { colors, spacing, radius, shadows, sizing } from '@/constants/theme';\nimport { useTheme } from '@/hooks/useTheme';\nimport { WeekDayTracker } from '@/types/dashboard';\nimport { createWeekTracker } from '@/utils/dashboard';\nimport { useSchedulesStore, type SchedulesState } from '@/store/schedulesStore';\nimport { usePlansStore, type Plan, type PlansState } from '@/store/plansStore';\nimport { useProgramsStore } from '@/store/programsStore';\nimport { WEEKDAY_LABELS } from '@/constants/schedule';\nimport type { ScheduleDayKey } from '@/types/schedule';\nimport { triggerHaptic } from '@/utils/haptics';\nimport { useWorkoutSessionsStore, type WorkoutSessionsState } from '@/store/workoutSessionsStore';\nimport type { Workout, WorkoutExercise } from '@/types/workout';\nimport { useSessionStore } from '@/store/sessionStore';\nimport { useUserProfileStore } from '@/store/userProfileStore';\nimport { WorkoutInProgressModal } from '@/components/molecules/WorkoutInProgressModal';\nimport type { ProgramWorkout } from '@/types/premadePlan';\nimport { createSetsWithHistory } from '@/utils/workout';\nimport { useActiveScheduleStore } from '@/store/activeScheduleStore';\nimport { formatDateToLocalISO } from '@/utils/date';\n\n\n\n\n\nconst SCHEDULE_DAY_KEYS: ScheduleDayKey[] = [\n  'sunday',\n  'monday',\n  'tuesday',\n  'wednesday',\n  'thursday',\n  'friday',\n  'saturday',\n];\n\nconst BUBBLE_DIAMETER = sizing.weekBubble;\nconst DAY_BUBBLE_RADIUS = BUBBLE_DIAMETER / 2;\nconst SCROLL_BOTTOM_PADDING = spacing.sm;\nconst CARD_LIFT_TRANSLATE = -2;\nconst CARD_LIFT_DURATION_MS = 200;\nconst CARD_PRESS_SCALE = 0.98;\nconst SCALE_DOWN_DURATION_MS = 150;\nconst scaleDownTimingConfig = {\n  duration: SCALE_DOWN_DURATION_MS,\n  easing: Easing.out(Easing.cubic),\n};\nconst scaleUpSpringConfig = {\n  damping: 15,\n  stiffness: 300,\n};\n\n\ntype ShadowConfig = {\n  shadowOpacity: number;\n  shadowRadius: number;\n  elevation: number;\n};\n\nconst shadowConfigs: Record<'sm' | 'md' | 'lg', ShadowConfig> = {\n  sm: {\n    shadowOpacity: 0,\n    shadowRadius: 0,\n    elevation: 0,\n  },\n  md: {\n    shadowOpacity: 0,\n    shadowRadius: 0,\n    elevation: 0,\n  },\n  lg: {\n    shadowOpacity: 0,\n    shadowRadius: 0,\n    elevation: 0,\n  },\n};\n\ntype CardLiftAnimation = {\n  animatedStyle: AnimatedStyle<ViewStyle>;\n  onPressIn: () => void;\n  onPressOut: () => void;\n};\n\nconst timingConfig = {\n  duration: CARD_LIFT_DURATION_MS,\n  easing: Easing.out(Easing.cubic),\n};\n\nconst useCardLiftAnimation = (initialShadow: ShadowConfig, activeShadow: ShadowConfig): CardLiftAnimation => {\n  const translateY = useSharedValue<number>(0);\n  const shadowOpacity = useSharedValue<number>(initialShadow.shadowOpacity);\n  const shadowRadius = useSharedValue<number>(initialShadow.shadowRadius);\n  const elevation = useSharedValue<number>(initialShadow.elevation);\n  const scale = useSharedValue<number>(1);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateY: translateY.value },\n      { scale: scale.value },\n    ],\n    shadowOpacity: shadowOpacity.value,\n    shadowRadius: shadowRadius.value,\n    elevation: elevation.value,\n  }));\n\n  const handlePressIn = () => {\n    translateY.value = withTiming(CARD_LIFT_TRANSLATE, timingConfig);\n    shadowOpacity.value = withTiming(activeShadow.shadowOpacity, timingConfig);\n    shadowRadius.value = withTiming(activeShadow.shadowRadius, timingConfig);\n    elevation.value = withTiming(activeShadow.elevation, timingConfig);\n    scale.value = withTiming(CARD_PRESS_SCALE, scaleDownTimingConfig);\n  };\n\n  const handlePressOut = () => {\n    translateY.value = withTiming(0, timingConfig);\n    shadowOpacity.value = withTiming(initialShadow.shadowOpacity, timingConfig);\n    shadowRadius.value = withTiming(initialShadow.shadowRadius, timingConfig);\n    elevation.value = withTiming(initialShadow.elevation, timingConfig);\n    scale.value = withSpring(1, scaleUpSpringConfig);\n  };\n\n  return {\n    animatedStyle,\n    onPressIn: handlePressIn,\n    onPressOut: handlePressOut,\n  };\n};\n\nconst styles = StyleSheet.create({\n  backgroundGradient: { flex: 1 },\n  container: {\n    flex: 1,\n  },\n  contentContainer: {\n    paddingTop: spacing.xl,\n    paddingBottom: SCROLL_BOTTOM_PADDING,\n    paddingHorizontal: spacing.md,\n    gap: spacing['2xl'],\n  },\n  dashboardCardHeader: {\n    width: '100%',\n    gap: spacing.xs,\n    paddingBottom: spacing.xs,\n    marginBottom: spacing.md,\n  },\n  pressableStretch: {\n    width: '100%',\n  },\n  streakTitle: {\n    width: '100%',\n    gap: spacing.xs,\n    paddingBottom: spacing.xs,\n    marginBottom: spacing.md,\n  },\n  weekRow: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n    marginHorizontal: -spacing.sm,\n  },\n  dayBubbleWrapper: {\n    flex: 0,\n    alignItems: 'center',\n    gap: spacing.xs,\n  },\n  dayBubbleBase: {\n    width: BUBBLE_DIAMETER,\n    height: BUBBLE_DIAMETER,\n    borderRadius: DAY_BUBBLE_RADIUS,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  dayBubbleBorder: {\n    width: '100%',\n    height: '100%',\n    borderRadius: DAY_BUBBLE_RADIUS,\n    borderWidth: spacing.xxxs,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  dayBubbleContent: {\n    width: '100%',\n    height: '100%',\n    borderRadius: DAY_BUBBLE_RADIUS - spacing.xxxs,\n    justifyContent: 'center',\n    alignItems: 'center',\n    overflow: 'hidden',\n  },\n  dayNumber: {\n    textAlign: 'center',\n  },\n  dayLabel: {\n    textAlign: 'center',\n  },\n  dayLabelToday: {\n    textAlign: 'center',\n  },\n  sectionHeading: {\n    marginBottom: 0,\n  },\n  sectionHeader: {\n    width: '100%',\n    gap: spacing.xs,\n    paddingBottom: 0,\n  },\n  todaysPlanCard: {\n    borderRadius: radius.lg,\n    overflow: 'hidden',\n    ...shadows.md,\n  },\n\n  todaysPlanContainer: {\n    width: '100%',\n  },\n  todaysPlanBody: {\n    width: '100%',\n    gap: spacing.lg,\n  },\n  planStartButton: {\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  planStartButtonGradient: {\n    width: '100%',\n    height: '100%',\n    borderRadius: radius.full,\n    position: 'absolute',\n  },\n  todaysPlanSubCard: {\n    borderColor: 'transparent',\n    borderWidth: 0,\n  },\n  todaysPlanEmptyContent: {\n    gap: spacing.sm,\n    width: '100%',\n  },\n  todaysPlanActions: {\n    marginTop: spacing.md,\n    width: '100%',\n  },\n  todaysMeta: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    gap: spacing.lg,\n    marginTop: spacing.lg,\n  },\n  todaysMetaItem: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    gap: spacing.sm,\n  },\n  metaDot: {\n    width: 10,\n    height: 10,\n    borderRadius: radius.full,\n    backgroundColor: colors.accent.orange,\n  },\n  quickLinksList: {\n    gap: spacing.lg,\n  },\n  inlineCard: {\n    borderWidth: StyleSheet.hairlineWidth,\n    borderColor: colors.border.light,\n    borderRadius: radius.lg,\n    backgroundColor: colors.surface.card,\n    shadowColor: 'transparent',\n    shadowOpacity: 0,\n    shadowRadius: 0,\n    shadowOffset: { width: 0, height: 0 },\n    elevation: 0,\n  },\n  recentEmptyCard: {\n    borderWidth: 0,\n    borderColor: 'transparent',\n  },\n  quickLinkRow: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n    gap: spacing.lg,\n  },\n  quickLinkInfo: {\n    flex: 1,\n    gap: spacing.xs,\n  },\n  quickLinkButton: {\n    width: 44,\n    height: 44,\n    borderRadius: radius.full,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  recentWorkoutsList: {\n    gap: spacing.md,\n  },\n  recentCardHeader: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n    marginBottom: spacing.sm,\n  },\n\n  todaysPlanInfo: {\n    flex: 1,\n    gap: spacing.xs,\n  },\n  todaysPlanStartButton: {\n    borderRadius: radius.md,\n  },\n  todaysPlanStartGradient: {\n    borderRadius: radius.md,\n    padding: spacing.xxxs,\n  },\n  todaysPlanStartContent: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    gap: spacing.xs,\n    borderRadius: radius.md,\n    backgroundColor: colors.surface.card,\n    paddingVertical: spacing.xs,\n    paddingHorizontal: spacing.sm,\n  },\n  todaysPlanStartIcon: {\n    width: spacing.lg,\n    height: spacing.lg,\n    borderRadius: radius.full,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  todaysPlanStartIconMask: {\n    width: spacing.lg,\n    height: spacing.lg,\n  },\n  todaysPlanStartIconFill: {\n    ...StyleSheet.absoluteFillObject,\n  },\n});\n\nconst formatElapsedForSubcard = (minutes: number): string => {\n  if (minutes >= 60) {\n    const hours = Math.floor(minutes / 60);\n    const remainingMinutes = minutes % 60;\n    return remainingMinutes > 0 ? `${hours}h ${remainingMinutes}m` : `${hours}h`;\n  }\n  return `${minutes}m`;\n};\n\nconst DashboardScreen: React.FC = () => {\n  const { theme } = useTheme();\n  const workouts = useWorkoutSessionsStore((state: WorkoutSessionsState) => state.workouts);\n  const profile = useUserProfileStore((state) => state.profile);\n\n  const [workoutInProgressVisible, setWorkoutInProgressVisible] = useState<boolean>(false);\n\n  // Get firstName and userInitial reactively from store state\n  const firstName = profile?.firstName || null;\n  const userInitial = firstName ? firstName.charAt(0).toUpperCase() : null;\n\n  const weekTracker = useMemo<WeekDayTracker[]>(() => {\n    return createWeekTracker(workouts);\n  }, [workouts]);\n\n  const getDayVariant = (day: WeekDayTracker): 'rest' | 'workout' => {\n    return day.hasWorkout ? 'workout' : 'rest';\n  };\n\n  const weeklyTrackerTranslateY = useSharedValue<number>(0);\n  const weeklyTrackerOpacity = useSharedValue<number>(1);\n  const todaysPlanTranslateY = useSharedValue<number>(0);\n  const todaysPlanOpacity = useSharedValue<number>(1);\n\n  const recentWorkoutsTranslateY = useSharedValue<number>(0);\n  const recentWorkoutsOpacity = useSharedValue<number>(1);\n  const sunScale = useSharedValue<number>(0);\n  const monScale = useSharedValue<number>(0);\n  const tueScale = useSharedValue<number>(0);\n  const wedScale = useSharedValue<number>(0);\n  const thuScale = useSharedValue<number>(0);\n  const friScale = useSharedValue<number>(0);\n  const satScale = useSharedValue<number>(0);\n\n  useEffect(() => {\n    const springConfig = {\n      damping: 12,\n      stiffness: 200,\n      mass: 0.5,\n    };\n\n    const popInStartDelay = 300;\n    const staggerMs = 50;\n\n    [sunScale, monScale, tueScale, wedScale, thuScale, friScale, satScale].forEach((scale, index) => {\n      scale.value = withDelay(popInStartDelay + index * staggerMs, withSpring(1, springConfig));\n    });\n  }, []);\n\n  const weeklyTrackerAnimatedStyle = useAnimatedStyle(() => ({\n    transform: [{ translateY: weeklyTrackerTranslateY.value }],\n    opacity: weeklyTrackerOpacity.value,\n  }));\n\n  const todaysPlanAnimatedStyle = useAnimatedStyle(() => ({\n    transform: [{ translateY: todaysPlanTranslateY.value }],\n    opacity: todaysPlanOpacity.value,\n  }));\n\n\n\n  const recentWorkoutsAnimatedStyle = useAnimatedStyle(() => ({\n    transform: [{ translateY: recentWorkoutsTranslateY.value }],\n    opacity: recentWorkoutsOpacity.value,\n  }));\n\n  const sunAnimatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: sunScale.value }],\n  }));\n\n  const monAnimatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: monScale.value }],\n  }));\n\n  const tueAnimatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: tueScale.value }],\n  }));\n\n  const wedAnimatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: wedScale.value }],\n  }));\n\n  const thuAnimatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: thuScale.value }],\n  }));\n\n  const friAnimatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: friScale.value }],\n  }));\n\n  const satAnimatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: satScale.value }],\n  }));\n\n  const dayAnimatedStyles = [\n    sunAnimatedStyle,\n    monAnimatedStyle,\n    tueAnimatedStyle,\n    wedAnimatedStyle,\n    thuAnimatedStyle,\n    friAnimatedStyle,\n    satAnimatedStyle,\n  ];\n\n  const router = useRouter();\n  const scrollRef = useRef<ScrollView>(null);\n  useScrollToTop(scrollRef);\n\n  useFocusEffect(\n    useCallback(() => {\n      scrollRef.current?.scrollTo({ y: 0, animated: false });\n    }, [])\n  );\n\n  const schedules = useSchedulesStore((state: SchedulesState) => state.schedules);\n  const hydrateSchedules = useSchedulesStore((state: SchedulesState) => state.hydrateSchedules);\n  const plans = usePlansStore((state: PlansState) => state.plans);\n  const hydratePlans = usePlansStore((state: PlansState) => state.hydratePlans);\n  const { activeRotation, hydratePrograms, userPrograms, getTodayWorkout, activePlanId } = useProgramsStore();\n  const hydrateWorkouts = useWorkoutSessionsStore((state: WorkoutSessionsState) => state.hydrateWorkouts);\n  const activeScheduleResult = useActiveScheduleStore((state) => state.getTodaysWorkout());\n  const activeScheduleRule = useActiveScheduleStore((state) => state.state.activeRule);\n  const startSession = useSessionStore((state) => state.startSession);\n  const setCompletionOverlayVisible = useSessionStore((state) => state.setCompletionOverlayVisible);\n  const isSessionActive = useSessionStore((state) => state.isSessionActive);\n  const currentSession = useSessionStore((state) => state.currentSession);\n\n  // Helper function to get workout name from ID\n  const getWorkoutName = (workoutId: string | null): string => {\n    if (!workoutId) return 'Rest Day';\n\n    // Check plans (My Workouts)\n    const plan = plans.find((p) => p.id === workoutId);\n    if (plan) return plan.name;\n\n    // Check user programs\n    for (const program of userPrograms) {\n      const workout = program.workouts.find((w) => w.id === workoutId);\n      if (workout) return workout.name;\n    }\n\n    return 'Unknown Workout';\n  };\n\n  // Helper function to get exercise count from workout ID\n  const getExerciseCount = (workoutId: string | null): number => {\n    if (!workoutId) return 0;\n\n    // Check plans (My Workouts)\n    const plan = plans.find((p) => p.id === workoutId);\n    if (plan) return plan.exercises.length;\n\n    // Check user programs\n    for (const program of userPrograms) {\n      const workout = program.workouts.find((w) => w.id === workoutId);\n      if (workout) return workout.exercises.length;\n    }\n\n    return 0;\n  };\n\n  useEffect(() => {\n    void hydrateSchedules();\n  }, [hydrateSchedules]);\n\n  useEffect(() => {\n    void hydratePlans();\n  }, [hydratePlans]);\n\n  useEffect(() => {\n    void hydratePrograms();\n  }, [hydratePrograms]);\n\n  useEffect(() => {\n    void hydrateWorkouts();\n  }, [hydrateWorkouts]);\n\n  const todayKey: ScheduleDayKey = useMemo(() => {\n    const dayIndex = new Date().getDay();\n    return SCHEDULE_DAY_KEYS[dayIndex];\n  }, []);\n\n  const todayLabel = useMemo(() => {\n    const match = WEEKDAY_LABELS.find((entry) => entry.key === todayKey);\n    return match?.label ?? 'Today';\n  }, [todayKey]);\n\n  const planNameLookup = useMemo(() => {\n    return plans.reduce<Record<string, Plan>>((acc, plan) => {\n      acc[plan.id] = plan;\n      return acc;\n    }, {});\n  }, [plans]);\n\n  const activeSchedule = schedules[0] ?? null;\n\n  type TodaysCardState =\n    | { variant: 'noSchedule' }\n    | { variant: 'noPlans' }\n    | { variant: 'rest'; dayLabel: string }\n    | { variant: 'plan'; dayLabel: string; plan: Plan }\n    | { variant: 'rotation'; programName: string; workout: ProgramWorkout; programId: string }\n    | { variant: 'standaloneRotation'; dayLabel: string; plan: Plan; dayNumber: number }\n    | { variant: 'completed'; workout: Workout }\n    | { variant: 'ongoing'; sessionName: string | null; exerciseCount: number; elapsedMinutes: number }\n    | { variant: 'activeSchedule'; dayLabel: string; workoutId: string | null; context?: string };\n\n  const todaysCardState: TodaysCardState = useMemo(() => {\n    // PRIORITY 1: Check for ongoing workout session (highest priority)\n    if (isSessionActive && currentSession) {\n      const elapsedMs = Date.now() - currentSession.startTime;\n      const elapsedMinutes = Math.floor(elapsedMs / 60000);\n      return {\n        variant: 'ongoing',\n        sessionName: currentSession.name,\n        exerciseCount: currentSession.exercises.length,\n        elapsedMinutes,\n      };\n    }\n\n    // Check for completed workout today\n    const todayString = new Date().toDateString();\n    const todaysWorkouts = workouts.filter(w => {\n      const timestamp = w.endTime ?? w.startTime ?? new Date(w.date).getTime();\n      return new Date(timestamp).toDateString() === todayString;\n    });\n\n    if (todaysWorkouts.length > 0) {\n      // Sort by most recent\n      const latestWorkout = todaysWorkouts.sort((a, b) => {\n        const aTime = a.endTime ?? a.startTime ?? new Date(a.date).getTime();\n        const bTime = b.endTime ?? b.startTime ?? new Date(b.date).getTime();\n        return bTime - aTime;\n      })[0];\n\n      return { variant: 'completed', workout: latestWorkout };\n    }\n\n    // PRIORITY 3: Check new activeScheduleStore (unified schedule system)\n    if (activeScheduleRule && activeScheduleResult.source !== 'none') {\n      const workoutName = getWorkoutName(activeScheduleResult.workoutId);\n      const exerciseCount = getExerciseCount(activeScheduleResult.workoutId);\n      const contextText = activeScheduleResult.workoutId ? `${exerciseCount} ${exerciseCount === 1 ? 'exercise' : 'exercises'}` : 'Take the day off';\n      return {\n        variant: 'activeSchedule',\n        dayLabel: workoutName,\n        workoutId: activeScheduleResult.workoutId,\n        context: contextText,\n      };\n    }\n\n    // Check for active rotation or active plan (Legacy System)\n    const todayProgramWorkout = getTodayWorkout();\n\n    // Check if there's an active plan\n    const activePlan = userPrograms.find(p => p.id === activePlanId);\n\n    // If we have an active plan but no workout (e.g., future start date or rest day)\n    if (activePlan && activePlan.schedule) {\n      if (todayProgramWorkout) {\n        return {\n          variant: 'rotation',\n          programName: activePlan.name,\n          workout: todayProgramWorkout,\n          programId: activePlan.id\n        };\n      }\n\n      // Active plan exists but no workout today (future start date or rest day in rotation)\n      if (activePlan.schedule.type === 'rotation' && activePlan.schedule.rotation?.startDate) {\n        const now = new Date();\n        const start = new Date(activePlan.schedule.rotation.startDate);\n        now.setHours(0, 0, 0, 0);\n        start.setHours(0, 0, 0, 0);\n        const diffDays = Math.floor((now.getTime() - start.getTime()) / (1000 * 60 * 60 * 24));\n\n        if (diffDays < 0) {\n          // Plan starts in the future\n          return { variant: 'rest', dayLabel: todayLabel };\n        }\n      }\n    }\n\n    if (plans.length === 0 && userPrograms.length === 0) {\n      return { variant: 'noPlans' };\n    }\n\n    if (!activeSchedule) {\n      return { variant: 'noSchedule' };\n    }\n\n    // Check for standalone rotating schedule\n    if (activeSchedule.type === 'rotating' && activeSchedule.rotating) {\n      const { days, startDate } = activeSchedule.rotating;\n\n      if (days.length === 0) {\n        return { variant: 'rest', dayLabel: todayLabel };\n      }\n\n      if (!startDate) {\n        // No start date set, show as rest\n        return { variant: 'rest', dayLabel: todayLabel };\n      }\n\n      // Calculate which day of the rotation we're on\n      const now = new Date();\n      const start = new Date(startDate);\n      now.setHours(0, 0, 0, 0);\n      start.setHours(0, 0, 0, 0);\n      const diffDays = Math.floor((now.getTime() - start.getTime()) / (1000 * 60 * 60 * 24));\n\n      if (diffDays < 0) {\n        // Schedule starts in the future\n        return { variant: 'rest', dayLabel: todayLabel };\n      }\n\n      const currentDayIndex = diffDays % days.length;\n      const currentDay = days[currentDayIndex];\n\n      if (!currentDay || !currentDay.planId) {\n        // Rest day in the rotation\n        return { variant: 'rest', dayLabel: `Day ${currentDay?.dayNumber ?? currentDayIndex + 1}` };\n      }\n\n      // Find the plan for today\n      const plan = planNameLookup[currentDay.planId];\n      if (!plan) {\n        return { variant: 'rest', dayLabel: `Day ${currentDay.dayNumber}` };\n      }\n\n      return {\n        variant: 'standaloneRotation',\n        dayLabel: `Day ${currentDay.dayNumber}`,\n        plan,\n        dayNumber: currentDay.dayNumber,\n      };\n    }\n\n    // Weekly schedule\n    const todaysPlanId = activeSchedule.weekdays[todayKey];\n\n    if (!todaysPlanId) {\n      return { variant: 'rest', dayLabel: todayLabel };\n    }\n\n    const plan = planNameLookup[todaysPlanId];\n\n    if (!plan) {\n      return { variant: 'rest', dayLabel: todayLabel };\n    }\n\n    return { variant: 'plan', dayLabel: todayLabel, plan };\n  }, [activeSchedule, activeRotation, getTodayWorkout, planNameLookup, plans.length, todayKey, todayLabel, userPrograms, workouts, activePlanId, isSessionActive, currentSession, activeScheduleRule, activeScheduleResult, getWorkoutName, getExerciseCount]);\n\n  const todaysPlan = todaysCardState.variant === 'plan'\n    ? todaysCardState.plan\n    : todaysCardState.variant === 'standaloneRotation'\n      ? todaysCardState.plan\n      : null;\n  const rotationWorkout = todaysCardState.variant === 'rotation' ? todaysCardState.workout : null;\n\n  const handleTodaysCardPress = useCallback(() => {\n    if (todaysCardState.variant === 'plan' || todaysCardState.variant === 'rotation' || todaysCardState.variant === 'standaloneRotation' || todaysCardState.variant === 'noPlans') {\n      return;\n    }\n\n    triggerHaptic('selection');\n\n    if (todaysCardState.variant === 'ongoing') {\n      router.push('/(tabs)/workout');\n      return;\n    }\n\n    if (todaysCardState.variant === 'completed') {\n      router.push({ pathname: '/(tabs)/workout-detail', params: { workoutId: todaysCardState.workout.id, from: 'dashboard' } });\n      return;\n    }\n\n    router.push('/(tabs)/schedule-editor');\n  }, [router, todaysCardState]);\n\n  const handleCreatePlanPress = useCallback(() => {\n    triggerHaptic('selection');\n    router.push('/(tabs)/plans');\n  }, [router]);\n\n  const handlePlanActionStart = useCallback(() => {\n    if (!todaysPlan && !rotationWorkout) {\n      return;\n    }\n\n    triggerHaptic('selection');\n\n    const doStartSession = () => {\n      setCompletionOverlayVisible(false);\n\n      const target = todaysPlan || rotationWorkout;\n      if (!target) return;\n\n      const historySetCounts: Record<string, number> = {};\n      const workoutExercises: WorkoutExercise[] = target.exercises.map((exercise) => {\n        const { sets, historySetCount } = createSetsWithHistory(exercise.name, workouts);\n        historySetCounts[exercise.name] = historySetCount;\n        return {\n          name: exercise.name,\n          sets,\n        };\n      });\n\n      const planId = todaysCardState.variant === 'rotation'\n        ? todaysCardState.programId\n        : (todaysPlan?.id ?? '');\n      const sessionName = todaysCardState.variant === 'rotation'\n        ? (rotationWorkout?.name ?? null)\n        : todaysCardState.variant === 'standaloneRotation'\n          ? `${todaysCardState.dayLabel}: ${todaysPlan?.name ?? 'Workout'}`\n          : (todaysPlan?.name ?? null);\n\n      startSession(planId, workoutExercises, sessionName, historySetCounts);\n      router.push('/(tabs)/workout');\n    };\n\n    if (isSessionActive && currentSession) {\n      setWorkoutInProgressVisible(true);\n      return;\n    }\n\n    doStartSession();\n  }, [todaysPlan, rotationWorkout, startSession, router, setCompletionOverlayVisible, todaysCardState, workouts, isSessionActive, currentSession]);\n\n  const recentWorkouts = useMemo<Workout[]>(() => {\n    if (workouts.length === 0) {\n      return [];\n    }\n\n    return [...workouts]\n      .sort((a, b) => {\n        const aTimestamp = a.endTime ?? a.startTime ?? new Date(a.date).getTime();\n        const bTimestamp = b.endTime ?? b.startTime ?? new Date(b.date).getTime();\n        return bTimestamp - aTimestamp;\n      })\n      .slice(0, 3);\n  }, [workouts]);\n\n  const formatWorkoutSubtitle = useCallback((workout: Workout) => {\n    const completedExercises = workout.exercises.filter((exercise) =>\n      exercise.sets.length > 0 ? exercise.sets.some((set) => set.completed) : false\n    );\n    const completedCount = completedExercises.length;\n    const base = `${completedCount} ${completedCount === 1 ? 'exercise' : 'exercises'}`;\n    const durationMinutes = workout.duration ? Math.max(Math.round(workout.duration / 60), 1) : null;\n\n    if (durationMinutes) {\n      if (durationMinutes >= 60) {\n        const hours = Math.floor(durationMinutes / 60);\n        const minutes = durationMinutes % 60;\n        return `${base}  ${hours} hr ${minutes} min`;\n      }\n      return `${base}  ${durationMinutes} min`;\n    }\n\n    return base;\n  }, []);\n\n  const formatWorkoutDateLabel = useCallback((workout: Workout) => {\n    const timestamp = workout.endTime ?? workout.startTime ?? new Date(workout.date).getTime();\n    const date = new Date(timestamp);\n\n    return date.toLocaleDateString('en-US', {\n      month: 'short',\n      day: 'numeric',\n    });\n  }, []);\n\n\n  const recentWorkoutLiftOne = useCardLiftAnimation(shadowConfigs.sm, shadowConfigs.md);\n  const recentWorkoutLiftTwo = useCardLiftAnimation(shadowConfigs.sm, shadowConfigs.md);\n  const recentWorkoutLiftThree = useCardLiftAnimation(shadowConfigs.sm, shadowConfigs.md);\n  const recentWorkoutLifts = [recentWorkoutLiftOne, recentWorkoutLiftTwo, recentWorkoutLiftThree];\n\n  return (\n    <TabSwipeContainer ref={scrollRef}>\n      <LinearGradient\n        colors={[theme.primary.bg, theme.primary.light, theme.primary.bg]}\n        locations={[0, 0.55, 1]}\n        start={{ x: 0, y: 0 }}\n        end={{ x: 0.8, y: 1 }}\n        style={styles.backgroundGradient}\n      >\n        <View style={[styles.container, { backgroundColor: theme.primary.bg }]}>\n          <WorkoutInProgressModal\n            visible={workoutInProgressVisible}\n            sessionName={currentSession?.name ?? 'Current Workout'}\n            elapsedMinutes={currentSession ? Math.floor((Date.now() - currentSession.startTime) / 60000) : 0}\n            onResume={() => {\n              setWorkoutInProgressVisible(false);\n              router.push('/(tabs)/workout');\n            }}\n            onCancel={() => {\n              setWorkoutInProgressVisible(false);\n            }}\n          />\n          <View style={styles.contentContainer}>\n            <ScreenHeader\n              title={firstName ? `Welcome, ${firstName}!` : 'Welcome!'}\n              subtitle=\"Your fitness journey starts here.\"\n              onProfilePress={() => router.push('/modals/profile')}\n              userInitial={userInitial}\n            />\n\n            <Animated.View style={weeklyTrackerAnimatedStyle}>\n              <Pressable style={styles.pressableStretch}>\n                <SurfaceCard tone=\"card\" padding=\"xl\" showAccentStripe={true} style={{ borderWidth: 0, marginTop: -spacing.md }}>\n                  <View style={styles.dashboardCardHeader}>\n                    <Text variant=\"heading3\" color=\"primary\">\n                      Your Week\n                    </Text>\n                  </View>\n\n                  <View style={styles.weekRow}>\n                    {weekTracker.map((day, index) => {\n                      const variant = getDayVariant(day);\n                      const isWorkoutDay = variant === 'workout';\n                      const isToday = day.isToday;\n                      const borderStyle = isWorkoutDay\n                        ? [\n                          styles.dayBubbleBorder,\n                          { backgroundColor: theme.accent.orange, borderColor: theme.accent.orange },\n                        ]\n                        : [\n                          styles.dayBubbleBorder,\n                          { backgroundColor: theme.surface.elevated, borderColor: theme.accent.orange },\n                        ];\n                      const contentStyle = [\n                        styles.dayBubbleContent,\n                        isWorkoutDay\n                          ? { backgroundColor: theme.accent.orange }\n                          : { backgroundColor: theme.surface.elevated },\n                      ];\n                      const dayNumberColor: 'primary' | 'onAccent' = isWorkoutDay ? 'onAccent' : 'primary';\n\n                      const handleDayPress = () => {\n                        if (day.hasWorkout) {\n                          // Extract ISO date from day.id (format: YYYY-MM-DD-label)\n                          const dayISO = day.id.split('-').slice(0, 3).join('-');\n\n                          // Find the workout for this day by comparing ISO dates\n                          const workout = workouts.find(w => {\n                            const workoutISO = w.startTime\n                              ? formatDateToLocalISO(new Date(w.startTime))\n                              : w.date ? formatDateToLocalISO(new Date(w.date)) : null;\n                            return workoutISO === dayISO;\n                          });\n\n                          if (workout) {\n                            triggerHaptic('selection');\n                            router.push({ pathname: '/(tabs)/workout-detail', params: { workoutId: workout.id, from: 'dashboard' } });\n                          }\n                        }\n                      };\n\n                      return (\n                        <Pressable key={day.id} style={styles.dayBubbleWrapper} onPress={handleDayPress}>\n                          <Animated.View style={[styles.dayBubbleBase, dayAnimatedStyles[index]]}>\n                            <View style={borderStyle}>\n                              <View style={contentStyle}>\n                                <Text variant=\"bodySemibold\" color={dayNumberColor}>\n                                  {day.date}\n                                </Text>\n                              </View>\n                            </View>\n                          </Animated.View>\n                          {isToday ? (\n                            <GradientText variant=\"caption\" style={styles.dayLabelToday}>\n                              {day.label}\n                            </GradientText>\n                          ) : (\n                            <Text variant=\"caption\" color=\"secondary\" style={styles.dayLabel}>\n                              {day.label}\n                            </Text>\n                          )}\n                        </Pressable>\n                      );\n                    })}\n                  </View>\n                </SurfaceCard>\n              </Pressable>\n            </Animated.View>\n\n            <Animated.View style={todaysPlanAnimatedStyle}>\n              <SurfaceCard tone=\"card\" padding=\"xl\" showAccentStripe={true} style={{ borderWidth: 0, marginTop: -spacing.md }}>\n                <View style={styles.todaysPlanContainer}>\n                  <View style={styles.dashboardCardHeader}>\n                    <Text variant=\"heading3\" color=\"primary\">\n                      Today&apos;s Workout\n                    </Text>\n                  </View>\n                  <View style={styles.todaysPlanBody}>\n                      {todaysCardState.variant === 'ongoing' ? (\n                        <SurfaceCard\n                          tone=\"neutral\"\n                          padding=\"lg\"\n                          showAccentStripe={false}\n                          style={styles.inlineCard}\n                        >\n                          <View style={styles.quickLinkRow}>\n                            <View style={styles.quickLinkInfo}>\n                              <Text variant=\"bodySemibold\" color=\"primary\">\n                                {todaysCardState.sessionName ?? 'Workout in Progress'}\n                              </Text>\n                              <Text variant=\"body\" color=\"secondary\">\n                                {todaysCardState.exerciseCount} {todaysCardState.exerciseCount === 1 ? 'exercise' : 'exercises'}  {formatElapsedForSubcard(todaysCardState.elapsedMinutes)} elapsed\n                              </Text>\n                            </View>\n                            <Pressable\n                              style={styles.planStartButton}\n                              onPress={handleTodaysCardPress}\n                              accessibilityRole=\"button\"\n                              accessibilityLabel=\"Resume ongoing workout\"\n                            >\n                              <View style={styles.quickLinkButton}>\n                                <LinearGradient\n                                  colors={[theme.accent.gradientStart, theme.accent.gradientEnd]}\n                                  start={{ x: 0, y: 0 }}\n                                  end={{ x: 1, y: 1 }}\n                                  style={styles.planStartButtonGradient}\n                                />\n                                <Text variant=\"bodySemibold\" color=\"onAccent\">\n                                  \n                                </Text>\n                              </View>\n                            </Pressable>\n                          </View>\n                        </SurfaceCard>\n                      ) : todaysCardState.variant === 'activeSchedule' ? (\n                        <SurfaceCard\n                          tone=\"neutral\"\n                          padding=\"lg\"\n                          showAccentStripe={false}\n                          style={styles.inlineCard}\n                        >\n                          <View style={styles.quickLinkRow}>\n                            <View style={styles.quickLinkInfo}>\n                              <Text variant=\"bodySemibold\" color=\"primary\">\n                                {todaysCardState.workoutId ? todaysCardState.dayLabel : 'Rest Day'}\n                              </Text>\n                              <Text variant=\"body\" color=\"secondary\">\n                                {todaysCardState.context || (todaysCardState.workoutId ? 'Scheduled workout' : 'Take the day off')}\n                              </Text>\n                            </View>\n                            {todaysCardState.workoutId && (\n                              <Pressable\n                                style={styles.planStartButton}\n                                onPress={() => {\n                                  triggerHaptic('selection');\n\n                                  // Find the workout from either plans or user programs\n                                  let targetWorkout: Plan | ProgramWorkout | null = null;\n                                  let planId = '';\n                                  let sessionName = '';\n\n                                  const plan = plans.find((p) => p.id === todaysCardState.workoutId);\n                                  if (plan) {\n                                    targetWorkout = plan;\n                                    planId = plan.id;\n                                    sessionName = plan.name;\n                                  } else {\n                                    for (const program of userPrograms) {\n                                      const workout = program.workouts.find((w) => w.id === todaysCardState.workoutId);\n                                      if (workout) {\n                                        targetWorkout = workout;\n                                        planId = program.id;\n                                        sessionName = workout.name;\n                                        break;\n                                      }\n                                    }\n                                  }\n\n                                  if (targetWorkout) {\n                                    const historySetCounts: Record<string, number> = {};\n                                    const workoutExercises: WorkoutExercise[] = targetWorkout.exercises.map((exercise) => {\n                                      const { sets, historySetCount } = createSetsWithHistory(exercise.name, workouts);\n                                      historySetCounts[exercise.name] = historySetCount;\n                                      return {\n                                        name: exercise.name,\n                                        sets,\n                                      };\n                                    });\n\n                                    startSession(planId, workoutExercises, sessionName, historySetCounts);\n                                  }\n\n                                  router.push('/(tabs)/workout');\n                                }}\n                                accessibilityRole=\"button\"\n                                accessibilityLabel=\"Start today's workout\"\n                              >\n                                <View style={styles.quickLinkButton}>\n                                  <LinearGradient\n                                    colors={[theme.accent.gradientStart, theme.accent.gradientEnd]}\n                                    start={{ x: 0, y: 0 }}\n                                    end={{ x: 1, y: 1 }}\n                                    style={styles.planStartButtonGradient}\n                                  />\n                                  <Text variant=\"bodySemibold\" color=\"onAccent\">\n                                    \n                                  </Text>\n                                </View>\n                              </Pressable>\n                            )}\n                          </View>\n                        </SurfaceCard>\n                      ) : todaysCardState.variant === 'plan' || todaysCardState.variant === 'rotation' || todaysCardState.variant === 'standaloneRotation' ? (\n                        <SurfaceCard\n                          tone=\"neutral\"\n                          padding=\"lg\"\n                          showAccentStripe={false}\n                          style={styles.inlineCard}\n                        >\n                          <View style={styles.quickLinkRow}>\n                            <View style={styles.quickLinkInfo}>\n                              <Text variant=\"bodySemibold\" color=\"primary\">\n                                {todaysCardState.variant === 'rotation'\n                                  ? `${todaysCardState.programName}: ${todaysCardState.workout.name}`\n                                  : todaysCardState.variant === 'standaloneRotation'\n                                    ? `${todaysCardState.dayLabel}: ${todaysCardState.plan.name}`\n                                    : todaysCardState.plan.name}\n                              </Text>\n                              <Text variant=\"body\" color=\"secondary\">\n                                {todaysCardState.variant === 'rotation'\n                                  ? `${todaysCardState.workout.exercises.length} exercises`\n                                  : todaysCardState.variant === 'standaloneRotation'\n                                    ? `${todaysCardState.plan.exercises.length} exercises`\n                                    : `${todaysCardState.plan.exercises.length} exercises`}\n                              </Text>\n                            </View>\n                            <Pressable\n                              style={styles.planStartButton}\n                              onPress={handlePlanActionStart}\n                              accessibilityRole=\"button\"\n                              accessibilityLabel=\"Start today's workout\"\n                            >\n                              <View style={styles.quickLinkButton}>\n                                <LinearGradient\n                                  colors={[theme.accent.gradientStart, theme.accent.gradientEnd]}\n                                  start={{ x: 0, y: 0 }}\n                                  end={{ x: 1, y: 1 }}\n                                  style={styles.planStartButtonGradient}\n                                />\n                                <Text variant=\"bodySemibold\" color=\"onAccent\">\n                                  \n                                </Text>\n                              </View>\n                            </Pressable>\n                          </View>\n                        </SurfaceCard>\n                      ) : todaysCardState.variant === 'completed' ? (\n                        <Pressable\n                          style={styles.pressableStretch}\n                          onPress={() => {\n                            triggerHaptic('selection');\n                            router.push({ pathname: '/(tabs)/workout-detail', params: { workoutId: todaysCardState.workout.id, from: 'dashboard' } });\n                          }}\n                        >\n                          <SurfaceCard\n                            tone=\"neutral\"\n                            padding=\"lg\"\n                            showAccentStripe={false}\n                            style={styles.inlineCard}\n                          >\n                            <View style={styles.recentCardHeader}>\n                              <Text variant=\"bodySemibold\" color=\"primary\">\n                                {todaysCardState.workout.name\n                                  ? todaysCardState.workout.name\n                                  : todaysCardState.workout.planId\n                                    ? planNameLookup[todaysCardState.workout.planId]?.name ?? `${formatWorkoutDateLabel(todaysCardState.workout)} Session`\n                                    : `${formatWorkoutDateLabel(todaysCardState.workout)} Session`}\n                              </Text>\n                              <Text variant=\"body\" color=\"secondary\">\n                                {formatWorkoutDateLabel(todaysCardState.workout)}\n                              </Text>\n                            </View>\n                            <Text variant=\"body\" color=\"secondary\">\n                              {formatWorkoutSubtitle(todaysCardState.workout)}\n                            </Text>\n                          </SurfaceCard>\n                        </Pressable>\n                      ) : todaysCardState.variant === 'noPlans' ? (\n                        <SurfaceCard\n                          tone=\"neutral\"\n                          padding=\"lg\"\n                          showAccentStripe={false}\n                          style={styles.inlineCard}\n                        >\n                          <View style={styles.todaysPlanEmptyContent}>\n                            <Text variant=\"bodySemibold\" color=\"primary\">\n                              Create a workout plan\n                            </Text>\n                            <Text variant=\"body\" color=\"secondary\">\n                              No workout plans yet. Build one to see it here.\n                            </Text>\n                            <View style={styles.todaysPlanActions}>\n                              <Button label=\"Create Workout Plan\" size=\"md\" onPress={handleCreatePlanPress} />\n                            </View>\n                          </View>\n                        </SurfaceCard>\n                      ) : (\n                        <SurfaceCard\n                          tone=\"neutral\"\n                          padding=\"lg\"\n                          showAccentStripe={false}\n                          style={styles.inlineCard}\n                        >\n                          <View style={styles.quickLinkRow}>\n                            <View style={styles.quickLinkInfo}>\n                              <Text variant=\"bodySemibold\" color=\"primary\">\n                                No workout scheduled\n                              </Text>\n                              <Text variant=\"body\" color=\"secondary\">\n                                Assign workouts to your schedule to see them here.\n                              </Text>\n                            </View>\n                            <Pressable\n                              style={styles.planStartButton}\n                              onPress={handleCreatePlanPress}\n                              accessibilityRole=\"button\"\n                              accessibilityLabel=\"Go to Programs\"\n                            >\n                              <View style={styles.quickLinkButton}>\n                                <LinearGradient\n                                  colors={[theme.accent.gradientStart, theme.accent.gradientEnd]}\n                                  start={{ x: 0, y: 0 }}\n                                  end={{ x: 1, y: 1 }}\n                                  style={styles.planStartButtonGradient}\n                                />\n                                <Text variant=\"bodySemibold\" color=\"onAccent\">\n                                  \n                                </Text>\n                              </View>\n                            </Pressable>\n                          </View>\n                        </SurfaceCard>\n                      )}\n                    </View>\n                  </View>\n                </SurfaceCard>\n            </Animated.View>\n\n\n\n            <Animated.View style={recentWorkoutsAnimatedStyle}>\n              <SurfaceCard tone=\"card\" padding=\"xl\" showAccentStripe={true} style={{ borderWidth: 0 }}>\n                <View style={styles.dashboardCardHeader}>\n                  <Text variant=\"heading3\" color=\"primary\">\n                    Recent Workouts\n                  </Text>\n                </View>\n                <View style={styles.recentWorkoutsList}>\n                  {recentWorkouts.length > 0 ? (\n                    recentWorkouts.map((workout, index) => {\n                      const lift = recentWorkoutLifts[index];\n                      const planTitle = workout.planId ? planNameLookup[workout.planId]?.name : null;\n                      const workoutTitle = workout.name ?? planTitle ?? `${formatWorkoutDateLabel(workout)} Session`;\n\n                      return (\n                        <Pressable\n                          key={workout.id}\n                          style={styles.pressableStretch}\n                          onPressIn={lift?.onPressIn}\n                          onPressOut={lift?.onPressOut}\n                          onPress={() => {\n                            lift?.onPressOut?.();\n                            triggerHaptic('selection');\n                            router.push({ pathname: '/(tabs)/workout-detail', params: { workoutId: workout.id, from: 'dashboard' } });\n                          }}\n                        >\n                          <SurfaceCard\n                            tone=\"neutral\"\n                            padding=\"lg\"\n                            showAccentStripe={false}\n                            style={[styles.inlineCard, lift?.animatedStyle]}\n                          >\n                            <View style={styles.recentCardHeader}>\n                              <Text variant=\"bodySemibold\" color=\"primary\">\n                                {workoutTitle}\n                              </Text>\n                              <Text variant=\"body\" color=\"secondary\">\n                                {formatWorkoutDateLabel(workout)}\n                              </Text>\n                            </View>\n                            <Text variant=\"body\" color=\"secondary\">\n                              {formatWorkoutSubtitle(workout)}\n                            </Text>\n                          </SurfaceCard>\n                        </Pressable>\n                      );\n                    })\n                  ) : (\n                    <SurfaceCard\n                      tone=\"neutral\"\n                      padding=\"lg\"\n                      showAccentStripe={false}\n                      style={styles.inlineCard}\n                    >\n                      <Text variant=\"bodySemibold\" color=\"primary\">\n                        No workouts yet\n                      </Text>\n                      <Text variant=\"body\" color=\"secondary\">\n                        Complete a workout session and it will appear here.\n                      </Text>\n                    </SurfaceCard>\n                  )}\n                </View>\n              </SurfaceCard>\n            </Animated.View>\n\n            {/* Hercules AI Card */}\n            <Animated.View style={recentWorkoutsAnimatedStyle}>\n              <SurfaceCard tone=\"card\" padding=\"xl\" showAccentStripe={true} style={{ borderWidth: 0 }}>\n                <View style={styles.dashboardCardHeader}>\n                  <Text variant=\"heading3\" color=\"primary\">\n                    Hercules AI\n                  </Text>\n                </View>\n                <Pressable\n                  style={styles.pressableStretch}\n                  onPress={() => {\n                    triggerHaptic('selection');\n                    router.push('/hercules-ai');\n                  }}\n                >\n                  <SurfaceCard\n                    tone=\"neutral\"\n                    padding=\"lg\"\n                    showAccentStripe={false}\n                    style={styles.inlineCard}\n                  >\n                    <View style={styles.quickLinkRow}>\n                      <View style={styles.quickLinkInfo}>\n                        <Text variant=\"bodySemibold\" color=\"primary\">\n                          Chat with your AI Coach\n                        </Text>\n                        <Text variant=\"body\" color=\"secondary\">\n                          Get workout advice, form tips, and personalized guidance\n                        </Text>\n                      </View>\n                      <View style={styles.quickLinkButton}>\n                        <LinearGradient\n                          colors={[theme.accent.gradientStart, theme.accent.gradientEnd]}\n                          start={{ x: 0, y: 0 }}\n                          end={{ x: 1, y: 1 }}\n                          style={styles.planStartButtonGradient}\n                        />\n                        <Text variant=\"bodySemibold\" color=\"onAccent\">\n                          \n                        </Text>\n                      </View>\n                    </View>\n                  </SurfaceCard>\n                </Pressable>\n              </SurfaceCard>\n            </Animated.View>\n\n          </View>\n        </View>\n      </LinearGradient>\n    </TabSwipeContainer>\n  );\n};\n\nexport default DashboardScreen;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\app\\(tabs)\\plans.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\app\\(tabs)\\profile.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SimpleDistributionChart' is defined but never used.","line":12,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sizing' is defined but never used.","line":24,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":24,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'distanceUnitPref' is assigned a value but never used.","line":81,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":81,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'streakStyles' is assigned a value but never used.","line":194,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":194,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'streakData' is assigned a value but never used.","line":409,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":409,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'last7Days' is assigned a value but never used.","line":458,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":458,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sessionsThisWeekFromSunday' is assigned a value but never used.","line":474,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":474,"endColumn":35}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useCallback, useRef, useEffect, useMemo } from 'react';\nimport { StyleSheet, View, ScrollView, BackHandler, Pressable, TouchableOpacity, TextInput, FlatList } from 'react-native';\nimport { useRouter, useFocusEffect } from 'expo-router';\nimport { useScrollToTop } from '@react-navigation/native';\nimport { Ionicons } from '@expo/vector-icons';\n\nimport { ScreenHeader } from '@/components/molecules/ScreenHeader';\nimport { Text } from '@/components/atoms/Text';\nimport { TabSwipeContainer } from '@/components/templates/TabSwipeContainer';\nimport { PersonalRecordsSection } from '@/components/organisms/PersonalRecordsSection';\nimport { AnalyticsCard } from '@/components/atoms/AnalyticsCard';\nimport { SimpleDistributionChart } from '@/components/molecules/SimpleDistributionChart';\nimport { SimpleVolumeChart } from '@/components/molecules/SimpleVolumeChart';\nimport { VolumeTrendChart, WEIGHT_EXERCISE_TYPES } from '@/components/molecules/VolumeTrendChart';\nimport { BalanceScoreCard } from '@/components/molecules/BalanceScoreCard';\nimport { WeeklyCardioGoalCard } from '@/components/molecules/WeeklyCardioGoalCard';\nimport { DistanceByActivityCard } from '@/components/molecules/DistanceByActivityCard';\nimport { InsightCard } from '@/components/molecules/InsightCard';\nimport { TimeRangeSelector } from '@/components/atoms/TimeRangeSelector';\nimport { SheetModal } from '@/components/molecules/SheetModal';\nimport { useAnalyticsData } from '@/hooks/useAnalyticsData';\nimport { useInsightsData } from '@/hooks/useInsightsData';\nimport { searchExercises } from '@/utils/exerciseSearch';\nimport { spacing, colors, radius, sizing } from '@/constants/theme';\nimport { useTheme } from '@/hooks/useTheme';\nimport { TIME_RANGE_SUBTITLES, TimeRange } from '@/types/analytics';\nimport type { CardioStats } from '@/types/analytics';\nimport { useSettingsStore } from '@/store/settingsStore';\nimport { exercises as exerciseCatalog } from '@/constants/exercises';\nimport { useUserProfileStore } from '@/store/userProfileStore';\n\n// Simple cardio stats content component\nconst EMPTY_CARD_MIN_HEIGHT = 240;\n\nconst formatDuration = (totalSeconds: number): string => {\n  const hours = Math.floor(totalSeconds / 3600);\n  const minutes = Math.floor((totalSeconds % 3600) / 60);\n\n  if (hours > 0) {\n    // Use colon format for hours:minutes when hours are present\n    if (minutes < 10) {\n      return `${hours}:0${minutes}`;\n    }\n    return `${hours}:${minutes}`;\n  }\n  return `${minutes}m`;\n};\n\nconst formatCompactNumber = (value: number): string => {\n  const abs = Math.abs(value);\n  const sign = value < 0 ? '-' : '';\n\n  if (abs >= 1_000_000_000) {\n    const num = abs / 1_000_000_000;\n    const rounded = num >= 100 ? Math.round(num) : parseFloat(num.toFixed(1));\n    return `${sign}${rounded}B`;\n  }\n\n  if (abs >= 1_000_000) {\n    const num = abs / 1_000_000;\n    const rounded = num >= 100 ? Math.round(num) : parseFloat(num.toFixed(1));\n    return `${sign}${rounded}M`;\n  }\n\n  if (abs >= 1_000) {\n    const num = abs / 1_000;\n    const rounded = num >= 100 ? Math.round(num) : parseFloat(num.toFixed(1));\n    return `${sign}${rounded}K`;\n  }\n\n  return `${sign}${Math.round(abs).toLocaleString()}`;\n};\n\ninterface CardioStatsContentProps {\n  stats: CardioStats;\n  timeRange: TimeRange;\n}\n\nconst CardioStatsContent: React.FC<CardioStatsContentProps> = ({ stats, timeRange }) => {\n  // Subscribe to distanceUnit to trigger re-renders when units change\n  const distanceUnitPref = useSettingsStore((state) => state.distanceUnit);\n  const { convertDistance, getDistanceUnitShort } = useSettingsStore();\n  const { totalDuration, totalDistanceByType } = stats;\n\n  // Calculate total distance across activities that represent real distance.\n  // Exercises measured in floors (e.g., stair climbing) are excluded from the mi/km total.\n  const totalDistance = Object.entries(totalDistanceByType).reduce((sum, [exerciseName, dist]) => {\n    const unit = exerciseCatalog.find(e => e.name === exerciseName)?.distanceUnit;\n    if (unit === 'floors') return sum;\n    return sum + (dist || 0);\n  }, 0);\n\n  // Check if there's any cardio data\n  const hasData = totalDuration > 0 || totalDistance > 0;\n\n  if (!hasData) {\n    return (\n      <View style={cardioStyles.emptyState}>\n        <Text variant=\"body\" color=\"secondary\" style={cardioStyles.emptyText}>\n          {`No workout data for ${TIME_RANGE_SUBTITLES[timeRange].toLowerCase()}.`}\n        </Text>\n      </View>\n    );\n  }\n\n  // Time formatting logic - same as overview summary\n  const cardioDurationHasHours = Math.floor(totalDuration / 3600) > 0;\n  const cardioDurationMinutes = Math.floor((totalDuration % 3600) / 60);\n  const cardioSummaryValue = cardioDurationHasHours\n    ? formatDuration(totalDuration)\n    : cardioDurationMinutes.toString();\n  const cardioSummaryLabelSuffix = cardioDurationHasHours ? ' (hr:min)' : ' (min)';\n\n  // Distance formatting\n  const distanceUnitShort = getDistanceUnitShort();\n  const displayDistance = convertDistance(totalDistance);\n  const distanceSummaryValue = displayDistance.toFixed(1);\n  const distanceSummaryLabelSuffix = ` (${distanceUnitShort})`;\n\n  return (\n    <View style={{ gap: spacing.lg, paddingVertical: spacing.md }}>\n      {/* Total Time and Total Distance - Side by Side */}\n      <View style={{ flexDirection: 'row', justifyContent: 'space-around', alignItems: 'center' }}>\n        {/* Total Time */}\n        <View style={{ alignItems: 'center', paddingHorizontal: spacing.sm }}>\n          <View style={summaryStyles.valueBadge}>\n            <Text variant=\"heading2\" color=\"primary\">\n              {cardioSummaryValue}\n            </Text>\n          </View>\n          <Text variant=\"caption\" color=\"secondary\" style={{ marginTop: spacing.xs }}>\n            Total Time{cardioSummaryLabelSuffix}\n          </Text>\n        </View>\n\n        {/* Total Distance */}\n        {totalDistance > 0 && (\n          <View style={{ alignItems: 'center', paddingHorizontal: spacing.sm }}>\n            <View style={summaryStyles.valueBadge}>\n              <Text variant=\"heading2\" color=\"primary\">\n                {distanceSummaryValue}\n              </Text>\n            </View>\n            <Text variant=\"caption\" color=\"secondary\" style={{ marginTop: spacing.xs }}>\n              Total Distance{distanceSummaryLabelSuffix}\n            </Text>\n          </View>\n        )}\n      </View>\n    </View>\n  );\n};\n\nconst cardioStyles = StyleSheet.create({\n  emptyState: {\n    alignItems: 'center',\n    justifyContent: 'center',\n    padding: spacing.md,\n    minHeight: EMPTY_CARD_MIN_HEIGHT,\n  },\n  emptyText: {\n    textAlign: 'center',\n  },\n});\n\nconst summaryStyles = StyleSheet.create({\n  grid: {\n    flexDirection: 'row',\n    flexWrap: 'wrap',\n    rowGap: spacing.lg,\n  },\n  tile: {\n    width: '50%',\n    paddingVertical: spacing.md,\n    paddingHorizontal: spacing.sm,\n    alignItems: 'center',\n  },\n  value: {\n    marginBottom: spacing.xs,\n    textAlign: 'center',\n  },\n  valueBadge: {\n    backgroundColor: colors.surface.card,\n    paddingHorizontal: spacing.md,\n    paddingVertical: spacing.xs,\n    borderRadius: radius.md,\n    alignItems: 'center',\n    justifyContent: 'center',\n    minWidth: 64,\n    marginBottom: spacing.xs,\n  },\n});\n\nconst streakStyles = StyleSheet.create({\n  row: {\n    flexDirection: 'row',\n    justifyContent: 'space-around',\n    marginTop: spacing.md,\n    gap: spacing.xs,\n  },\n  dayItem: {\n    flex: 1,\n    alignItems: 'center',\n  },\n  dayDot: {\n    width: 28,\n    height: 28,\n    borderRadius: 14,\n    borderWidth: 1,\n    borderColor: colors.border.light,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  dayDotActive: {\n    backgroundColor: colors.accent.orange,\n    borderColor: colors.accent.orange,\n  },\n});\n\nconst volumeTrendFilterStyles = StyleSheet.create({\n  headerControls: {\n    alignItems: 'center',\n    gap: spacing.md,\n  },\n  filterButton: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    gap: spacing.xs,\n  },\n  filterText: {\n    flexShrink: 1,\n  },\n  modalContent: {\n    padding: spacing.lg,\n    paddingTop: spacing.md,\n    paddingBottom: spacing.md,\n    flex: 1,\n  },\n  searchInput: {\n    backgroundColor: colors.primary.bg,\n    borderWidth: 1,\n    borderColor: colors.border.medium,\n    padding: spacing.md,\n    borderRadius: radius.md,\n    fontSize: 16,\n    color: colors.text.primary,\n    marginBottom: spacing.md,\n  },\n  exerciseList: {\n    flex: 1,\n  },\n  exerciseItem: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    paddingVertical: spacing.md,\n    borderBottomWidth: 0.5,\n    borderBottomColor: colors.border.light,\n  },\n  exerciseItemSelected: {\n    backgroundColor: colors.accent.orangeMuted + '20',\n  },\n});\n\ntype PerformanceTab = 'general' | 'weights' | 'cardio' | 'insights';\n\ninterface TabPillProps {\n  label: string;\n  isActive: boolean;\n  onPress: () => void;\n}\n\nconst TabPill: React.FC<TabPillProps> = ({ label, isActive, onPress }) => {\n  const { theme } = useTheme();\n\n  const baseStyle = {\n    flex: 1,\n    flexBasis: 0,\n    paddingHorizontal: spacing.xs,\n    paddingVertical: spacing.xxs,\n    borderRadius: 999,\n    borderWidth: 1,\n    borderColor: theme.accent.orangeMuted,\n    backgroundColor: theme.primary.bg,\n  } as const;\n\n  const containerStyle = {\n    ...baseStyle,\n  };\n\n  const activeStyle = isActive\n    ? {\n        backgroundColor: theme.accent.orangeMuted,\n        borderColor: theme.accent.orange,\n      }\n    : {};\n\n  const textStyle = {\n    textAlign: 'center' as const,\n    color: theme.text.primary,\n  };\n\n  return (\n    <Pressable onPress={onPress} style={[containerStyle, activeStyle]} hitSlop={spacing.xs}>\n      <Text variant=\"bodySemibold\" style={textStyle}>\n        {label}\n      </Text>\n    </Pressable>\n  );\n};\n\nconst StatsScreen: React.FC = () => {\n  const router = useRouter();\n  const { theme } = useTheme();\n  const scrollRef = useRef<ScrollView>(null);\n  useScrollToTop(scrollRef);\n\n  useFocusEffect(\n    useCallback(() => {\n      scrollRef.current?.scrollTo({ y: 0, animated: false });\n    }, [])\n  );\n\n  // Handle Android hardware back button - navigate to Dashboard\n  useEffect(() => {\n    const backAction = () => {\n      router.replace('/(tabs)');\n      return true;\n    };\n\n    const backHandler = BackHandler.addEventListener('hardwareBackPress', backAction);\n    return () => backHandler.remove();\n  }, [router]);\n\n  const styles = StyleSheet.create({\n    contentContainer: {\n      flexGrow: 1,\n      backgroundColor: theme.primary.bg,\n      paddingTop: spacing.xl,\n      paddingHorizontal: spacing.md,\n      paddingBottom: spacing.sm,\n      gap: spacing.xl,\n    },\n    tabsRow: {\n      flexDirection: 'row',\n      justifyContent: 'flex-start',\n      alignItems: 'center',\n      marginTop: -spacing.lg,\n      marginBottom: spacing.sm,\n      paddingHorizontal: 0,\n      gap: spacing.xs,\n    },\n    tabPill: {\n      paddingHorizontal: spacing.lg,\n      paddingVertical: spacing.xxs,\n      borderRadius: 999,\n      borderWidth: 1,\n      borderColor: theme.accent.orangeMuted,\n      backgroundColor: theme.primary.bg,\n      minWidth: 90,\n    },\n    tabPillActive: {\n      backgroundColor: theme.accent.orangeMuted,\n      borderColor: theme.accent.orange,\n    },\n    tabPillLabel: {\n      textAlign: 'center',\n    },\n    tabPillLabelActive: {\n      color: theme.text.onAccent,\n    },\n  });\n\n  // Independent state for each card\n  const [generalTimeRange, setGeneralTimeRange] = useState<TimeRange>('week');\n  const [volumeTimeRange, setVolumeTimeRange] = useState<TimeRange>('week');\n  const [volumeTrendTimeRange, setVolumeTrendTimeRange] = useState<TimeRange>('week');\n  const [cardioTimeRange, setCardioTimeRange] = useState<TimeRange>('week');\n  const [activeTab, setActiveTab] = useState<PerformanceTab>('general');\n\n  // Used to force InsightCards to remount (so they default back to collapsed)\n  const [insightsCollapseNonce, setInsightsCollapseNonce] = useState(0);\n\n  // Volume trend exercise filter state\n  const [volumeTrendExercise, setVolumeTrendExercise] = useState<string | null>(null);\n  const [isExerciseModalVisible, setIsExerciseModalVisible] = useState(false);\n  const [exerciseSearchQuery, setExerciseSearchQuery] = useState('');\n\n  // Reset time ranges to 'week' when page gains focus\n  useFocusEffect(\n    useCallback(() => {\n      setGeneralTimeRange('week');\n      setVolumeTimeRange('week');\n      setVolumeTrendTimeRange('week');\n      setCardioTimeRange('week');\n      setVolumeTrendExercise(null);\n\n      // Ensure insight cards default back to collapsed when returning to this screen.\n      setInsightsCollapseNonce((n) => n + 1);\n    }, [])\n  );\n\n  // Fetch data separately for each time range\n  const {\n    workouts: allWorkouts,\n    filteredWorkouts: generalFilteredWorkouts,\n    weeklyVolume: generalWeeklyVolume,\n    cardioStats: generalCardioStats,\n    streakData,\n    hasData: hasAnyWorkoutData,\n    hasFilteredData: hasGeneralFilteredData,\n  } = useAnalyticsData({ timeRange: generalTimeRange });\n\n  const { hasFilteredData: hasVolumeData, filteredWorkouts: volumeFilteredWorkouts } = useAnalyticsData({ timeRange: volumeTimeRange });\n  const { filteredWorkouts: volumeTrendFilteredWorkouts } = useAnalyticsData({ timeRange: volumeTrendTimeRange });\n  const weightUnit = useSettingsStore((state) => state.weightUnit);\n  const { cardioStats } = useAnalyticsData({ timeRange: cardioTimeRange });\n\n  // Get list of weight exercises the user has performed for the volume trend filter\n  const performedWeightExercises = useMemo(() => {\n    const exerciseNames = new Set<string>();\n    volumeTrendFilteredWorkouts.forEach((workout) => {\n      workout.exercises.forEach((exercise: any) => {\n        const catalogEntry = exerciseCatalog.find((e) => e.name === exercise.name);\n        const exerciseType = catalogEntry?.exerciseType || 'weight';\n        if (WEIGHT_EXERCISE_TYPES.includes(exerciseType)) {\n          exerciseNames.add(exercise.name);\n        }\n      });\n    });\n    return Array.from(exerciseNames).sort();\n  }, [volumeTrendFilteredWorkouts]);\n\n  // Filter exercises for the modal\n  const filteredExercisesForModal = useMemo(() => {\n    const weightExercises = exerciseCatalog.filter(\n      (ex) => WEIGHT_EXERCISE_TYPES.includes(ex.exerciseType) && performedWeightExercises.includes(ex.name)\n    );\n    \n    if (!exerciseSearchQuery.trim()) {\n      return weightExercises.slice(0, 50);\n    }\n    \n    return searchExercises(exerciseSearchQuery, weightExercises, { limit: 50 });\n  }, [exerciseSearchQuery, performedWeightExercises]);\n\n  // Insights data for the Insights tab\n  const { groupedInsights, orderedTypes, emptyReason } = useInsightsData();\n\n  const handleDistributionPress = () => {\n    router.push('/(tabs)/distribution-analytics');\n  };\n\n  const handleVolumePress = () => {\n    router.push('/(tabs)/volume-analytics');\n  };\n\n  const last7Days = useMemo(() => {\n    const today = new Date();\n    const workoutDates = new Set(allWorkouts.map((w) => w.date.split('T')[0]));\n\n    return Array.from({ length: 7 }).map((_, index) => {\n      const date = new Date(today);\n      // Oldest on the left, today on the right\n      date.setDate(today.getDate() - (6 - index));\n      const dateKey = date.toISOString().split('T')[0];\n      const hasWorkout = workoutDates.has(dateKey);\n      const label = date.toLocaleDateString(undefined, { weekday: 'short' }).charAt(0);\n\n      return { label, hasWorkout, key: dateKey };\n    });\n  }, [allWorkouts]);\n\n  const sessionsThisWeekFromSunday = useMemo(() => {\n    if (!allWorkouts.length) return 0;\n\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n    const dayOfWeek = today.getDay(); // 0 = Sunday\n\n    const weekStart = new Date(today);\n    weekStart.setDate(today.getDate() - dayOfWeek);\n\n    const weekStartISO = weekStart.toISOString().split('T')[0];\n    const todayISO = today.toISOString().split('T')[0];\n\n    return allWorkouts.filter((w) => {\n      const dateKey = w.date.split('T')[0];\n      return dateKey >= weekStartISO && dateKey <= todayISO;\n    }).length;\n  }, [allWorkouts]);\n\n  const totalWorkoutSessions = generalFilteredWorkouts.length;\n\n  const totalVolume = useMemo(() => {\n    if (!generalWeeklyVolume?.high) return 0;\n    return generalWeeklyVolume.high.reduce((sum, bar) => sum + (bar.value || 0), 0);\n  }, [generalWeeklyVolume]);\n\n  const totalCardioTime = generalCardioStats.totalDuration;\n  const totalCardioDistance = useMemo(\n    () =>\n      Object.entries(generalCardioStats.totalDistanceByType || {}).reduce(\n        (sum, [exerciseName, dist]) => {\n          const unit = exerciseCatalog.find(e => e.name === exerciseName)?.distanceUnit;\n          if (unit === 'floors') return sum;\n          return sum + (dist || 0);\n        },\n        0,\n      ),\n    [generalCardioStats.totalDistanceByType],\n  );\n  const distanceUnitShort = useSettingsStore((state) => state.getDistanceUnitShort());\n  const formatDistanceValue = useSettingsStore((state) => state.formatDistanceValue);\n\n  const convertWeight = useSettingsStore((state) => state.convertWeight);\n  const userBodyWeight = useUserProfileStore((state) => state.profile?.weightLbs ?? 0);\n\n  const topExercisesByVolume = useMemo(() => {\n    const volumes: Record<string, number> = {};\n\n    volumeFilteredWorkouts.forEach((workout) => {\n      workout.exercises.forEach((exercise: any) => {\n        const catalogEntry = exerciseCatalog.find((e) => e.name === exercise.name);\n        const exerciseType = catalogEntry?.exerciseType || 'weight';\n\n        // Skip cardio and pure duration exercises\n        if (exerciseType === 'cardio' || exerciseType === 'duration') {\n          return;\n        }\n\n        let exerciseVolume = 0;\n\n        exercise.sets.forEach((set: any) => {\n          if (!set.completed) return;\n          const reps = set.reps ?? 0;\n          if (reps <= 0) return;\n\n          let setVolume = 0;\n          switch (exerciseType) {\n            case 'bodyweight':\n              if (userBodyWeight > 0) {\n                setVolume = userBodyWeight * reps;\n              }\n              break;\n            case 'assisted': {\n              if (userBodyWeight > 0) {\n                const assistance = set.assistanceWeight ?? 0;\n                const effective = Math.max(0, userBodyWeight - assistance);\n                if (effective > 0) {\n                  setVolume = effective * reps;\n                }\n              }\n              break;\n            }\n            case 'reps_only':\n              // Bands etc  do not contribute to volume\n              setVolume = 0;\n              break;\n            case 'weight':\n            default: {\n              const weight = set.weight ?? 0;\n              if (weight > 0) {\n                setVolume = weight * reps;\n              }\n              break;\n            }\n          }\n\n          if (setVolume > 0) {\n            // Convert to user's preferred unit (lbs -> user)\n            exerciseVolume += convertWeight(setVolume);\n          }\n        });\n\n        if (exerciseVolume > 0) {\n          volumes[exercise.name] = (volumes[exercise.name] || 0) + exerciseVolume;\n        }\n      });\n    });\n\n    const entries = Object.entries(volumes)\n      .filter(([, vol]) => vol > 0)\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, 5);\n\n    return entries.map(([name, volume]) => ({ name, volume }));\n  }, [volumeFilteredWorkouts, convertWeight, userBodyWeight]);\n\n  const renderGeneralTab = () => {\n    const cardioDurationHasHours = Math.floor(totalCardioTime / 3600) > 0;\n    const cardioDurationMinutes = Math.floor((totalCardioTime % 3600) / 60);\n    const cardioSummaryValue = cardioDurationHasHours\n      ? formatDuration(totalCardioTime)\n      : cardioDurationMinutes.toString();\n    const cardioSummaryLabelSuffix = cardioDurationHasHours ? ' (hr:min)' : ' (min)';\n\n    return (\n      <>\n        <View>\n          <PersonalRecordsSection />\n        </View>\n\n        <AnalyticsCard\n          title=\"Summary\"\n          showAccentStripe={false}\n          titleCentered={true}\n          showHorizontalAccentBar={false}\n          showChevron={false}\n          headerRight={\n            <TimeRangeSelector value={generalTimeRange} onChange={setGeneralTimeRange} />\n          }\n        >\n          {!hasAnyWorkoutData ? (\n            <View style={cardioStyles.emptyState}>\n              <Text variant=\"body\" color=\"secondary\" style={cardioStyles.emptyText}>\n                No workouts yet  start your first session to see stats here.\n              </Text>\n            </View>\n          ) : !hasGeneralFilteredData ? (\n            <View style={cardioStyles.emptyState}>\n              <Text variant=\"body\" color=\"secondary\" style={cardioStyles.emptyText}>\n                {`No workout data for ${TIME_RANGE_SUBTITLES[generalTimeRange].toLowerCase()}.`}\n              </Text>\n            </View>\n          ) : (\n            <View style={summaryStyles.grid}>\n              <View style={summaryStyles.tile}>\n                <View style={summaryStyles.valueBadge}>\n                  <Text variant=\"heading3\" color=\"primary\">\n                    {totalWorkoutSessions}\n                  </Text>\n                </View>\n                <Text variant=\"caption\" color=\"secondary\">\n                  Workout Sessions\n                </Text>\n              </View>\n\n              <View style={summaryStyles.tile}>\n                <View style={summaryStyles.valueBadge}>\n                  <Text variant=\"heading3\" color=\"primary\">\n                    {formatCompactNumber(totalVolume)}\n                  </Text>\n                </View>\n                <Text variant=\"caption\" color=\"secondary\">\n                  {`Total Volume (${weightUnit})`}\n                </Text>\n              </View>\n\n              <View style={summaryStyles.tile}>\n                <View style={summaryStyles.valueBadge}>\n                  <Text variant=\"heading3\" color=\"primary\">\n                    {cardioSummaryValue}\n                  </Text>\n                </View>\n                <Text variant=\"caption\" color=\"secondary\">\n                  Cardio Time{cardioSummaryLabelSuffix}\n                </Text>\n              </View>\n\n              <View style={summaryStyles.tile}>\n                <View style={summaryStyles.valueBadge}>\n                  <Text variant=\"heading3\" color=\"primary\">\n                    {formatDistanceValue(totalCardioDistance, 1)}\n                  </Text>\n                </View>\n                <Text variant=\"caption\" color=\"secondary\">\n                  {`Cardio Distance (${distanceUnitShort})`}\n                </Text>\n              </View>\n            </View>\n          )}\n        </AnalyticsCard>\n      </>\n    );\n  };\n\n  const renderWeightsTab = () => (\n    <>\n      <AnalyticsCard\n        title={`Volume Trend (${weightUnit})`}\n        showAccentStripe={false}\n        titleCentered={true}\n        showHorizontalAccentBar={false}\n        showChevron={false}\n        headerRight={\n          <View style={volumeTrendFilterStyles.headerControls}>\n            {/* Exercise filter dropdown */}\n            <TouchableOpacity \n              style={volumeTrendFilterStyles.filterButton} \n              onPress={() => {\n                setExerciseSearchQuery('');\n                setIsExerciseModalVisible(true);\n              }}\n            >\n              <Text variant=\"caption\" color=\"secondary\" numberOfLines={1} style={volumeTrendFilterStyles.filterText}>\n                {volumeTrendExercise || 'All Exercises'}\n              </Text>\n              <Ionicons name=\"chevron-down\" size={14} color={theme.text.secondary} />\n            </TouchableOpacity>\n            {/* Time range selector */}\n            <TimeRangeSelector value={volumeTrendTimeRange} onChange={setVolumeTrendTimeRange} />\n          </View>\n        }\n      >\n        <VolumeTrendChart timeRange={volumeTrendTimeRange} selectedExercise={volumeTrendExercise} />\n        \n        {/* Exercise selection modal */}\n        <SheetModal\n          visible={isExerciseModalVisible}\n          onClose={() => setIsExerciseModalVisible(false)}\n          title=\"Filter by Exercise\"\n        >\n          <View style={volumeTrendFilterStyles.modalContent}>\n            <TextInput\n              style={volumeTrendFilterStyles.searchInput}\n              placeholder=\"Search exercises...\"\n              value={exerciseSearchQuery}\n              onChangeText={setExerciseSearchQuery}\n              placeholderTextColor={colors.text.tertiary}\n            />\n            \n            {/* All Exercises option to clear filter */}\n            <TouchableOpacity\n              style={[volumeTrendFilterStyles.exerciseItem, !volumeTrendExercise && volumeTrendFilterStyles.exerciseItemSelected]}\n              onPress={() => {\n                setVolumeTrendExercise(null);\n                setIsExerciseModalVisible(false);\n              }}\n            >\n              <Text variant=\"body\" style={!volumeTrendExercise ? { fontWeight: '600' } : undefined}>All Exercises</Text>\n              {!volumeTrendExercise && <Ionicons name=\"checkmark\" size={20} color={theme.accent.orange} />}\n            </TouchableOpacity>\n            \n            <FlatList\n              data={filteredExercisesForModal}\n              keyExtractor={(item) => item.id}\n              renderItem={({ item }) => (\n                <TouchableOpacity\n                  style={[volumeTrendFilterStyles.exerciseItem, volumeTrendExercise === item.name && volumeTrendFilterStyles.exerciseItemSelected]}\n                  onPress={() => {\n                    setVolumeTrendExercise(item.name);\n                    setIsExerciseModalVisible(false);\n                  }}\n                >\n                  <Text variant=\"body\" style={volumeTrendExercise === item.name ? { fontWeight: '600' } : undefined}>\n                    {item.name}\n                  </Text>\n                  {volumeTrendExercise === item.name && (\n                    <Ionicons name=\"checkmark\" size={20} color={theme.accent.orange} />\n                  )}\n                </TouchableOpacity>\n              )}\n              style={volumeTrendFilterStyles.exerciseList}\n            />\n          </View>\n        </SheetModal>\n      </AnalyticsCard>\n\n      <AnalyticsCard\n        title={`Volume Totals (${weightUnit})`}\n        onPress={handleVolumePress}\n        headerRight={\n          <TimeRangeSelector value={volumeTimeRange} onChange={setVolumeTimeRange} />\n        }\n        isEmpty={!hasVolumeData}\n        showAccentStripe={false}\n        titleCentered={true}\n        showHorizontalAccentBar={false}\n      >\n        <SimpleVolumeChart timeRange={volumeTimeRange} />\n      </AnalyticsCard>\n\n      <BalanceScoreCard />\n\n      <AnalyticsCard\n        title={`Top Exercises (${weightUnit})`}\n        showAccentStripe={false}\n        titleCentered={true}\n        showHorizontalAccentBar={false}\n        showChevron={false}\n        headerRight={\n          <TimeRangeSelector value={volumeTimeRange} onChange={setVolumeTimeRange} />\n        }\n      >\n        {topExercisesByVolume.length === 0 ? (\n          <View style={cardioStyles.emptyState}>\n            <Text variant=\"body\" color=\"secondary\" style={cardioStyles.emptyText}>\n              No strength workouts in this time range.\n            </Text>\n          </View>\n        ) : (\n          <View style={{ gap: spacing.sm, paddingTop: spacing.md }}>\n            {topExercisesByVolume.map((entry, index) => (\n              <View\n                key={entry.name}\n                style={{\n                  flexDirection: 'row',\n                  justifyContent: 'space-between',\n                  alignItems: 'center',\n                  paddingVertical: spacing.xs,\n                  minHeight: 32,\n                }}\n              >\n                <View\n                  style={{\n                    flexDirection: 'row',\n                    alignItems: 'center',\n                    gap: spacing.sm,\n                    flex: 1,\n                    marginRight: spacing.md,\n                  }}\n                >\n                  <Text variant=\"body\" color=\"primary\" style={{ flex: 1 }} numberOfLines={2}>\n                    {index + 1}. {entry.name}\n                  </Text>\n                </View>\n                <View style={{ minWidth: 80, alignItems: 'flex-end' }}>\n                  <Text variant=\"bodySemibold\" color=\"primary\">\n                    {formatCompactNumber(entry.volume)}\n                  </Text>\n                </View>\n              </View>\n            ))}\n          </View>\n        )}\n      </AnalyticsCard>\n    </>\n  );\n  const renderCardioTab = () => (\n    <>\n      {/* Weekly Cardio Goal Card - Swipeable Time/Distance */}\n      <WeeklyCardioGoalCard />\n\n      {/* Distance by Activity Card */}\n      <DistanceByActivityCard />\n\n      {/* Cardio Summary Card - Total Time and Total Distance only */}\n      <AnalyticsCard\n        title=\"Cardio Summary\"\n        showAccentStripe={false}\n        titleCentered={true}\n        showHorizontalAccentBar={false}\n        showChevron={false}\n        headerRight={\n          <TimeRangeSelector value={cardioTimeRange} onChange={setCardioTimeRange} />\n        }\n      >\n        <CardioStatsContent stats={cardioStats} timeRange={cardioTimeRange} />\n      </AnalyticsCard>\n    </>\n  );\n\n  const renderInsightsTab = () => (\n    <>\n      {/* Insight Cards - one per category, sorted by priority */}\n      {orderedTypes.length > 0 ? (\n        <View style={{ gap: spacing.sm }}>\n          {orderedTypes.map((type) => (\n            <InsightCard\n              key={`${type}-${insightsCollapseNonce}`}\n              insights={groupedInsights[type]}\n            />\n          ))}\n        </View>\n      ) : (\n        <View\n          style={{\n            backgroundColor: theme.surface.card,\n            borderRadius: radius.md,\n            padding: spacing.lg,\n            alignItems: 'center',\n            gap: spacing.sm,\n          }}\n        >\n          {emptyReason === 'no-workouts' ? (\n            <>\n              <Text style={{ fontSize: 32 }}></Text>\n              <Text variant=\"heading3\" color=\"primary\" style={{ textAlign: 'center' }}>\n                No Workouts Yet\n              </Text>\n              <Text variant=\"body\" color=\"secondary\" style={{ textAlign: 'center' }}>\n                Complete your first workout to start getting personalized insights.\n              </Text>\n            </>\n          ) : emptyReason === 'insufficient-data' ? (\n            <>\n              <Text style={{ fontSize: 32 }}></Text>\n              <Text variant=\"heading3\" color=\"primary\" style={{ textAlign: 'center' }}>\n                Building Your Profile\n              </Text>\n              <Text variant=\"body\" color=\"secondary\" style={{ textAlign: 'center' }}>\n                Complete a few more workouts and insights will appear here automatically.\n              </Text>\n            </>\n          ) : (\n            <>\n              <Text style={{ fontSize: 32 }}></Text>\n              <Text variant=\"heading3\" color=\"primary\" style={{ textAlign: 'center' }}>\n                Looking Good!\n              </Text>\n              <Text variant=\"body\" color=\"secondary\" style={{ textAlign: 'center' }}>\n                Your training is well-balanced this week. Keep it up!\n              </Text>\n            </>\n          )}\n        </View>\n      )}\n\n      {/* Deep Dive section */}\n      <AnalyticsCard\n        title=\"Deep Dive\"\n        showAccentStripe={false}\n        titleCentered={true}\n        showHorizontalAccentBar={false}\n        showChevron={false}\n      >\n        <View style={{ gap: spacing.md }}>\n          <Text variant=\"body\" color=\"secondary\" style={{ textAlign: 'center' }}>\n            Explore more advanced analytics views for your training.\n          </Text>\n          <View style={{ gap: spacing.sm }}>\n            <Pressable\n              onPress={handleVolumePress}\n              style={{\n                paddingVertical: spacing.sm,\n                paddingHorizontal: spacing.md,\n                borderRadius: radius.md,\n                borderWidth: 1,\n                borderColor: colors.accent.orangeMuted,\n                backgroundColor: colors.surface.card,\n              }}\n            >\n              <Text variant=\"bodySemibold\" color=\"primary\" style={{ textAlign: 'center' }}>\n                Volume Totals Breakdown\n              </Text>\n              <Text variant=\"caption\" color=\"secondary\" style={{ textAlign: 'center' }}>\n                Drill into weekly and body-region volume.\n              </Text>\n            </Pressable>\n\n            <Pressable\n              onPress={handleDistributionPress}\n              style={{\n                paddingVertical: spacing.sm,\n                paddingHorizontal: spacing.md,\n                borderRadius: radius.md,\n                borderWidth: 1,\n                borderColor: colors.accent.orangeMuted,\n                backgroundColor: colors.surface.card,\n              }}\n            >\n              <Text variant=\"bodySemibold\" color=\"primary\" style={{ textAlign: 'center' }}>\n                Volume Distribution Map\n              </Text>\n              <Text variant=\"caption\" color=\"secondary\" style={{ textAlign: 'center' }}>\n                Visualize how work is spread across muscle groups.\n              </Text>\n            </Pressable>\n          </View>\n        </View>\n      </AnalyticsCard>\n    </>\n  );\n\n  const renderActiveTabContent = () => {\n    switch (activeTab) {\n      case 'general':\n        return renderGeneralTab();\n      case 'weights':\n        return renderWeightsTab();\n      case 'cardio':\n        return renderCardioTab();\n      case 'insights':\n        return renderInsightsTab();\n      default:\n        return null;\n    }\n  };\n\n  return (\n    <TabSwipeContainer ref={scrollRef} contentContainerStyle={styles.contentContainer}>\n      <ScreenHeader\n        title=\"Performance\"\n        subtitle=\"Track your gains and personal records\"\n      />\n\n      {/* Top-level Performance tabs */}\n      <View style={styles.tabsRow}>\n        <TabPill\n          label=\"Overview\"\n          isActive={activeTab === 'general'}\n          onPress={() => setActiveTab('general')}\n        />\n        <TabPill\n          label=\"Strength\"\n          isActive={activeTab === 'weights'}\n          onPress={() => setActiveTab('weights')}\n        />\n        <TabPill\n          label=\"Cardio\"\n          isActive={activeTab === 'cardio'}\n          onPress={() => setActiveTab('cardio')}\n        />\n        <TabPill\n          label=\"Insights\"\n          isActive={activeTab === 'insights'}\n          onPress={() => setActiveTab('insights')}\n        />\n      </View>\n\n      {renderActiveTabContent()}\n    </TabSwipeContainer>\n  );\n};\n\nexport default StatsScreen;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\app\\(tabs)\\program-details.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Badge' is defined but never used.","line":10,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'PremadeProgram' is defined but never used.","line":16,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'UserProgram' is defined but never used.","line":16,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":42}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useCallback, useState, useRef, useEffect } from 'react';\r\nimport { View, StyleSheet, ScrollView, Alert, Pressable, BackHandler } from 'react-native';\r\nimport { useLocalSearchParams, useRouter } from 'expo-router';\r\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\r\nimport { useFocusEffect } from '@react-navigation/native';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { Button } from '@/components/atoms/Button';\r\nimport { Badge } from '@/components/atoms';\r\nimport { SurfaceCard } from '@/components/atoms/SurfaceCard';\r\nimport { IconSymbol } from '@/components/ui/icon-symbol';\r\nimport { PremiumLimitModal } from '@/components/molecules/PremiumLimitModal';\r\nimport { colors, spacing, radius, sizing } from '@/constants/theme';\r\nimport { useProgramsStore } from '@/store/programsStore';\r\nimport type { PremadeProgram, UserProgram, RotationSchedule } from '@/types/premadePlan';\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    flex: 1,\r\n    backgroundColor: colors.primary.bg,\r\n  },\r\n  header: {\r\n    flexDirection: 'row',\r\n    alignItems: 'flex-start',\r\n    justifyContent: 'space-between',\r\n    paddingTop: spacing.xl,\r\n    paddingBottom: spacing.md,\r\n    gap: spacing.sm,\r\n  },\r\n  backButton: {\r\n    padding: spacing.sm,\r\n    paddingTop: spacing.xs,\r\n    borderRadius: radius.full,\r\n  },\r\n  titleContainer: {\r\n    flex: 1,\r\n  },\r\n  titleWrapper: {\r\n    paddingBottom: spacing.xs,\r\n  },\r\n  scrollContent: {\r\n    paddingHorizontal: spacing.md,\r\n    paddingBottom: spacing['2xl'],\r\n    gap: spacing.lg,\r\n  },\r\n  outerCardContent: {\r\n    gap: spacing.lg,\r\n  },\r\n  workoutCard: {\r\n    borderRadius: radius.md,\r\n    backgroundColor: colors.surface.card,\r\n    borderWidth: 1,\r\n    borderColor: colors.border.light,\r\n    padding: spacing.md,\r\n    gap: spacing.xs,\r\n    marginTop: spacing.md,\r\n    overflow: 'hidden',\r\n  },\r\n  exercisesContainer: {\r\n    marginTop: spacing.xs,\r\n  },\r\n  workoutCardHeader: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'space-between',\r\n    marginBottom: spacing.sm,\r\n  },\r\n  exerciseRow: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    gap: spacing.sm,\r\n    paddingVertical: spacing.sm,\r\n  },\r\n  exerciseNumber: {\r\n    width: sizing.iconLG,\r\n    height: sizing.iconLG,\r\n    borderRadius: radius.full,\r\n    backgroundColor: colors.surface.card,\r\n    borderWidth: 1,\r\n    borderColor: colors.accent.orange,\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n    flexShrink: 0,\r\n  },\r\n  exerciseNumberText: {\r\n    color: colors.text.primary,\r\n    fontSize: 16,\r\n    fontWeight: '600',\r\n    includeFontPadding: false,\r\n  },\r\n  exerciseNameContainer: {\r\n    flex: 1,\r\n    flexShrink: 1,\r\n    width: 0,\r\n  },\r\n  exerciseName: {\r\n    fontSize: 18,\r\n    fontWeight: '500',\r\n    color: colors.text.primary,\r\n  },\r\n  exerciseCount: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    gap: spacing.xs,\r\n    marginTop: spacing.xs,\r\n  },\r\n  workoutsList: {\r\n    gap: spacing.md,\r\n  },\r\n});\r\n\r\nexport default function ProgramDetailsScreen() {\r\n  const router = useRouter();\r\n  const insets = useSafeAreaInsets();\r\n  const { programId } = useLocalSearchParams<{ programId: string }>();\r\n  const { premadePrograms, userPrograms, clonePremadeProgram, setActiveRotation } = useProgramsStore();\r\n  const [isAdding, setIsAdding] = useState(false);\r\n  const [showLimitModal, setShowLimitModal] = useState(false);\r\n  const [limitType, setLimitType] = useState<'workout' | 'plan'>('plan');\r\n\r\n  const program = premadePrograms.find(p => p.id === programId) || userPrograms.find(p => p.id === programId);\r\n  const isUserProgram = program && !program.isPremade;\r\n\r\n  const handleBack = useCallback(() => {\r\n    triggerHaptic('selection');\r\n    router.back();\r\n  }, [router]);\r\n\r\n  const scrollRef = useRef<ScrollView>(null);\r\n\r\n  useFocusEffect(\r\n    useCallback(() => {\r\n      // Small timeout to ensure layout is done and previous transition completed\r\n      const timeout = setTimeout(() => {\r\n        scrollRef.current?.scrollTo({ y: 0, animated: false });\r\n      }, 50);\r\n      return () => clearTimeout(timeout);\r\n    }, [])\r\n  );\r\n\r\n  // Handle Android hardware back button\r\n  useEffect(() => {\r\n    const backAction = () => {\r\n      handleBack();\r\n      return true;\r\n    };\r\n\r\n    const backHandler = BackHandler.addEventListener('hardwareBackPress', backAction);\r\n    return () => backHandler.remove();\r\n  }, [handleBack]);\r\n\r\n  const handleAddToPlans = useCallback(async () => {\r\n    if (isAdding || !program) return;\r\n    setIsAdding(true);\r\n    triggerHaptic('selection');\r\n\r\n    try {\r\n      await clonePremadeProgram(program.id);\r\n      triggerHaptic('success');\r\n\r\n      // Navigate back to Plans tab\r\n      router.replace('/(tabs)/plans');\r\n    } catch (error: any) {\r\n      if (error?.message === 'FREE_LIMIT_REACHED') {\r\n        setLimitType('plan');\r\n        setShowLimitModal(true);\r\n      } else if (error?.message === 'WORKOUT_LIMIT_REACHED') {\r\n        setLimitType('workout');\r\n        setShowLimitModal(true);\r\n      } else {\r\n        console.error('Failed to add program:', error);\r\n        Alert.alert('Error', 'Failed to add program to your library.');\r\n      }\r\n    } finally {\r\n      setIsAdding(false);\r\n    }\r\n  }, [clonePremadeProgram, isAdding, program, router]);\r\n\r\n  const handleSetRotation = useCallback(async () => {\r\n    if (isAdding || !program) return;\r\n    setIsAdding(true);\r\n    triggerHaptic('selection');\r\n\r\n    try {\r\n      const rotation: RotationSchedule = {\r\n        id: `rot-${Date.now()}`,\r\n        name: program.name,\r\n        programId: program.id,\r\n        workoutSequence: program.workouts.map((w) => w.id),\r\n        currentIndex: 0,\r\n      };\r\n\r\n      await setActiveRotation(rotation);\r\n      triggerHaptic('success');\r\n\r\n      Alert.alert(\r\n        'Schedule Updated',\r\n        'This program is now your active rotation schedule. Check the Dashboard for your next workout.',\r\n        [{\r\n          text: 'OK', onPress: () => {\r\n            router.replace('/(tabs)');\r\n          }\r\n        }]\r\n      );\r\n    } catch (error) {\r\n      console.error('Failed to set rotation:', error);\r\n      Alert.alert('Error', 'Failed to update schedule.');\r\n    } finally {\r\n      setIsAdding(false);\r\n    }\r\n  }, [isAdding, program, setActiveRotation, router]);\r\n\r\n  if (!program) {\r\n    return (\r\n      <View style={[styles.container, { paddingTop: insets.top, paddingBottom: insets.bottom + sizing.tabBarHeight }]}>\r\n        <View style={styles.header}>\r\n          <View style={styles.titleContainer}>\r\n            <Text variant=\"heading2\" color=\"primary\">Program Not Found</Text>\r\n            <Text variant=\"body\" color=\"secondary\">The requested program could not be found.</Text>\r\n          </View>\r\n          <Pressable onPress={handleBack} style={styles.backButton} hitSlop={8}>\r\n            <IconSymbol name=\"arrow-back\" size={24} color={colors.text.primary} />\r\n          </Pressable>\r\n        </View>\r\n        <View style={{ justifyContent: 'center', alignItems: 'center', flex: 1 }}>\r\n          <Button label=\"Go Back\" onPress={handleBack} />\r\n        </View>\r\n      </View>\r\n    );\r\n  }\r\n  return (\r\n    <>\r\n      <PremiumLimitModal\r\n        visible={showLimitModal}\r\n        onClose={() => setShowLimitModal(false)}\r\n        limitType={limitType}\r\n      />\r\n      <View style={[styles.container, { paddingTop: insets.top, paddingBottom: insets.bottom + sizing.tabBarHeight }]}>\r\n        {/* Content */}\r\n        <ScrollView ref={scrollRef} contentContainerStyle={styles.scrollContent}>\r\n          {/* Header */}\r\n          <View style={styles.header}>\r\n            <View style={styles.titleContainer}>\r\n              <Text variant=\"heading2\" color=\"primary\">\r\n                {program.name}\r\n              </Text>\r\n              <Text variant=\"body\" color=\"secondary\">\r\n                {program.metadata.description}\r\n              </Text>\r\n            </View>\r\n            <Pressable onPress={handleBack} style={styles.backButton} hitSlop={8}>\r\n              <IconSymbol name=\"arrow-back\" size={24} color={colors.text.primary} />\r\n            </Pressable>\r\n          </View>\r\n\r\n\r\n\r\n          <SurfaceCard padding=\"xl\" tone=\"neutral\">\r\n            <View style={styles.outerCardContent}>\r\n              <Text variant=\"heading3\" color=\"primary\">Workouts Included</Text>\r\n              <View style={styles.workoutsList}>\r\n                {program.workouts\r\n                  .filter(w => w.exercises.length > 0)\r\n                  .map((workout, index) => (\r\n                    <View\r\n                      key={workout.id}\r\n                      style={styles.workoutCard}\r\n                    >\r\n                      <View style={styles.workoutCardHeader}>\r\n                        <Text variant=\"heading4\" color=\"primary\">\r\n                          {index + 1}. {workout.name}\r\n                        </Text>\r\n                      </View>\r\n\r\n                      {/* List all exercises */}\r\n                      <View style={styles.exercisesContainer}>\r\n                        {workout.exercises.map((ex, exIndex) => (\r\n                          <View key={ex.id} style={styles.exerciseRow}>\r\n                            <View style={styles.exerciseNumber}>\r\n                              <Text style={styles.exerciseNumberText}>\r\n                                {exIndex + 1}\r\n                              </Text>\r\n                            </View>\r\n                            <View style={styles.exerciseNameContainer}>\r\n                              <Text style={styles.exerciseName}>\r\n                                {ex.name}\r\n                              </Text>\r\n                            </View>\r\n                          </View>\r\n                        ))}\r\n                      </View>\r\n                    </View>\r\n                  ))}\r\n              </View>\r\n            </View>\r\n          </SurfaceCard>\r\n\r\n          <View style={styles.outerCardContent}>\r\n            {isUserProgram ? (\r\n              <Button\r\n                label=\"Start Rotation Schedule\"\r\n                onPress={handleSetRotation}\r\n                loading={isAdding}\r\n                size=\"lg\"\r\n                variant=\"primary\"\r\n              />\r\n            ) : (\r\n              <Button\r\n                label=\"Add to My Plans\"\r\n                onPress={handleAddToPlans}\r\n                loading={isAdding}\r\n                size=\"lg\"\r\n              />\r\n            )}\r\n          </View>\r\n        </ScrollView>\r\n      </View>\r\n    </>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\app\\(tabs)\\schedule-editor.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\app\\(tabs)\\schedule-setup.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FlatList' is defined but never used.","line":7,"column":58,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":66},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'PanGestureHandler' is defined but never used.","line":8,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'State' is defined but never used.","line":8,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'PlanScheduleConfig' is defined but never used.","line":23,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":23,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Schedule Setup Page\r\n * Full-screen page for configuring the active schedule rule.\r\n * Supports Weekly, Rotating Cycle, and Plan-Driven schedule types.\r\n */\r\nimport React, { useState, useCallback, useMemo, useEffect, useRef } from 'react';\r\nimport { View, StyleSheet, ScrollView, Pressable, Modal, FlatList, BackHandler } from 'react-native';\r\nimport { PanGestureHandler, State } from 'react-native-gesture-handler';\r\nimport { useRouter } from 'expo-router';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { Button } from '@/components/atoms/Button';\r\nimport { SurfaceCard } from '@/components/atoms/SurfaceCard';\r\nimport { TabSwipeContainer } from '@/components/templates/TabSwipeContainer';\r\nimport { IconSymbol } from '@/components/ui/icon-symbol';\r\nimport { useActiveScheduleStore } from '@/store/activeScheduleStore';\r\nimport { useProgramsStore } from '@/store/programsStore';\r\nimport { usePlansStore } from '@/store/plansStore';\r\nimport { useTheme } from '@/hooks/useTheme';\r\nimport { useAuth } from '@/providers/AuthProvider';\r\nimport { spacing, radius, colors, shadows } from '@/constants/theme';\r\nimport type { PlanScheduleConfig, UserProgram } from '@/types/premadePlan';\r\nimport type {\r\n  ScheduleRule,\r\n  ScheduleRuleType,\r\n  WeeklyScheduleRule,\r\n  RotatingScheduleRule,\r\n  PlanDrivenScheduleRule,\r\n  WeekdayKey,\r\n} from '@/types/activeSchedule';\r\n\r\ntype EditorStep = 'type-select' | 'configure';\r\n\r\ninterface WorkoutOption {\r\n  id: string | null;\r\n  name: string;\r\n  source: string;\r\n  isRest: boolean;\r\n}\r\n\r\nconst SCHEDULE_TYPES: { type: ScheduleRuleType; label: string; description: string; icon: string }[] = [\r\n  {\r\n    type: 'weekly',\r\n    label: 'Weekly',\r\n    description: 'Same workout on the same day each week',\r\n    icon: 'calendar-today',\r\n  },\r\n  {\r\n    type: 'rotating',\r\n    label: 'Rotating Cycle',\r\n    description: 'Cycle through workouts regardless of day',\r\n    icon: 'autorenew',\r\n  },\r\n  {\r\n    type: 'plan-driven',\r\n    label: 'Plan-Driven',\r\n    description: 'Follow a saved plan sequentially',\r\n    icon: 'assignment',\r\n  },\r\n];\r\n\r\nconst WEEKDAYS: { key: WeekdayKey; label: string; short: string }[] = [\r\n  { key: 'sunday', label: 'Sunday', short: 'Sun' },\r\n  { key: 'monday', label: 'Monday', short: 'Mon' },\r\n  { key: 'tuesday', label: 'Tuesday', short: 'Tue' },\r\n  { key: 'wednesday', label: 'Wednesday', short: 'Wed' },\r\n  { key: 'thursday', label: 'Thursday', short: 'Thu' },\r\n  { key: 'friday', label: 'Friday', short: 'Fri' },\r\n  { key: 'saturday', label: 'Saturday', short: 'Sat' },\r\n];\r\n\r\nconst createEmptyWeeklyRule = (): WeeklyScheduleRule => ({\r\n  type: 'weekly',\r\n  days: {\r\n    monday: null,\r\n    tuesday: null,\r\n    wednesday: null,\r\n    thursday: null,\r\n    friday: null,\r\n    saturday: null,\r\n    sunday: null,\r\n  },\r\n});\r\n\r\nconst createEmptyRotatingRule = (startTime?: number): RotatingScheduleRule => ({\r\n  type: 'rotating',\r\n  startDate: startTime || Date.now(),\r\n  cycleWorkouts: [null],\r\n});\r\n\r\nconst normalizeCycleWorkouts = (cycleWorkouts: (string | null)[]): (string | null)[] => {\r\n  // Important: Array holes (sparse arrays) can cause map() to skip indices,\r\n  // which leads to Day 1 / Day 5 gaps. filter() compacts the array.\r\n  return cycleWorkouts.filter((id) => id !== undefined);\r\n};\r\n\r\nconst normalizeRotatingRule = (rule: RotatingScheduleRule): RotatingScheduleRule => {\r\n  return {\r\n    ...rule,\r\n    cycleWorkouts: normalizeCycleWorkouts(rule.cycleWorkouts),\r\n  };\r\n};\r\n\r\nconst normalizeScheduleRule = (rule: ScheduleRule | null): ScheduleRule | null => {\r\n  if (!rule) return null;\r\n  if (rule.type !== 'rotating') return rule;\r\n  return normalizeRotatingRule(rule);\r\n};\r\n\r\nconst MAX_ROTATING_CYCLE_DAYS = 14;\r\n\r\n/** Extract cycleWorkouts from a plan's suggested schedule */\r\nconst getPlanCycleWorkouts = (plan: UserProgram): (string | null)[] => {\r\n  // Prefer the user's saved schedule (already mapped to the user's cloned workout IDs)\r\n  if (plan.schedule?.type === 'rotation') {\r\n    const order = plan.schedule.rotation?.workoutOrder as (string | null)[] | undefined;\r\n    if (order && order.length > 0) return order;\r\n  }\r\n\r\n  if (plan.schedule?.type === 'weekly' && plan.schedule.weekly) {\r\n    const weekdays = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];\r\n    const weekly = plan.schedule.weekly;\r\n    return weekdays.map((day) => (weekly as unknown as Record<string, string | null>)[day] ?? null);\r\n  }\r\n\r\n  // Fallback to premade suggestedSchedule (may contain source IDs)\r\n  if (plan.suggestedSchedule?.rotation && plan.suggestedSchedule.rotation.length > 0) {\r\n    return plan.suggestedSchedule.rotation;\r\n  }\r\n\r\n  if (plan.suggestedSchedule?.weekly) {\r\n    const weekdays = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];\r\n    return weekdays.map((day) => plan.suggestedSchedule?.weekly?.[day] ?? null);\r\n  }\r\n\r\n  // Default: list all workouts with rest days between them\r\n  const workouts: (string | null)[] = [];\r\n  plan.workouts.forEach((w, i) => {\r\n    workouts.push(w.id);\r\n    if (i < plan.workouts.length - 1) {\r\n      workouts.push(null);\r\n    }\r\n  });\r\n  return workouts.length > 0 ? workouts : [null];\r\n};\r\n\r\nconst createEmptyPlanDrivenRule = (planId: string, cycleWorkouts: (string | null)[] = [null]): PlanDrivenScheduleRule => ({\r\n  type: 'plan-driven',\r\n  planId,\r\n  startDate: Date.now(),\r\n  cycleWorkouts,\r\n  currentIndex: 0,\r\n});\r\n\r\nconst ScheduleSetupScreen: React.FC = () => {\r\n  const { theme } = useTheme();\r\n  const router = useRouter();\r\n  const { user } = useAuth();\r\n  const setActiveRule = useActiveScheduleStore((state) => state.setActiveRule);\r\n  const currentRule = useActiveScheduleStore((state) => state.state.activeRule);\r\n  \r\n  // Check if we're editing an existing schedule\r\n  const isEditing = !!currentRule;\r\n\r\n  const userPrograms = useProgramsStore((state) => state.userPrograms);\r\n  const plans = usePlansStore((state) => state.plans);\r\n  const hydratePlans = usePlansStore((state) => state.hydratePlans);\r\n  const hydratePrograms = useProgramsStore((state) => state.hydratePrograms);\r\n\r\n  const editorScrollRef = useRef<ScrollView>(null);\r\n\r\n  const [step, setStep] = useState<EditorStep>(isEditing ? 'configure' : 'type-select');\r\n  const [selectedType, setSelectedType] = useState<ScheduleRuleType | null>(\r\n    currentRule?.type || null\r\n  );\r\n  const [draftRule, setDraftRule] = useState<ScheduleRule | null>(() => normalizeScheduleRule(currentRule));\r\n\r\n  const [pickerVisible, setPickerVisible] = useState(false);\r\n  const [pickerContext, setPickerContext] = useState<{\r\n    type: 'weekly' | 'rotating' | 'plan-driven';\r\n    index: number | WeekdayKey;\r\n  } | null>(null);\r\n  const [startDate, setStartDate] = useState<Date>(\r\n    (currentRule?.type === 'rotating' || currentRule?.type === 'plan-driven') \r\n      ? new Date(currentRule.startDate) \r\n      : new Date()\r\n  );\r\n  const [datePickerVisible, setDatePickerVisible] = useState(false);\r\n  const [datePickerViewDate, setDatePickerViewDate] = useState<Date>(\r\n    (currentRule?.type === 'rotating' || currentRule?.type === 'plan-driven') \r\n      ? new Date(currentRule.startDate) \r\n      : new Date()\r\n  );\r\n  const [pendingStartDate, setPendingStartDate] = useState<Date>(\r\n    (currentRule?.type === 'rotating' || currentRule?.type === 'plan-driven') \r\n      ? new Date(currentRule.startDate) \r\n      : new Date()\r\n  );\r\n\r\n  // Ensure data is loaded when component mounts\r\n  useEffect(() => {\r\n    if (user?.id) {\r\n      void hydratePlans(user.id);\r\n      void hydratePrograms();\r\n    }\r\n  }, [user?.id, hydratePlans, hydratePrograms]);\r\n\r\n  const allWorkouts = useMemo((): WorkoutOption[] => {\r\n    const workouts: WorkoutOption[] = [\r\n      { id: null, name: 'Rest Day', source: '', isRest: true },\r\n    ];\r\n\r\n    // Add workouts from programs\r\n    userPrograms.forEach((program) => {\r\n      program.workouts.forEach((w) => {\r\n        if (w.exercises.length > 0) {\r\n          workouts.push({ id: w.id, name: w.name, source: program.name, isRest: false });\r\n        }\r\n      });\r\n    });\r\n\r\n    // Add custom plans (My Workouts)\r\n    plans.forEach((plan) => {\r\n      workouts.push({ id: plan.id, name: plan.name, source: 'My Workouts', isRest: false });\r\n    });\r\n\r\n    // Debug logging (remove in production)\r\n    console.log('All workouts:', workouts);\r\n    console.log('Plans count:', plans.length);\r\n    console.log('Programs count:', userPrograms.length);\r\n\r\n    return workouts;\r\n  }, [userPrograms, plans]);\r\n\r\n  const allPlans = useMemo(() => {\r\n    return userPrograms.map((p) => ({ id: p.id, name: p.name }));\r\n  }, [userPrograms]);\r\n\r\n  const newestPlan = useMemo(() => {\r\n    if (userPrograms.length === 0) return null;\r\n    return [...userPrograms].sort((a, b) => {\r\n      const aTime = Math.max(a.modifiedAt ?? 0, a.createdAt ?? 0);\r\n      const bTime = Math.max(b.modifiedAt ?? 0, b.createdAt ?? 0);\r\n      return bTime - aTime;\r\n    })[0];\r\n  }, [userPrograms]);\r\n\r\n  const handleTypeSelect = useCallback((type: ScheduleRuleType) => {\r\n    triggerHaptic('selection');\r\n    setSelectedType(type);\r\n\r\n    switch (type) {\r\n      case 'weekly':\r\n        setDraftRule(\r\n          currentRule?.type === 'weekly' ? currentRule : createEmptyWeeklyRule()\r\n        );\r\n        break;\r\n      case 'rotating':\r\n        setDraftRule(\r\n          currentRule?.type === 'rotating'\r\n            ? normalizeRotatingRule(currentRule)\r\n            : createEmptyRotatingRule(startDate.getTime())\r\n        );\r\n        break;\r\n      case 'plan-driven':\r\n        if (currentRule?.type === 'plan-driven') {\r\n          setDraftRule(currentRule);\r\n        } else {\r\n          const defaultPlan = newestPlan;\r\n          if (defaultPlan) {\r\n            const cycleWorkouts = getPlanCycleWorkouts(defaultPlan);\r\n            setDraftRule(createEmptyPlanDrivenRule(defaultPlan.id, cycleWorkouts));\r\n          } else {\r\n            setDraftRule(createEmptyPlanDrivenRule('', [null]));\r\n          }\r\n        }\r\n        break;\r\n    }\r\n    setStep('configure');\r\n  }, [currentRule, newestPlan, startDate]);\r\n\r\n  useEffect(() => {\r\n    if (step !== 'configure') return;\r\n    requestAnimationFrame(() => {\r\n      editorScrollRef.current?.scrollTo({ y: 0, animated: false });\r\n    });\r\n  }, [step, selectedType]);\r\n\r\n  useEffect(() => {\r\n    if (selectedType !== 'plan-driven') return;\r\n    if (!draftRule || draftRule.type !== 'plan-driven') return;\r\n    if (!newestPlan) return;\r\n\r\n    const isBlankRule = !draftRule.planId || !draftRule.cycleWorkouts || draftRule.cycleWorkouts.length <= 1;\r\n    if (!isBlankRule) return;\r\n\r\n    const cycleWorkouts = getPlanCycleWorkouts(newestPlan);\r\n    setDraftRule({\r\n      ...draftRule,\r\n      planId: newestPlan.id,\r\n      cycleWorkouts,\r\n    });\r\n  }, [draftRule, newestPlan, selectedType]);\r\n\r\n  const handleBack = useCallback(() => {\r\n    triggerHaptic('selection');\r\n    if (step === 'configure') {\r\n      // Always go to type-select from configure mode\r\n      setStep('type-select');\r\n    } else {\r\n      router.push('/(tabs)/plans');\r\n    }\r\n  }, [step, router]);\r\n\r\n  // Handle Android hardware back button\r\n  useEffect(() => {\r\n    const backAction = () => {\r\n      handleBack();\r\n      return true;\r\n    };\r\n\r\n    const backHandler = BackHandler.addEventListener('hardwareBackPress', backAction);\r\n    return () => backHandler.remove();\r\n  }, [handleBack]);\r\n\r\n  const handleSave = useCallback(async () => {\r\n    triggerHaptic('success');\r\n    \r\n    // Update rotating/plan-driven rule with selected start date\r\n    let finalRule = draftRule;\r\n    if (draftRule?.type === 'rotating') {\r\n      finalRule = {\r\n        ...draftRule,\r\n        startDate: startDate.getTime(),\r\n        cycleWorkouts: normalizeCycleWorkouts(draftRule.cycleWorkouts),\r\n      };\r\n    } else if (draftRule?.type === 'plan-driven') {\r\n      finalRule = {\r\n        ...draftRule,\r\n        startDate: startDate.getTime(),\r\n      };\r\n    }\r\n    \r\n    await setActiveRule(finalRule);\r\n    router.push('/(tabs)/plans');\r\n  }, [draftRule, startDate, setActiveRule, router]);\r\n\r\n  const handleClearSchedule = useCallback(async () => {\r\n    triggerHaptic('warning');\r\n    await setActiveRule(null);\r\n    router.push('/(tabs)/plans');\r\n  }, [setActiveRule, router]);\r\n\r\n  const openWorkoutPicker = useCallback((type: 'weekly' | 'rotating' | 'plan-driven', index: number | WeekdayKey) => {\r\n    triggerHaptic('selection');\r\n    setPickerContext({ type, index });\r\n    setPickerVisible(true);\r\n  }, []);\r\n\r\n  const handleWorkoutSelect = useCallback((workoutId: string | null) => {\r\n    triggerHaptic('selection');\r\n    if (!pickerContext || !draftRule) return;\r\n\r\n    if (pickerContext.type === 'weekly' && draftRule.type === 'weekly') {\r\n      const day = pickerContext.index as WeekdayKey;\r\n      setDraftRule({\r\n        ...draftRule,\r\n        days: { ...draftRule.days, [day]: workoutId },\r\n      });\r\n    } else if (pickerContext.type === 'rotating' && draftRule.type === 'rotating') {\r\n      const idx = pickerContext.index as number;\r\n\r\n      const normalizedCycle = normalizeCycleWorkouts(draftRule.cycleWorkouts);\r\n\r\n      if (idx === normalizedCycle.length && normalizedCycle.length >= MAX_ROTATING_CYCLE_DAYS) {\r\n        setPickerVisible(false);\r\n        setPickerContext(null);\r\n        return;\r\n      }\r\n      \r\n      // Check if this is a new day being added (index equals current length)\r\n      if (idx === normalizedCycle.length) {\r\n        // Add the new day with the selected workout\r\n        setDraftRule({\r\n          ...draftRule,\r\n          cycleWorkouts: normalizeCycleWorkouts([...normalizedCycle, workoutId]),\r\n        });\r\n      } else {\r\n        // Update existing day\r\n        const newCycle = [...normalizedCycle];\r\n        newCycle[idx] = workoutId;\r\n        setDraftRule({ ...draftRule, cycleWorkouts: normalizeCycleWorkouts(newCycle) });\r\n      }\r\n    } else if (pickerContext.type === 'plan-driven' && draftRule.type === 'plan-driven') {\r\n      const idx = pickerContext.index as number;\r\n      const cycleWorkouts = draftRule.cycleWorkouts || [];\r\n\r\n      if (idx === cycleWorkouts.length && cycleWorkouts.length >= MAX_ROTATING_CYCLE_DAYS) {\r\n        setPickerVisible(false);\r\n        setPickerContext(null);\r\n        return;\r\n      }\r\n      \r\n      if (idx === cycleWorkouts.length) {\r\n        setDraftRule({\r\n          ...draftRule,\r\n          cycleWorkouts: [...cycleWorkouts, workoutId],\r\n        });\r\n      } else {\r\n        const newCycle = [...cycleWorkouts];\r\n        newCycle[idx] = workoutId;\r\n        setDraftRule({ ...draftRule, cycleWorkouts: newCycle });\r\n      }\r\n    }\r\n\r\n    setPickerVisible(false);\r\n    setPickerContext(null);\r\n  }, [pickerContext, draftRule]);\r\n\r\n  const pickerTitle = useMemo(() => {\r\n    if (pickerContext?.type === 'weekly') {\r\n      const dayKey = pickerContext.index as WeekdayKey;\r\n      const dayLabel = WEEKDAYS.find((day) => day.key === dayKey)?.label;\r\n      if (dayLabel) {\r\n        return `Select Workout - ${dayLabel}`;\r\n      }\r\n    } else if (pickerContext?.type === 'rotating') {\r\n      const dayIndex = (pickerContext.index as number) ?? 0;\r\n      return `Select Workout - Day ${dayIndex + 1}`;\r\n    }\r\n    return 'Select Workout';\r\n  }, [pickerContext]);\r\n\r\n  const addCycleDay = useCallback(() => {\r\n    if (draftRule?.type !== 'rotating') return;\r\n    triggerHaptic('selection');\r\n    const newIndex = normalizeCycleWorkouts(draftRule.cycleWorkouts).length;\r\n    if (newIndex >= MAX_ROTATING_CYCLE_DAYS) return;\r\n    // Don't add the day yet, just open the picker\r\n    setTimeout(() => {\r\n      openWorkoutPicker('rotating', newIndex);\r\n    }, 100);\r\n  }, [draftRule, openWorkoutPicker]);\r\n\r\n  const removeCycleDay = useCallback((index: number) => {\r\n    if (draftRule?.type !== 'rotating') return;\r\n    if (draftRule.cycleWorkouts.length <= 1) return;\r\n    triggerHaptic('selection');\r\n    const newCycle = [...normalizeCycleWorkouts(draftRule.cycleWorkouts)];\r\n    newCycle.splice(index, 1);\r\n    setDraftRule({ ...draftRule, cycleWorkouts: normalizeCycleWorkouts(newCycle) });\r\n  }, [draftRule]);\r\n\r\n  const updatePlanDrivenPlan = useCallback((planId: string) => {\r\n    if (draftRule?.type !== 'plan-driven') return;\r\n    triggerHaptic('selection');\r\n    \r\n    // Find the selected plan and update cycleWorkouts from its suggested schedule\r\n    const selectedPlan = userPrograms.find(p => p.id === planId);\r\n    if (selectedPlan) {\r\n      const cycleWorkouts = getPlanCycleWorkouts(selectedPlan);\r\n      setDraftRule({ ...draftRule, planId, cycleWorkouts });\r\n    } else {\r\n      setDraftRule({ ...draftRule, planId });\r\n    }\r\n  }, [draftRule, userPrograms]);\r\n\r\n  const addPlanDrivenDay = useCallback(() => {\r\n    if (draftRule?.type !== 'plan-driven') return;\r\n    triggerHaptic('selection');\r\n    const cycleWorkouts = draftRule.cycleWorkouts || [];\r\n    const newIndex = cycleWorkouts.length;\r\n    if (newIndex >= MAX_ROTATING_CYCLE_DAYS) return;\r\n    setTimeout(() => {\r\n      openWorkoutPicker('plan-driven', newIndex);\r\n    }, 100);\r\n  }, [draftRule, openWorkoutPicker]);\r\n\r\n  const removePlanDrivenDay = useCallback((index: number) => {\r\n    if (draftRule?.type !== 'plan-driven') return;\r\n    const cycleWorkouts = draftRule.cycleWorkouts || [];\r\n    if (cycleWorkouts.length <= 1) return;\r\n    triggerHaptic('selection');\r\n    const newCycle = [...cycleWorkouts];\r\n    newCycle.splice(index, 1);\r\n    setDraftRule({ ...draftRule, cycleWorkouts: newCycle });\r\n  }, [draftRule]);\r\n\r\n  const movePlanDrivenDay = useCallback((fromIndex: number, toIndex: number) => {\r\n    if (draftRule?.type !== 'plan-driven') return;\r\n    const cycleWorkouts = draftRule.cycleWorkouts || [];\r\n    if (fromIndex < 0 || toIndex < 0) return;\r\n    if (fromIndex >= cycleWorkouts.length || toIndex >= cycleWorkouts.length) return;\r\n    if (fromIndex === toIndex) return;\r\n\r\n    triggerHaptic('selection');\r\n    const newCycle = [...cycleWorkouts];\r\n    const temp = newCycle[fromIndex];\r\n    newCycle[fromIndex] = newCycle[toIndex];\r\n    newCycle[toIndex] = temp;\r\n    setDraftRule({ ...draftRule, cycleWorkouts: newCycle });\r\n  }, [draftRule]);\r\n\r\n  const getWorkoutName = (workoutId: string | null | undefined): string => {\r\n    if (workoutId == null) return 'Rest Day';\r\n    const workout = allWorkouts.find((w) => w.id === workoutId);\r\n    return workout?.name || 'Unknown';\r\n  };\r\n\r\n  const renderTypeSelection = () => (\r\n    <View style={{ gap: spacing.md, marginTop: spacing.md }}>\r\n      {SCHEDULE_TYPES.map(({ type, label, description, icon }) => {\r\n        const isSelected = selectedType === type;\r\n        return (\r\n          <Pressable\r\n            key={type}\r\n            style={[\r\n              styles.typeCard,\r\n              { backgroundColor: theme.surface.elevated },\r\n              isSelected && { borderColor: theme.accent.orange, borderWidth: 2 },\r\n            ]}\r\n            onPress={() => handleTypeSelect(type)}\r\n          >\r\n            <View style={[styles.typeIcon, { backgroundColor: theme.accent.orange + '20' }]}>\r\n              <IconSymbol\r\n                name={icon as any}\r\n                size={24}\r\n                color={theme.accent.orange}\r\n              />\r\n            </View>\r\n            <View style={styles.typeCardContent}>\r\n              <Text variant=\"bodySemibold\" color=\"primary\">\r\n                {label}\r\n              </Text>\r\n              <Text variant=\"caption\" color=\"secondary\">\r\n                {description}\r\n              </Text>\r\n            </View>\r\n            <IconSymbol\r\n              name=\"chevron-right\"\r\n              size={20}\r\n              color={theme.text.tertiary}\r\n            />\r\n          </Pressable>\r\n        );\r\n      })}\r\n\r\n      {currentRule && (\r\n        <View style={styles.clearButtonWrapper}>\r\n          <Button\r\n            label=\"Clear Schedule\"\r\n            variant=\"ghost\"\r\n            size=\"md\"\r\n            onPress={handleClearSchedule}\r\n            textColor={colors.accent.warning}\r\n          />\r\n        </View>\r\n      )}\r\n    </View>\r\n  );\r\n\r\n  const renderWeeklyEditor = () => {\r\n    if (draftRule?.type !== 'weekly') return null;\r\n\r\n    return (\r\n      <View style={{ gap: spacing.md, marginTop: spacing.md }}>\r\n        <View style={styles.daysList}>\r\n          {WEEKDAYS.map(({ key, label }) => {\r\n            const selectedId = draftRule.days[key];\r\n            const workoutName = getWorkoutName(selectedId);\r\n            const isRest = selectedId === null;\r\n\r\n            return (\r\n              <Pressable\r\n                key={key}\r\n                style={[styles.dayRow, { backgroundColor: theme.surface.elevated }]}\r\n                onPress={() => openWorkoutPicker('weekly', key)}\r\n              >\r\n                <Text variant=\"bodySemibold\" color=\"primary\" style={styles.dayLabel}>\r\n                  {label}\r\n                </Text>\r\n                <View style={styles.dayValue}>\r\n                  <Text\r\n                    variant=\"body\"\r\n                    color={isRest ? 'tertiary' : 'primary'}\r\n                    numberOfLines={1}\r\n                  >\r\n                    {workoutName}\r\n                  </Text>\r\n                  <IconSymbol name=\"chevron-right\" size={16} color={theme.text.tertiary} />\r\n                </View>\r\n              </Pressable>\r\n            );\r\n          })}\r\n        </View>\r\n\r\n        <View style={styles.saveButtonWrapper}>\r\n          <Button\r\n            label=\"Save Schedule\"\r\n            variant=\"primary\"\r\n            size=\"lg\"\r\n            onPress={handleSave}\r\n          />\r\n        </View>\r\n      </View>\r\n    );\r\n  };\r\n\r\n  const renderRotatingEditor = () => {\r\n    if (draftRule?.type !== 'rotating') return null;\r\n\r\n    const normalizedCycle = normalizeCycleWorkouts(draftRule.cycleWorkouts);\r\n\r\n    return (\r\n      <View style={{ gap: spacing.md, marginTop: spacing.md }}>\r\n        <View style={[styles.cycleRow, { backgroundColor: theme.surface.elevated }]}>\r\n          <Text variant=\"bodySemibold\" color=\"primary\" style={styles.cycleDayNum}>\r\n            Start Date\r\n          </Text>\r\n          <Pressable\r\n            style={styles.cycleWorkoutPicker}\r\n            onPress={() => {\r\n              setDatePickerViewDate(startDate);\r\n              setPendingStartDate(startDate);\r\n              setDatePickerVisible(true);\r\n            }}\r\n          >\r\n            <Text\r\n              variant=\"body\"\r\n              color=\"primary\"\r\n              numberOfLines={1}\r\n              style={[styles.cycleWorkoutText, { textAlignVertical: 'center' }]}\r\n            >\r\n              {startDate.toLocaleDateString()}\r\n            </Text>\r\n            <IconSymbol name=\"calendar-today\" size={16} color={theme.text.tertiary} />\r\n          </Pressable>\r\n        </View>\r\n        \r\n        <View style={styles.daysList}>\r\n          {normalizedCycle.map((workoutId, visualIndex) => {\r\n            const workoutName = getWorkoutName(workoutId);\r\n            const isRest = workoutId === null;\r\n\r\n            return (\r\n              <View\r\n                key={`cycle-${visualIndex}-${workoutId ?? 'rest'}`}\r\n                style={[styles.cycleRow, { backgroundColor: theme.surface.elevated }]}\r\n              >\r\n                <Text variant=\"bodySemibold\" color=\"primary\" style={styles.cycleDayNum}>\r\n                  Day {visualIndex + 1}\r\n                </Text>\r\n                <Pressable\r\n                  style={styles.cycleWorkoutPicker}\r\n                  onPress={() => openWorkoutPicker('rotating', visualIndex)}\r\n                >\r\n                  <Text\r\n                    variant=\"body\"\r\n                    color={isRest ? 'tertiary' : 'primary'}\r\n                    numberOfLines={1}\r\n                    style={styles.cycleWorkoutText}\r\n                  >\r\n                    {workoutName}\r\n                  </Text>\r\n                  <IconSymbol name=\"chevron-right\" size={16} color={theme.text.tertiary} />\r\n                </Pressable>\r\n                {normalizedCycle.length > 1 && (\r\n                  <Pressable\r\n                    style={styles.removeButton}\r\n                    onPress={() => removeCycleDay(visualIndex)}\r\n                  >\r\n                    <IconSymbol name=\"close\" size={18} color={theme.accent.warning} />\r\n                  </Pressable>\r\n                )}\r\n              </View>\r\n            );\r\n          })}\r\n        </View>\r\n\r\n        <Pressable\r\n          style={[styles.addDayButton, { backgroundColor: theme.surface.elevated }]}\r\n          onPress={addCycleDay}\r\n          disabled={normalizedCycle.length >= MAX_ROTATING_CYCLE_DAYS}\r\n        >\r\n          <IconSymbol name=\"add\" size={24} color={theme.accent.warning} />\r\n        </Pressable>\r\n\r\n        <View style={styles.saveButtonWrapper}>\r\n          <Button\r\n            label=\"Save Schedule\"\r\n            variant=\"primary\"\r\n            size=\"lg\"\r\n            onPress={handleSave}\r\n          />\r\n        </View>\r\n      </View>\r\n    );\r\n  };\r\n\r\n  const renderPlanDrivenEditor = () => {\r\n    if (draftRule?.type !== 'plan-driven') return null;\r\n\r\n    const cycleWorkouts = draftRule.cycleWorkouts || [];\r\n    const effectiveSelectedPlanId = draftRule.planId || (cycleWorkouts.length > 1 ? newestPlan?.id || '' : '');\r\n\r\n    return (\r\n      <View style={{ gap: spacing.md, marginTop: spacing.md }}>\r\n        {/* Plan Selection */}\r\n        <View style={styles.planList}>\r\n          {allPlans.length === 0 ? (\r\n            <SurfaceCard tone=\"neutral\" padding=\"lg\">\r\n              <Text variant=\"body\" color=\"tertiary\" style={styles.emptyText}>\r\n                No plans available. Create a plan first from My Programs.\r\n              </Text>\r\n            </SurfaceCard>\r\n          ) : (\r\n            <ScrollView horizontal showsHorizontalScrollIndicator={false} style={styles.planScrollView}>\r\n              {allPlans.map((plan) => {\r\n                const isSelected = effectiveSelectedPlanId === plan.id;\r\n                return (\r\n                  <Pressable\r\n                    key={plan.id}\r\n                    style={[\r\n                      styles.planChip,\r\n                      {\r\n                        backgroundColor: isSelected ? theme.accent.orange : theme.surface.elevated,\r\n                        borderColor: isSelected ? theme.accent.orange : theme.border.light,\r\n                      },\r\n                    ]}\r\n                    onPress={() => updatePlanDrivenPlan(plan.id)}\r\n                  >\r\n                    <Text \r\n                      variant=\"bodySemibold\" \r\n                      color={isSelected ? 'onAccent' : 'primary'}\r\n                    >\r\n                      {plan.name}\r\n                    </Text>\r\n                  </Pressable>\r\n                );\r\n              })}\r\n            </ScrollView>\r\n          )}\r\n        </View>\r\n\r\n        {/* Start Date */}\r\n        <View style={[styles.cycleRow, { backgroundColor: theme.surface.elevated }]}>\r\n          <Text variant=\"bodySemibold\" color=\"primary\" style={styles.cycleDayNum}>\r\n            Start Date\r\n          </Text>\r\n          <Pressable\r\n            style={styles.cycleWorkoutPicker}\r\n            onPress={() => {\r\n              setDatePickerViewDate(startDate);\r\n              setPendingStartDate(startDate);\r\n              setDatePickerVisible(true);\r\n            }}\r\n          >\r\n            <Text\r\n              variant=\"body\"\r\n              color=\"primary\"\r\n              numberOfLines={1}\r\n              style={[styles.cycleWorkoutText, { textAlignVertical: 'center' }]}\r\n            >\r\n              {startDate.toLocaleDateString()}\r\n            </Text>\r\n            <IconSymbol name=\"calendar-today\" size={16} color={theme.text.tertiary} />\r\n          </Pressable>\r\n        </View>\r\n\r\n        {/* Cycle Days */}\r\n        <View style={styles.daysList}>\r\n          {cycleWorkouts.map((workoutId, visualIndex) => {\r\n            const workoutName = getWorkoutName(workoutId);\r\n            const isRest = workoutId === null;\r\n            const canMoveUp = visualIndex > 0;\r\n            const canMoveDown = visualIndex < cycleWorkouts.length - 1;\r\n\r\n            return (\r\n              <View\r\n                key={`plan-cycle-${visualIndex}-${workoutId ?? 'rest'}`}\r\n                style={[styles.cycleRow, { backgroundColor: theme.surface.elevated }]}\r\n              >\r\n                <Text variant=\"bodySemibold\" color=\"primary\" style={styles.cycleDayNum}>\r\n                  Day {visualIndex + 1}\r\n                </Text>\r\n                <View style={styles.reorderButtonsContainer}>\r\n                  <Pressable\r\n                    style={[styles.reorderButton, !canMoveUp && styles.reorderButtonDisabled]}\r\n                    disabled={!canMoveUp}\r\n                    onPress={() => movePlanDrivenDay(visualIndex, visualIndex - 1)}\r\n                    hitSlop={8}\r\n                  >\r\n                    <IconSymbol\r\n                      name=\"keyboard-arrow-up\"\r\n                      size={20}\r\n                      color={canMoveUp ? theme.text.secondary : theme.text.tertiary}\r\n                    />\r\n                  </Pressable>\r\n                  <Pressable\r\n                    style={[styles.reorderButton, !canMoveDown && styles.reorderButtonDisabled]}\r\n                    disabled={!canMoveDown}\r\n                    onPress={() => movePlanDrivenDay(visualIndex, visualIndex + 1)}\r\n                    hitSlop={8}\r\n                  >\r\n                    <IconSymbol\r\n                      name=\"keyboard-arrow-down\"\r\n                      size={20}\r\n                      color={canMoveDown ? theme.text.secondary : theme.text.tertiary}\r\n                    />\r\n                  </Pressable>\r\n                </View>\r\n                <Pressable\r\n                  style={styles.cycleWorkoutPicker}\r\n                  onPress={() => openWorkoutPicker('plan-driven', visualIndex)}\r\n                >\r\n                  <Text\r\n                    variant=\"body\"\r\n                    color={isRest ? 'tertiary' : 'primary'}\r\n                    numberOfLines={1}\r\n                    style={styles.cycleWorkoutText}\r\n                  >\r\n                    {workoutName}\r\n                  </Text>\r\n                  <IconSymbol name=\"chevron-right\" size={16} color={theme.text.tertiary} />\r\n                </Pressable>\r\n                {cycleWorkouts.length > 1 && (\r\n                  <Pressable\r\n                    style={styles.removeButton}\r\n                    onPress={() => removePlanDrivenDay(visualIndex)}\r\n                  >\r\n                    <IconSymbol name=\"close\" size={18} color={theme.accent.warning} />\r\n                  </Pressable>\r\n                )}\r\n              </View>\r\n            );\r\n          })}\r\n        </View>\r\n\r\n        {/* Add Day Button */}\r\n        <Pressable\r\n          style={[styles.addDayButton, { backgroundColor: theme.surface.elevated }]}\r\n          onPress={addPlanDrivenDay}\r\n          disabled={cycleWorkouts.length >= MAX_ROTATING_CYCLE_DAYS}\r\n        >\r\n          <IconSymbol name=\"add\" size={24} color={theme.accent.warning} />\r\n        </Pressable>\r\n\r\n        {/* Save Button */}\r\n        {allPlans.length > 0 && (\r\n          <View style={styles.saveButtonWrapper}>\r\n            <Button\r\n              label=\"Save Schedule\"\r\n              variant=\"primary\"\r\n              size=\"lg\"\r\n              onPress={handleSave}\r\n            />\r\n          </View>\r\n        )}\r\n      </View>\r\n    );\r\n  };\r\n\r\n  const renderConfigureStep = () => {\r\n    switch (selectedType) {\r\n      case 'weekly':\r\n        return renderWeeklyEditor();\r\n      case 'rotating':\r\n        return renderRotatingEditor();\r\n      case 'plan-driven':\r\n        return renderPlanDrivenEditor();\r\n      default:\r\n        return null;\r\n    }\r\n  };\r\n\r\n  const renderWorkoutPicker = () => (\r\n    <Modal\r\n      visible={pickerVisible}\r\n      transparent\r\n      animationType=\"fade\"\r\n      onRequestClose={() => setPickerVisible(false)}\r\n    >\r\n      <View style={[styles.pickerOverlay, { backgroundColor: colors.overlay.scrim }]}>\r\n        <View style={[styles.pickerPopup, { backgroundColor: theme.surface.card }]}>\r\n          <View style={styles.pickerHeader}>\r\n            <Text variant=\"heading3\" color=\"primary\">\r\n              {pickerTitle}\r\n            </Text>\r\n            <Pressable onPress={() => setPickerVisible(false)}>\r\n              <IconSymbol name=\"close\" size={24} color={theme.text.primary} />\r\n            </Pressable>\r\n          </View>\r\n\r\n          <ScrollView\r\n            style={styles.pickerScroll}\r\n            contentContainerStyle={styles.pickerScrollContent}\r\n            showsVerticalScrollIndicator={false}\r\n          >\r\n            {allWorkouts.map((item) => (\r\n              <Pressable\r\n                key={item.id || 'rest'}\r\n                style={[styles.pickerItem, { borderBottomColor: theme.border.light }]}\r\n                onPress={() => handleWorkoutSelect(item.id)}\r\n              >\r\n                <View style={styles.pickerItemContent}>\r\n                  <Text variant=\"bodySemibold\" color={item.isRest ? 'tertiary' : 'primary'}>\r\n                    {item.name}\r\n                  </Text>\r\n                  {item.source && !item.isRest && item.source !== 'My Workouts' && (\r\n                    <Text variant=\"caption\" color=\"secondary\">\r\n                      {item.source}\r\n                    </Text>\r\n                  )}\r\n                </View>\r\n                              </Pressable>\r\n            ))}\r\n          </ScrollView>\r\n        </View>\r\n      </View>\r\n    </Modal>\r\n  );\r\n\r\n  const getTitle = () => {\r\n    if (step === 'type-select') return 'Create Schedule';\r\n    switch (selectedType) {\r\n      case 'weekly': return 'Weekly Schedule';\r\n      case 'rotating': return 'Rotating Cycle';\r\n      case 'plan-driven': return 'Plan-Driven';\r\n      default: return 'Create Schedule';\r\n    }\r\n  };\r\n\r\n  const getSubtitle = () => {\r\n    if (step === 'type-select') return 'Choose how you want to organize your training';\r\n    switch (selectedType) {\r\n      case 'weekly': return 'Assign workouts to specific days of the week';\r\n      case 'rotating': return 'Create a cycle that repeats regardless of the day';\r\n      case 'plan-driven': return 'Follow a saved plan in order';\r\n      default: return '';\r\n    }\r\n  };\r\n\r\n  const renderDatePicker = () => {\r\n    if (!datePickerVisible) return null;\r\n\r\n    // Generate calendar days\r\n    const year = datePickerViewDate.getFullYear();\r\n    const month = datePickerViewDate.getMonth();\r\n    const firstDay = new Date(year, month, 1);\r\n    const lastDay = new Date(year, month + 1, 0);\r\n    const daysInMonth = lastDay.getDate();\r\n    const startingDayOfWeek = firstDay.getDay();\r\n\r\n    const calendarDays = [];\r\n    \r\n    // Add empty cells for days before month starts\r\n    for (let i = 0; i < startingDayOfWeek; i++) {\r\n      calendarDays.push(null);\r\n    }\r\n    \r\n    // Add days of the month\r\n    for (let i = 1; i <= daysInMonth; i++) {\r\n      calendarDays.push(i);\r\n    }\r\n\r\n    const handleDateSelect = (day: number) => {\r\n      const newDate = new Date(year, month, day);\r\n      setPendingStartDate(newDate);\r\n    };\r\n\r\n    const handleSaveStartDate = () => {\r\n      triggerHaptic('selection');\r\n      setStartDate(pendingStartDate);\r\n      setDatePickerVisible(false);\r\n    };\r\n\r\n    const handleMonthChange = (direction: 'prev' | 'next') => {\r\n      const newDate = new Date(datePickerViewDate);\r\n      if (direction === 'prev') {\r\n        newDate.setMonth(month - 1);\r\n      } else {\r\n        newDate.setMonth(month + 1);\r\n      }\r\n      setDatePickerViewDate(newDate);\r\n    };\r\n\r\n    return (\r\n      <Modal\r\n        visible={datePickerVisible}\r\n        transparent\r\n        animationType=\"fade\"\r\n        onRequestClose={() => setDatePickerVisible(false)}\r\n      >\r\n        <Pressable \r\n          style={[styles.pickerOverlay, { backgroundColor: colors.overlay.scrim }]} \r\n          onPress={() => setDatePickerVisible(false)}\r\n        >\r\n          <View style={[styles.datePickerPopup, { backgroundColor: theme.surface.card }]}>\r\n            <View style={styles.pickerHeader}>\r\n              <Text variant=\"heading3\" color=\"primary\">\r\n                Select Start Date\r\n              </Text>\r\n              <Pressable onPress={() => setDatePickerVisible(false)}>\r\n                <IconSymbol name=\"close\" size={24} color={theme.text.primary} />\r\n              </Pressable>\r\n            </View>\r\n\r\n            <View style={styles.content}>\r\n              {/* Month navigation */}\r\n              <View style={styles.monthNavigation}>\r\n                <Pressable onPress={() => handleMonthChange('prev')} style={styles.monthNavButton}>\r\n                  <IconSymbol name=\"chevron-left\" size={20} color={theme.text.primary} />\r\n                </Pressable>\r\n                <Text variant=\"bodySemibold\" color=\"primary\">\r\n                  {datePickerViewDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' })}\r\n                </Text>\r\n                <Pressable onPress={() => handleMonthChange('next')} style={styles.monthNavButton}>\r\n                  <IconSymbol name=\"chevron-right\" size={20} color={theme.text.primary} />\r\n                </Pressable>\r\n              </View>\r\n\r\n              {/* Weekday headers */}\r\n              <View style={styles.weekdayHeaders}>\r\n                {['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map((day) => (\r\n                  <View key={day} style={styles.weekdayHeaderCell}>\r\n                    <Text variant=\"caption\" color=\"primary\" style={styles.weekdayHeaderText}>\r\n                      {day}\r\n                    </Text>\r\n                  </View>\r\n                ))}\r\n              </View>\r\n\r\n              {/* Calendar grid */}\r\n              <View style={styles.calendarGrid}>\r\n                {calendarDays.map((day, index) => {\r\n                  if (day === null) {\r\n                    return <View key={`empty-${index}`} style={styles.calendarDay} />;\r\n                  }\r\n                  \r\n                  const isSelected =\r\n                    pendingStartDate.getFullYear() === year &&\r\n                    pendingStartDate.getMonth() === month &&\r\n                    pendingStartDate.getDate() === day;\r\n                  const isToday = new Date().getDate() === day && \r\n                                 new Date().getMonth() === month && \r\n                                 new Date().getFullYear() === year;\r\n\r\n                  return (\r\n                    <Pressable\r\n                      key={day}\r\n                      style={[\r\n                        styles.calendarDay,\r\n                        isSelected && { backgroundColor: theme.accent.orange },\r\n                        isToday && !isSelected && { backgroundColor: theme.surface.elevated },\r\n                      ]}\r\n                      onPress={() => handleDateSelect(day)}\r\n                    >\r\n                      <Text\r\n                        variant=\"body\"\r\n                        color={isSelected ? 'onAccent' : 'primary'}\r\n                        style={isToday && !isSelected ? { fontWeight: 'bold' } : {}}\r\n                      >\r\n                        {day}\r\n                      </Text>\r\n                    </Pressable>\r\n                  );\r\n                })}\r\n              </View>\r\n\r\n              <View style={styles.datePickerActions}>\r\n                <Button\r\n                  label=\"Save\"\r\n                  variant=\"primary\"\r\n                  size=\"md\"\r\n                  onPress={handleSaveStartDate}\r\n                />\r\n              </View>\r\n            </View>\r\n          </View>\r\n        </Pressable>\r\n      </Modal>\r\n    );\r\n  };\r\n\r\n  return (\r\n    <TabSwipeContainer>\r\n      <View style={styles.container}>\r\n        {/* Header */}\r\n        <View style={styles.header}>\r\n          <View style={styles.titleContainer}>\r\n            <Text variant=\"heading2\" color=\"primary\">\r\n              {getTitle()}\r\n            </Text>\r\n            <Text variant=\"body\" color=\"secondary\">\r\n              {getSubtitle()}\r\n            </Text>\r\n          </View>\r\n          <Pressable onPress={handleBack} style={styles.backButton} hitSlop={8}>\r\n            <IconSymbol name=\"arrow-back\" size={24} color={colors.text.primary} />\r\n          </Pressable>\r\n        </View>\r\n        \r\n        <ScrollView\r\n          ref={editorScrollRef}\r\n          style={styles.editorScroll}\r\n          contentContainerStyle={styles.contentContainer}\r\n          showsVerticalScrollIndicator={false}\r\n        >\r\n          {step === 'type-select' ? renderTypeSelection() : renderConfigureStep()}\r\n        </ScrollView>\r\n      </View>\r\n\r\n      {renderWorkoutPicker()}\r\n      {renderDatePicker()}\r\n    </TabSwipeContainer>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    flex: 1,\r\n    backgroundColor: colors.primary.bg,\r\n  },\r\n  header: {\r\n    flexDirection: 'row',\r\n    alignItems: 'flex-start',\r\n    justifyContent: 'space-between',\r\n    paddingHorizontal: spacing.md,\r\n    paddingTop: spacing.xl,\r\n    paddingBottom: spacing.lg,\r\n    gap: spacing.sm,\r\n  },\r\n  backButton: {\r\n    padding: spacing.sm,\r\n    paddingTop: spacing.xs,\r\n    borderRadius: radius.full,\r\n  },\r\n  titleContainer: {\r\n    flex: 1,\r\n  },\r\n  editorScroll: {\r\n    flex: 1,\r\n  },\r\n  contentContainer: {\r\n    flexGrow: 1,\r\n    paddingHorizontal: spacing.md,\r\n    paddingBottom: spacing.sm,\r\n    gap: spacing.xl,\r\n  },\r\n  scrollView: {\r\n    flex: 1,\r\n  },\r\n  content: {\r\n    padding: spacing.md,\r\n    gap: spacing.lg,\r\n  },\r\n  sectionTitle: {\r\n    textAlign: 'center',\r\n  },\r\n  sectionSubtitle: {\r\n    textAlign: 'center',\r\n    marginBottom: spacing.sm,\r\n  },\r\n  typeList: {\r\n    gap: spacing.md,\r\n  },\r\n  typeCard: {\r\n    borderRadius: radius.lg,\r\n    borderWidth: StyleSheet.hairlineWidth,\r\n    borderColor: colors.border.light,\r\n    backgroundColor: colors.surface.card,\r\n    paddingVertical: spacing.md,\r\n    paddingHorizontal: spacing.lg,\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    gap: spacing.md,\r\n    ...shadows.cardSoft,\r\n  },\r\n  typeIcon: {\r\n    width: 48,\r\n    height: 48,\r\n    borderRadius: radius.md,\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n  },\r\n  typeCardContent: {\r\n    flex: 1,\r\n    gap: spacing.xxs,\r\n  },\r\n  clearButtonWrapper: {\r\n    marginTop: spacing.xl,\r\n    alignItems: 'center',\r\n  },\r\n  daysList: {\r\n    gap: spacing.sm,\r\n  },\r\n  dayRow: {\r\n    borderRadius: radius.lg,\r\n    borderWidth: StyleSheet.hairlineWidth,\r\n    borderColor: colors.border.light,\r\n    backgroundColor: colors.surface.card,\r\n    paddingVertical: spacing.md,\r\n    paddingHorizontal: spacing.lg,\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'space-between',\r\n    ...shadows.cardSoft,\r\n  },\r\n  dayLabel: {\r\n    width: 100,\r\n  },\r\n  dayValue: {\r\n    flex: 1,\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'flex-end',\r\n    gap: spacing.sm,\r\n  },\r\n  cycleRow: {\r\n    borderRadius: radius.lg,\r\n    borderWidth: StyleSheet.hairlineWidth,\r\n    borderColor: colors.border.light,\r\n    backgroundColor: colors.surface.card,\r\n    paddingVertical: spacing.md,\r\n    paddingHorizontal: spacing.lg,\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    gap: spacing.sm,\r\n    ...shadows.cardSoft,\r\n  },\r\n  cycleDayNum: {\r\n    width: 80,\r\n  },\r\n  cycleWorkoutPicker: {\r\n    flex: 1,\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'flex-end',\r\n    gap: spacing.sm,\r\n    minHeight: 44,\r\n  },\r\n  cycleWorkoutText: {\r\n    flex: 1,\r\n    textAlign: 'right',\r\n    textAlignVertical: 'center',\r\n  },\r\n  removeButton: {\r\n    padding: spacing.sm,\r\n  },\r\n  reorderButtonsContainer: {\r\n    flexDirection: 'column',\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    gap: 2,\r\n  },\r\n  reorderButton: {\r\n    paddingHorizontal: spacing.xs,\r\n    paddingVertical: 2,\r\n    borderRadius: radius.sm,\r\n  },\r\n  reorderButtonDisabled: {\r\n    opacity: 0.5,\r\n  },\r\n  addDayWrapper: {\r\n    alignItems: 'center',\r\n  },\r\n  saveButtonWrapper: {\r\n    marginTop: spacing.lg,\r\n  },\r\n  planList: {\r\n    gap: spacing.md,\r\n  },\r\n  planScrollView: {\r\n    flexGrow: 0,\r\n  },\r\n  planChip: {\r\n    paddingVertical: spacing.sm,\r\n    paddingHorizontal: spacing.lg,\r\n    borderRadius: radius.full,\r\n    marginRight: spacing.sm,\r\n    borderWidth: StyleSheet.hairlineWidth,\r\n  },\r\n  planCard: {\r\n    borderRadius: radius.lg,\r\n    borderWidth: StyleSheet.hairlineWidth,\r\n    borderColor: colors.border.light,\r\n    backgroundColor: colors.surface.card,\r\n    paddingVertical: spacing.md,\r\n    paddingHorizontal: spacing.lg,\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'space-between',\r\n    ...shadows.cardSoft,\r\n  },\r\n  emptyText: {\r\n    textAlign: 'center',\r\n  },\r\n  pickerOverlay: {\r\n    flex: 1,\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n  },\r\n  pickerPopup: {\r\n    borderRadius: radius.xl,\r\n    width: '90%',\r\n    maxHeight: '80%',\r\n    marginHorizontal: spacing.md,\r\n    minHeight: 280,\r\n    overflow: 'hidden',\r\n  },\r\n  pickerHeader: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'space-between',\r\n    padding: spacing.lg,\r\n    borderBottomWidth: StyleSheet.hairlineWidth,\r\n    borderBottomColor: colors.border.light,\r\n  },\r\n  pickerScroll: {\r\n    maxHeight: 420,\r\n  },\r\n  pickerScrollContent: {\r\n    paddingHorizontal: spacing.lg,\r\n    paddingBottom: spacing.lg,\r\n  },\r\n  pickerItem: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'space-between',\r\n    padding: spacing.lg,\r\n    borderBottomWidth: StyleSheet.hairlineWidth,\r\n  },\r\n  pickerItemContent: {\r\n    flex: 1,\r\n    gap: spacing.xxs,\r\n  },\r\n  debugSection: {\r\n    borderRadius: radius.lg,\r\n    padding: spacing.lg,\r\n    gap: spacing.md,\r\n    marginTop: spacing.lg,\r\n  },\r\n  iconRow: {\r\n    flexDirection: 'row',\r\n    justifyContent: 'space-around',\r\n    gap: spacing.md,\r\n  },\r\n  iconItem: {\r\n    alignItems: 'center',\r\n    gap: spacing.xs,\r\n  },\r\n  iconGrid: {\r\n    flexDirection: 'row',\r\n    flexWrap: 'wrap',\r\n    justifyContent: 'space-between',\r\n    gap: spacing.sm,\r\n  },\r\n  iconSectionTitle: {\r\n    marginTop: spacing.lg,\r\n  },\r\n  // Date picker styles\r\n  datePickerPopup: {\r\n    borderRadius: radius.xl,\r\n    width: '90%',\r\n    maxHeight: '80%',\r\n    marginHorizontal: spacing.md,\r\n    minHeight: 280,\r\n    overflow: 'hidden',\r\n  },\r\n  headerTitle: {\r\n    flex: 1,\r\n    textAlign: 'center',\r\n  },\r\n  closeButton: {\r\n    position: 'absolute',\r\n    right: spacing.lg,\r\n    padding: spacing.xs,\r\n  },\r\n  monthNavigation: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'space-between',\r\n    paddingHorizontal: spacing.md,\r\n    paddingVertical: spacing.xs,\r\n    marginBottom: spacing.sm,\r\n  },\r\n  monthNavButton: {\r\n    padding: spacing.sm,\r\n    borderRadius: radius.full,\r\n  },\r\n  weekdayHeaders: {\r\n    flexDirection: 'row',\r\n    paddingHorizontal: spacing.md,\r\n    paddingTop: 0,\r\n    paddingBottom: spacing.xxs,\r\n  },\r\n  weekdayHeaderCell: {\r\n    flex: 1,\r\n  },\r\n  weekdayHeaderText: {\r\n    textAlign: 'center',\r\n    fontWeight: '600',\r\n    fontSize: 12,\r\n    paddingTop: 0,\r\n    paddingBottom: 0,\r\n  },\r\n  calendarGrid: {\r\n    flexDirection: 'row',\r\n    flexWrap: 'wrap',\r\n    paddingHorizontal: spacing.md,\r\n    paddingTop: 0,\r\n    paddingBottom: spacing.sm,\r\n  },\r\n  calendarDay: {\r\n    width: `${100 / 7}%`,\r\n    aspectRatio: 1,\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    borderRadius: radius.full,\r\n    marginHorizontal: 0,\r\n    marginVertical: 1,\r\n  },\r\n  datePickerActions: {\r\n    marginTop: spacing.sm,\r\n    alignItems: 'center',\r\n  },\r\n  // Add day card styles\r\n  addDayCard: {\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n    borderStyle: 'dashed',\r\n    borderWidth: 1,\r\n    borderColor: colors.accent.warning + '40',\r\n  },\r\n  addDayContent: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    gap: spacing.sm,\r\n  },\r\n  addDayText: {\r\n    color: colors.accent.warning,\r\n  },\r\n  addDayButton: {\r\n    width: 48,\r\n    height: 48,\r\n    borderRadius: radius.full,\r\n    borderWidth: StyleSheet.hairlineWidth,\r\n    borderColor: colors.accent.warning + '40',\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    alignSelf: 'center',\r\n    marginTop: spacing.md,\r\n    ...shadows.cardSoft,\r\n  },\r\n  // Swipe indicator styles\r\n  swipeIndicator: {\r\n    alignItems: 'center',\r\n    paddingVertical: spacing.xs,\r\n  },\r\n  swipeBar: {\r\n    width: 36,\r\n    height: 4,\r\n    backgroundColor: colors.border.light,\r\n    borderRadius: radius.full,\r\n  },\r\n});\r\n\r\nexport default ScheduleSetupScreen;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\app\\(tabs)\\volume-analytics.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\app\\(tabs)\\workout-detail.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\app\\(tabs)\\workout-preview.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'PremadeWorkout' is defined but never used.","line":29,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":29,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'from' is assigned a value but never used.","line":118,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":118,"endColumn":13}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * WorkoutPreviewScreen\r\n * Preview screen for premade workouts - \"take it or leave it\" style.\r\n * Similar to program-details.tsx but for individual workouts.\r\n * \r\n * Features:\r\n * - Instant load (no loading states - data already in store)\r\n * - Shows workout name, description, exercises\r\n * - \"Add to My Workouts\" button to save\r\n * - Back navigation to browse workouts\r\n */\r\nimport React, { useCallback, useState, useRef, useEffect } from 'react';\r\nimport { View, StyleSheet, ScrollView, Alert, Pressable, BackHandler } from 'react-native';\r\nimport { useLocalSearchParams, useRouter } from 'expo-router';\r\nimport { useFocusEffect } from '@react-navigation/native';\r\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { Button } from '@/components/atoms/Button';\r\nimport { Badge } from '@/components/atoms';\r\nimport { SurfaceCard } from '@/components/atoms/SurfaceCard';\r\nimport { IconSymbol } from '@/components/ui/icon-symbol';\r\nimport { PremiumLimitModal } from '@/components/molecules/PremiumLimitModal';\r\nimport { colors, spacing, radius, sizing } from '@/constants/theme';\r\nimport { useProgramsStore } from '@/store/programsStore';\r\nimport { usePlansStore } from '@/store/plansStore';\r\nimport { exercises as exerciseCatalog } from '@/constants/exercises';\r\nimport type { PremadeWorkout } from '@/types/premadePlan';\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    flex: 1,\r\n    backgroundColor: colors.primary.bg,\r\n  },\r\n  header: {\r\n    flexDirection: 'row',\r\n    alignItems: 'flex-start',\r\n    justifyContent: 'space-between',\r\n    paddingTop: spacing.xl,\r\n    paddingBottom: spacing.md,\r\n    gap: spacing.sm,\r\n  },\r\n  backButton: {\r\n    padding: spacing.sm,\r\n    paddingTop: spacing.xs,\r\n    borderRadius: radius.full,\r\n  },\r\n  titleContainer: {\r\n    flex: 1,\r\n  },\r\n  scrollContent: {\r\n    paddingHorizontal: spacing.md,\r\n    paddingBottom: spacing['2xl'],\r\n    gap: spacing.lg,\r\n  },\r\n  outerCardContent: {\r\n    gap: spacing.lg,\r\n  },\r\n  metadataRow: {\r\n    flexDirection: 'row',\r\n    flexWrap: 'wrap',\r\n    gap: spacing.sm,\r\n    marginTop: spacing.sm,\r\n  },\r\n  exerciseCard: {\r\n    borderRadius: radius.md,\r\n    backgroundColor: colors.surface.card,\r\n    borderWidth: 1,\r\n    borderColor: colors.border.light,\r\n    padding: spacing.md,\r\n    gap: spacing.xs,\r\n  },\r\n  exerciseRow: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    gap: spacing.sm,\r\n    paddingVertical: spacing.sm,\r\n  },\r\n  exerciseNumber: {\r\n    width: sizing.iconLG,\r\n    height: sizing.iconLG,\r\n    borderRadius: radius.full,\r\n    backgroundColor: colors.surface.card,\r\n    borderWidth: 1,\r\n    borderColor: colors.accent.orange,\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n    flexShrink: 0,\r\n  },\r\n  exerciseNumberText: {\r\n    color: colors.text.primary,\r\n    fontSize: 16,\r\n    fontWeight: '600',\r\n    includeFontPadding: false,\r\n  },\r\n  exerciseNameContainer: {\r\n    flex: 1,\r\n    flexShrink: 1,\r\n    width: 0,\r\n  },\r\n  exerciseName: {\r\n    fontSize: 18,\r\n    fontWeight: '500',\r\n    color: colors.text.primary,\r\n  },\r\n  exercisesList: {\r\n    gap: spacing.sm,\r\n  },\r\n});\r\n\r\nexport default function WorkoutPreviewScreen() {\r\n  const router = useRouter();\r\n  const insets = useSafeAreaInsets();\r\n  const scrollRef = useRef<ScrollView>(null);\r\n  const params = useLocalSearchParams<{ workoutId: string; from?: string }>();\r\n  const workoutId = Array.isArray(params.workoutId) ? params.workoutId[0] : params.workoutId;\r\n  const from = Array.isArray(params.from) ? params.from[0] : params.from;\r\n\r\n  const { premadeWorkouts } = useProgramsStore();\r\n  const { addPlan, plans } = usePlansStore();\r\n  const [isAdding, setIsAdding] = useState(false);\r\n  const [showLimitModal, setShowLimitModal] = useState(false);\r\n\r\n  // Direct lookup - instant, no loading needed\r\n  const workout = premadeWorkouts.find(w => w.id === workoutId);\r\n\r\n  // Check if already added\r\n  const isAlreadyAdded = plans.some(p => p.name === workout?.name);\r\n\r\n  const handleBack = useCallback(() => {\r\n    triggerHaptic('selection');\r\n    router.back();\r\n  }, [router]);\r\n\r\n  // Reset scroll position when screen gains focus\r\n  useFocusEffect(\r\n    useCallback(() => {\r\n      const timeout = setTimeout(() => {\r\n        scrollRef.current?.scrollTo({ y: 0, animated: false });\r\n      }, 50);\r\n      return () => clearTimeout(timeout);\r\n    }, [])\r\n  );\r\n\r\n  // Handle Android hardware back button\r\n  useEffect(() => {\r\n    const backAction = () => {\r\n      handleBack();\r\n      return true;\r\n    };\r\n\r\n    const backHandler = BackHandler.addEventListener('hardwareBackPress', backAction);\r\n    return () => backHandler.remove();\r\n  }, [handleBack]);\r\n\r\n  const handleAddToWorkouts = useCallback(async () => {\r\n    if (isAdding || !workout) return;\r\n    setIsAdding(true);\r\n    triggerHaptic('selection');\r\n\r\n    try {\r\n      // Resolve exercises from catalog\r\n      const resolvedExercises = workout.exercises\r\n        .map(ex => exerciseCatalog.find(e => e.id === ex.id))\r\n        .filter((e): e is NonNullable<typeof e> => e !== null && e !== undefined);\r\n\r\n      await addPlan({\r\n        name: workout.name,\r\n        exercises: resolvedExercises,\r\n        source: 'library',\r\n      });\r\n\r\n      triggerHaptic('success');\r\n\r\n      // Navigate to My Workouts (Plans tab)\r\n      router.replace('/(tabs)/plans');\r\n    } catch (error: any) {\r\n      if (error?.message === 'FREE_LIMIT_REACHED') {\r\n        setShowLimitModal(true);\r\n      } else {\r\n        console.error('Failed to add workout:', error);\r\n        Alert.alert('Error', 'Failed to add workout to your library.');\r\n      }\r\n    } finally {\r\n      setIsAdding(false);\r\n    }\r\n  }, [addPlan, isAdding, workout, router]);\r\n\r\n  // Not found state - instant render\r\n  if (!workout) {\r\n    return (\r\n      <View style={[styles.container, { paddingTop: insets.top, paddingBottom: insets.bottom + sizing.tabBarHeight }]}>\r\n        <View style={[styles.header, { paddingHorizontal: spacing.md }]}>\r\n          <View style={styles.titleContainer}>\r\n            <Text variant=\"heading2\" color=\"primary\">Workout Not Found</Text>\r\n            <Text variant=\"body\" color=\"secondary\">The requested workout could not be found.</Text>\r\n          </View>\r\n          <Pressable onPress={handleBack} style={styles.backButton} hitSlop={8}>\r\n            <IconSymbol name=\"arrow-back\" size={24} color={colors.text.primary} />\r\n          </Pressable>\r\n        </View>\r\n        <View style={{ justifyContent: 'center', alignItems: 'center', flex: 1 }}>\r\n          <Button label=\"Go Back\" onPress={handleBack} />\r\n        </View>\r\n      </View>\r\n    );\r\n  }\r\n\r\n  // Format experience level for display\r\n  const formatExperience = (level: string) => {\r\n    return level.charAt(0).toUpperCase() + level.slice(1);\r\n  };\r\n\r\n  // Format goal for display\r\n  const formatGoal = (goalStr: string) => {\r\n    return goalStr.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <PremiumLimitModal\r\n        visible={showLimitModal}\r\n        onClose={() => setShowLimitModal(false)}\r\n        limitType=\"workout\"\r\n      />\r\n      <View style={[styles.container, { paddingTop: insets.top, paddingBottom: insets.bottom + sizing.tabBarHeight }]}>\r\n        <ScrollView ref={scrollRef} contentContainerStyle={styles.scrollContent}>\r\n          {/* Header */}\r\n          <View style={styles.header}>\r\n            <View style={styles.titleContainer}>\r\n              <Text variant=\"heading2\" color=\"primary\">\r\n                {workout.name}\r\n              </Text>\r\n              <Text variant=\"body\" color=\"secondary\">\r\n                {workout.metadata.description}\r\n              </Text>\r\n\r\n              {/* Metadata badges */}\r\n              <View style={styles.metadataRow}>\r\n                <Badge\r\n                  label={formatExperience(workout.metadata.experienceLevel)}\r\n                  variant=\"workout\"\r\n                />\r\n                <Badge\r\n                  label={formatGoal(workout.metadata.goal)}\r\n                  variant=\"workout\"\r\n                />\r\n                <Badge\r\n                  label={`~${workout.metadata.durationMinutes} min`}\r\n                  variant=\"workout\"\r\n                />\r\n              </View>\r\n            </View>\r\n            <Pressable onPress={handleBack} style={styles.backButton} hitSlop={8}>\r\n              <IconSymbol name=\"arrow-back\" size={24} color={colors.text.primary} />\r\n            </Pressable>\r\n          </View>\r\n\r\n          {/* Exercises Card */}\r\n          <SurfaceCard padding=\"xl\" tone=\"neutral\">\r\n            <View style={styles.outerCardContent}>\r\n              <Text variant=\"heading3\" color=\"primary\">\r\n                Exercises ({workout.exercises.length})\r\n              </Text>\r\n              <View style={styles.exercisesList}>\r\n                {workout.exercises.map((exercise, index) => (\r\n                  <View key={exercise.id} style={styles.exerciseRow}>\r\n                    <View style={styles.exerciseNumber}>\r\n                      <Text style={styles.exerciseNumberText}>\r\n                        {index + 1}\r\n                      </Text>\r\n                    </View>\r\n                    <View style={styles.exerciseNameContainer}>\r\n                      <Text style={styles.exerciseName}>\r\n                        {exercise.name}\r\n                      </Text>\r\n                    </View>\r\n                  </View>\r\n                ))}\r\n              </View>\r\n            </View>\r\n          </SurfaceCard>\r\n\r\n          {/* Action Button */}\r\n          <View style={styles.outerCardContent}>\r\n            {isAlreadyAdded ? (\r\n              <Button\r\n                label=\"Already in My Workouts\"\r\n                onPress={() => router.replace('/(tabs)/plans')}\r\n                size=\"lg\"\r\n                variant=\"secondary\"\r\n              />\r\n            ) : (\r\n              <Button\r\n                label=\"Add to My Workouts\"\r\n                onPress={handleAddToWorkouts}\r\n                loading={isAdding}\r\n                size=\"lg\"\r\n              />\r\n            )}\r\n          </View>\r\n        </ScrollView>\r\n      </View>\r\n    </>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\app\\(tabs)\\workout.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Plan' is defined but never used.","line":13,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":34}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useCallback, useState, useRef, useMemo, useEffect } from 'react';\nimport { Pressable, StyleSheet, View, ScrollView, BackHandler } from 'react-native';\nimport { triggerHaptic } from '@/utils/haptics';\nimport { useFocusEffect, useScrollToTop } from '@react-navigation/native';\nimport { Button } from '@/components/atoms/Button';\nimport { Text } from '@/components/atoms/Text';\nimport { IconSymbol } from '@/components/ui/icon-symbol';\nimport { SurfaceCard } from '@/components/atoms/SurfaceCard';\nimport { TabSwipeContainer } from '@/components/templates/TabSwipeContainer';\nimport { WorkoutInProgressModal } from '@/components/molecules/WorkoutInProgressModal';\nimport { radius, sizing, spacing } from '@/constants/theme';\nimport { useTheme } from '@/hooks/useTheme';\nimport { usePlansStore, type Plan, type PlansState } from '@/store/plansStore';\nimport { useProgramsStore } from '@/store/programsStore';\nimport { useSessionStore } from '@/store/sessionStore';\nimport type { WorkoutExercise } from '@/types/workout';\nimport { createSetsWithHistory } from '@/utils/workout';\nimport { useWorkoutSessionsStore } from '@/store/workoutSessionsStore';\nimport WorkoutSessionScreen from '../workout-session';\nimport { WorkoutCompletionOverlay } from '@/components/organisms';\n\nconst styles = StyleSheet.create({\n  contentContainer: {\n    flexGrow: 1,\n    minHeight: '100%',\n    justifyContent: 'center',\n    alignItems: 'center',\n    paddingHorizontal: spacing.md,\n    paddingBottom: spacing.sm,\n    paddingTop: spacing['2xl'],\n    position: 'relative',\n  },\n  heroContainer: {\n    width: '100%',\n    alignItems: 'center',\n    gap: spacing.lg,\n    paddingTop: 64,\n    position: 'relative',\n  },\n  heroTitle: {\n    textAlign: 'center',\n  },\n  buttonWrapper: {\n    width: '100%',\n  },\n  optionsContainer: {\n    width: '100%',\n    alignItems: 'center',\n    gap: spacing.md,\n  },\n  topBar: {\n    position: 'absolute',\n    top: spacing.md,\n    left: spacing.sm,\n  },\n  backIconButton: {\n    padding: spacing.sm,\n    borderRadius: spacing.md,\n  },\n  planList: {\n    width: '100%',\n    gap: spacing.sm,\n  },\n  planCard: {\n    borderRadius: radius.lg,\n  },\n  planCardContent: {\n    gap: spacing.xs,\n  },\n});\n\nconst WorkoutScreen: React.FC = () => {\n  const { theme } = useTheme();\n  const scrollRef = useRef<ScrollView>(null);\n  useScrollToTop(scrollRef);\n\n  useFocusEffect(\n    useCallback(() => {\n      scrollRef.current?.scrollTo({ y: 0, animated: false });\n    }, [])\n  );\n\n  const [workoutInProgressVisible, setWorkoutInProgressVisible] = useState<boolean>(false);\n  const [showPlansList, setShowPlansList] = useState<boolean>(false);\n\n  // Handle Android hardware back button - navigate to Dashboard\n  useEffect(() => {\n    const backAction = () => {\n      if (showPlansList) {\n        setShowPlansList(false);\n        return true;\n      }\n      // If not showing plans list, go to Dashboard\n      return false; // Let default behavior handle it (will go to Dashboard via tab navigation)\n    };\n\n    const backHandler = BackHandler.addEventListener('hardwareBackPress', backAction);\n    return () => backHandler.remove();\n  }, [showPlansList]);\n  const plans = usePlansStore((state: PlansState) => state.plans);\n  const { userPrograms } = useProgramsStore();\n  const startSession = useSessionStore((state) => state.startSession);\n  const isSessionActive = useSessionStore((state) => state.isSessionActive);\n  const currentSession = useSessionStore((state) => state.currentSession);\n  const isCompletionOverlayVisible = useSessionStore((state) => state.isCompletionOverlayVisible);\n  const setCompletionOverlayVisible = useSessionStore((state) => state.setCompletionOverlayVisible);\n\n  const handleBack = () => {\n    triggerHaptic('selection');\n    setShowPlansList(false);\n  };\n\n  const handleStartFromPlan = () => {\n    setShowPlansList(true);\n  };\n\n  const allWorkouts = useWorkoutSessionsStore((state) => state.workouts);\n\n  // Combine workouts from both plans and programs with name-based deduplication\n  // This prevents duplicates when the same workout exists in both plansStore and programs\n  const allAvailableWorkouts = useMemo(() => {\n    interface WorkoutItem {\n      id: string;\n      name: string;\n      exercises: any[];\n      type: 'custom' | 'program';\n      programId?: string;\n      programName?: string;\n      subtitle: string;\n    }\n\n    // Use name-based grouping to prevent duplicates\n    const workoutsGroupedByName: Record<string, WorkoutItem> = {};\n\n    // Add custom workouts from plansStore first (these are the \"source of truth\")\n    plans.forEach(plan => {\n      const nameKey = plan.name.trim().toLowerCase();\n      if (!workoutsGroupedByName[nameKey]) {\n        workoutsGroupedByName[nameKey] = {\n          id: plan.id,\n          name: plan.name,\n          exercises: plan.exercises,\n          type: 'custom',\n          subtitle: `${plan.exercises.length} ${plan.exercises.length === 1 ? 'exercise' : 'exercises'}`\n        };\n      }\n    });\n\n    // Add workouts from programs - only if not already present by name\n    // If already present, update to show plan info (the workout is part of a plan)\n    userPrograms.forEach(prog => {\n      prog.workouts.forEach(w => {\n        if (w.exercises.length === 0) return;\n\n        const nameKey = w.name.trim().toLowerCase();\n        if (!workoutsGroupedByName[nameKey]) {\n          // New workout from program\n          workoutsGroupedByName[nameKey] = {\n            id: w.id,\n            name: w.name,\n            exercises: w.exercises,\n            type: 'program',\n            programId: prog.id,\n            programName: prog.name,\n            subtitle: `${prog.name}  ${w.exercises.length} ${w.exercises.length === 1 ? 'exercise' : 'exercises'}`\n          };\n        } else {\n          // Already exists - update to show it's part of a plan\n          // Use the program version's exercises (more up-to-date after edits)\n          workoutsGroupedByName[nameKey].exercises = w.exercises;\n          workoutsGroupedByName[nameKey].type = 'program';\n          workoutsGroupedByName[nameKey].programId = prog.id;\n          workoutsGroupedByName[nameKey].programName = prog.name;\n          workoutsGroupedByName[nameKey].subtitle = `${prog.name}  ${w.exercises.length} ${w.exercises.length === 1 ? 'exercise' : 'exercises'}`;\n        }\n      });\n    });\n\n    // Convert to array and sort\n    return Object.values(workoutsGroupedByName).sort((a, b) => {\n      // Priority 1: Group by Plan (Custom considered as a plan group)\n      const aPlanGroup = a.type === 'custom' ? 'Custom' : a.programName || '';\n      const bPlanGroup = b.type === 'custom' ? 'Custom' : b.programName || '';\n\n      const planComparison = aPlanGroup.localeCompare(bPlanGroup);\n      if (planComparison !== 0) return planComparison;\n\n      // Priority 2: Alphabetical within plan group\n      return a.name.localeCompare(b.name);\n    });\n  }, [plans, userPrograms]);\n\n  const handlePlanSelect = useCallback(\n    (workout: any) => {\n      triggerHaptic('selection');\n\n      const doStartSession = () => {\n        setCompletionOverlayVisible(false);\n\n        const historySetCounts: Record<string, number> = {};\n        const mappedExercises: WorkoutExercise[] = workout.exercises.map((exercise: any) => {\n          const { sets, historySetCount } = createSetsWithHistory(exercise.name, allWorkouts);\n          historySetCounts[exercise.name] = historySetCount;\n          return {\n            name: exercise.name,\n            sets,\n          };\n        });\n\n        const planId = workout.type === 'program' ? workout.programId : workout.id;\n        startSession(planId, mappedExercises, workout.name, historySetCounts);\n        setShowPlansList(false);\n      };\n\n      if (isSessionActive && currentSession) {\n        setWorkoutInProgressVisible(true);\n        return;\n      }\n\n      doStartSession();\n    },\n    [startSession, setCompletionOverlayVisible, allWorkouts, isSessionActive, currentSession],\n  );\n\n  const handleStartFromScratch = useCallback(() => {\n    triggerHaptic('selection');\n\n    const doStartSession = () => {\n      setCompletionOverlayVisible(false);\n      startSession(null, [], null);\n      setShowPlansList(false);\n    };\n\n    if (isSessionActive && currentSession) {\n      setWorkoutInProgressVisible(true);\n      return;\n    }\n\n    doStartSession();\n  }, [startSession, setCompletionOverlayVisible, isSessionActive, currentSession]);\n\n  useFocusEffect(\n    useCallback(() => {\n      setShowPlansList(false);\n    }, [])\n  );\n\n  if (isSessionActive && currentSession) {\n    return (\n      <>\n        {isCompletionOverlayVisible ? (\n          <WorkoutCompletionOverlay onDismiss={() => setCompletionOverlayVisible(false)} />\n        ) : null}\n        <WorkoutSessionScreen />\n      </>\n    );\n  }\n\n  return (\n    <TabSwipeContainer ref={scrollRef} contentContainerStyle={styles.contentContainer}>\n      <WorkoutInProgressModal\n        visible={workoutInProgressVisible}\n        sessionName={currentSession?.name ?? 'Current Workout'}\n        elapsedMinutes={currentSession ? Math.floor((Date.now() - currentSession.startTime) / 60000) : 0}\n        onResume={() => {\n          setWorkoutInProgressVisible(false);\n          setShowPlansList(false);\n        }}\n        onCancel={() => {\n          setWorkoutInProgressVisible(false);\n        }}\n      />\n      {isCompletionOverlayVisible ? (\n        <WorkoutCompletionOverlay onDismiss={() => setCompletionOverlayVisible(false)} />\n      ) : null}\n      {showPlansList ? (\n        <View style={styles.topBar}>\n          <Pressable style={styles.backIconButton} onPress={handleBack} hitSlop={spacing.sm}>\n            <IconSymbol name=\"arrow-back\" color={theme.text.primary} size={sizing.iconMD} />\n          </Pressable>\n        </View>\n      ) : null}\n      <View style={styles.heroContainer}>\n        {showPlansList ? (\n          <>\n            <Text variant=\"display1\" color=\"primary\" style={styles.heroTitle} fadeIn>\n              Select a Workout\n            </Text>\n            <View style={styles.planList}>\n              {allAvailableWorkouts.length > 0 ? (\n                allAvailableWorkouts.map((workout) => (\n                  <Pressable\n                    key={`${workout.type}-${workout.id}`}\n                    onPress={() => handlePlanSelect(workout)}\n                    accessibilityRole=\"button\"\n                    accessibilityLabel={`Start ${workout.name}`}\n                  >\n                    <SurfaceCard tone=\"neutral\" padding=\"md\" showAccentStripe={false} style={styles.planCard}>\n                      <View style={styles.planCardContent}>\n                        <Text variant=\"bodySemibold\" color=\"primary\">\n                          {workout.name}\n                        </Text>\n                        <Text variant=\"body\" color=\"secondary\">\n                          {workout.subtitle}\n                        </Text>\n                      </View>\n                    </SurfaceCard>\n                  </Pressable>\n                ))\n              ) : (\n                <SurfaceCard tone=\"neutral\" padding=\"md\" showAccentStripe={false} style={styles.planCard}>\n                  <View style={styles.planCardContent}>\n                    <Text variant=\"bodySemibold\" color=\"primary\">\n                      No saved workouts yet\n                    </Text>\n                    <Text variant=\"body\" color=\"secondary\">\n                      Create a workout from the Plans tab to see it here.\n                    </Text>\n                  </View>\n                </SurfaceCard>\n              )}\n            </View>\n          </>\n        ) : (\n          <>\n            <Text variant=\"display1\" color=\"primary\" style={styles.heroTitle} fadeIn>\n              Start Your Next Session\n            </Text>\n            <View style={styles.optionsContainer}>\n              <View style={styles.buttonWrapper}>\n                <Button label=\"Start from Saved Workout\" size=\"lg\" onPress={handleStartFromPlan} />\n              </View>\n              <View style={styles.buttonWrapper}>\n                <Button label=\"Start from Scratch\" size=\"lg\" variant=\"light\" onPress={handleStartFromScratch} />\n              </View>\n            </View>\n          </>\n        )}\n      </View>\n    </TabSwipeContainer>\n  );\n};\n\nexport default WorkoutScreen;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\app\\_layout.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'router'. Either include it or remove the dependency array.","line":45,"column":6,"nodeType":"ArrayExpression","endLine":45,"endColumn":36,"suggestions":[{"desc":"Update the dependencies array to be: [session, segments, isLoading, router]","fix":{"range":[1760,1790],"text":"[session, segments, isLoading, router]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useMemo, useState } from 'react';\nimport { DarkTheme, DefaultTheme, ThemeProvider } from '@react-navigation/native';\nimport { Stack, useSegments, useRouter } from 'expo-router';\nimport { StatusBar } from 'expo-status-bar';\nimport * as NavigationBar from 'expo-navigation-bar';\nimport { Platform, StyleSheet, ActivityIndicator, View } from 'react-native';\nimport { GestureHandlerRootView } from 'react-native-gesture-handler';\nimport { MaterialIcons } from '@expo/vector-icons';\nimport * as Font from 'expo-font';\nimport 'react-native-reanimated';\n\nimport { colors, darkColors } from '@/constants/theme';\nimport { useTheme } from '@/hooks/useTheme';\nimport { AuthProvider, useAuth } from '@/providers/AuthProvider';\nimport { PlanBuilderProvider } from '@/providers/PlanBuilderProvider';\nimport { ProgramBuilderProvider } from '@/providers/ProgramBuilderProvider';\nimport { useUserProfileStore } from '@/store/userProfileStore';\nimport { useActiveScheduleStore } from '@/store/activeScheduleStore';\nimport { useCustomExerciseStore } from '@/store/customExerciseStore';\nimport { useSettingsStore } from '@/store/settingsStore';\n\nimport './add-exercises';\n\nexport const unstable_settings = {\n  anchor: '(tabs)',\n  useNativeStack: true,\n};\n\nconst useProtectedRoute = (session: any, isLoading: boolean) => {\n  const segments = useSegments();\n  const router = useRouter();\n\n  useEffect(() => {\n    if (isLoading) return;\n\n    const inAuthGroup = (segments[0] as string) === 'auth';\n\n    if (!session && !inAuthGroup) {\n      // Redirect to the sign-in page.\n      router.replace('/auth/login' as any);\n    } else if (session && inAuthGroup) {\n      // Redirect away from the sign-in page.\n      router.replace('/(tabs)' as any);\n    }\n  }, [session, segments, isLoading]);\n};\n\nconst RootLayout: React.FC = () => {\n  const [fontsLoaded, setFontsLoaded] = useState(false);\n  const { isDarkMode, theme } = useTheme();\n\n  // Preload MaterialIcons font to prevent icon lag on first render\n  useEffect(() => {\n    const loadFonts = async () => {\n      try {\n        await Font.loadAsync(MaterialIcons.font);\n        setFontsLoaded(true);\n      } catch (error) {\n        console.warn('[RootLayout] Failed to load MaterialIcons font:', error);\n        setFontsLoaded(true); // Continue anyway to not block the app\n      }\n    };\n    loadFonts();\n  }, []);\n\n  const statusBarStyle: 'light' | 'dark' = isDarkMode ? 'light' : 'dark';\n  const statusBarBackgroundColor = Platform.OS === 'android'\n    ? 'transparent'\n    : theme.primary.bg;\n  const androidStatusBarStyle: 'light' | 'dark' = isDarkMode ? 'light' : 'dark';\n\n  const navigationTheme = useMemo(\n    () => {\n      if (isDarkMode) {\n        return {\n          ...DarkTheme,\n          colors: {\n            ...DarkTheme.colors,\n            background: darkColors.primary.bg,\n            card: darkColors.primary.bg,\n            text: darkColors.text.primary,\n            border: darkColors.border.dark,\n            primary: darkColors.accent.primary,\n          },\n        };\n      }\n\n      return {\n        ...DefaultTheme,\n        colors: {\n          ...DefaultTheme.colors,\n          background: colors.primary.bg,\n          card: colors.primary.bg,\n          text: colors.text.primary,\n          border: colors.border.dark,\n          primary: colors.accent.primary,\n        },\n      };\n    },\n    [isDarkMode],\n  );\n\n  useEffect(() => {\n    if (Platform.OS !== 'android') {\n      return;\n    }\n\n    const configureNavigationBar = async () => {\n      const androidVersion = typeof Platform.Version === 'number'\n        ? Platform.Version\n        : Number.parseInt(String(Platform.Version), 10);\n\n      try {\n        if (!Number.isNaN(androidVersion) && androidVersion < 29) {\n          await NavigationBar.setBackgroundColorAsync(theme.primary.bg);\n        }\n      } catch (error) {\n        console.warn('[NavigationBar] Unable to set background color', error);\n      }\n\n      try {\n        await NavigationBar.setButtonStyleAsync(isDarkMode ? 'light' : 'dark');\n      } catch (error) {\n        console.warn('[NavigationBar] Unable to set button style', error);\n      }\n    };\n\n    void configureNavigationBar();\n  }, [isDarkMode, theme.primary.bg]);\n\n  return (\n    <AuthProvider>\n      <PlanBuilderProvider>\n        <ProgramBuilderProvider>\n          <RootLayoutNav\n            navigationTheme={navigationTheme}\n            isDarkMode={isDarkMode}\n            theme={theme}\n            statusBarBackgroundColor={statusBarBackgroundColor}\n            statusBarStyle={statusBarStyle}\n            androidStatusBarStyle={androidStatusBarStyle}\n            fontsLoaded={fontsLoaded}\n          />\n        </ProgramBuilderProvider>\n      </PlanBuilderProvider>\n    </AuthProvider>\n  );\n};\n\n// Separate component to use the Auth context\nconst RootLayoutNav = ({\n  navigationTheme,\n  isDarkMode,\n  theme,\n  statusBarBackgroundColor,\n  statusBarStyle,\n  androidStatusBarStyle,\n  fontsLoaded,\n}: any) => {\n  const { session, isLoading, user } = useAuth();\n  const segments = useSegments();\n  const fetchProfile = useUserProfileStore((state) => state.fetchProfile);\n  const hydrateActiveSchedule = useActiveScheduleStore((state) => state.hydrateActiveSchedule);\n  const hydrateCustomExercises = useCustomExerciseStore((state) => state.hydrateCustomExercises);\n  const syncFromSupabase = useSettingsStore((state) => state.syncFromSupabase);\n\n  // Fetch profile and hydrate stores when user session is established\n  useEffect(() => {\n    if (user?.id) {\n      fetchProfile(user.id);\n      hydrateActiveSchedule(user.id);\n      hydrateCustomExercises(user.id);\n      syncFromSupabase();\n    }\n  }, [user?.id, fetchProfile, hydrateActiveSchedule, hydrateCustomExercises, syncFromSupabase]);\n\n  useProtectedRoute(session, isLoading);\n\n  const inAuthGroup = segments[0] === 'auth';\n\n  if (isLoading || !fontsLoaded || (!session && !inAuthGroup)) {\n    return (\n      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: theme.primary.bg }}>\n        <ActivityIndicator size=\"large\" color={theme.accent.primary} />\n      </View>\n    );\n  }\n\n  return (\n    <GestureHandlerRootView\n      style={[styles.root, { backgroundColor: theme.primary.bg }]}\n    >\n      <ThemeProvider value={navigationTheme}>\n        <Stack\n          screenOptions={{\n            headerShown: false,\n            animation: 'slide_from_bottom',\n          }}\n        >\n          <Stack.Screen name=\"(tabs)\" options={{ headerShown: false, animation: 'none' }} />\n          <Stack.Screen name=\"auth\" options={{ headerShown: false, animation: 'fade' }} />\n          <Stack.Screen\n            name=\"plan-detail\"\n            options={{\n              animation: 'none',\n              headerShown: false,\n              presentation: 'transparentModal',\n              contentStyle: {\n                backgroundColor: 'transparent',\n              },\n            }}\n          />\n          <Stack.Screen\n            name=\"workout-edit\"\n            options={{\n              animation: 'slide_from_right',\n              headerShown: false,\n            }}\n          />\n          <Stack.Screen\n            name=\"workout-success\"\n            options={{\n              headerShown: false,\n              animation: 'none',\n            }}\n          />\n          <Stack.Screen\n            name=\"add-exercises\"\n            options={{\n              presentation: 'card',\n              headerShown: false,\n              animation: 'none',\n            }}\n          />\n          <Stack.Screen\n            name=\"program-view\"\n            options={{\n              animation: 'none',\n              headerShown: false,\n            }}\n          />\n          <Stack.Screen\n            name=\"modals\"\n            options={{\n              headerShown: false,\n              animation: 'slide_from_bottom',\n            }}\n          />\n          <Stack.Screen\n            name=\"hercules-ai\"\n            options={{\n              headerShown: false,\n              animation: 'slide_from_bottom',\n            }}\n          />\n        </Stack>\n        <StatusBar\n          animated\n          backgroundColor={statusBarBackgroundColor}\n          style={Platform.OS === 'android' ? androidStatusBarStyle : statusBarStyle}\n        />\n      </ThemeProvider>\n    </GestureHandlerRootView>\n  );\n};\n\nexport default RootLayout;\n\nconst styles = StyleSheet.create({\n  root: {\n    flex: 1,\n  },\n});","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\app\\add-exercises.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\app\\add-workouts-to-program.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\app\\auth\\_layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\app\\auth\\login.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Ionicons' is defined but never used.","line":15,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'signInWithOtp' is assigned a value but never used.","line":23,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":23,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\r\nimport {\r\n    View,\r\n    Text,\r\n    TextInput,\r\n    TouchableOpacity,\r\n    StyleSheet,\r\n    ActivityIndicator,\r\n    Alert,\r\n    KeyboardAvoidingView,\r\n    Platform,\r\n    ScrollView,\r\n} from 'react-native';\r\nimport { useRouter, Link } from 'expo-router';\r\nimport { Ionicons } from '@expo/vector-icons';\r\n\r\nimport { colors, spacing, typography, radius, sizing } from '@/constants/theme';\r\nimport { useAuth } from '@/providers/AuthProvider';\r\nimport { supabaseClient } from '@/lib/supabaseClient';\r\n\r\nexport default function LoginScreen() {\r\n    const router = useRouter();\r\n    const { signInWithOtp } = useAuth(); // We might want to switch to password auth for \"profile creation\" flow\r\n    const [email, setEmail] = useState('');\r\n    const [password, setPassword] = useState('');\r\n    const [loading, setLoading] = useState(false);\r\n\r\n    // Switching to password auth since the user mentioned \"make a profile\"\r\n    // OTP is great but password is more standard for \"profile\" based apps initially\r\n    const handleLogin = async () => {\r\n        if (!email || !password) {\r\n            Alert.alert('Error', 'Please fill in all fields');\r\n            return;\r\n        }\r\n\r\n        setLoading(true);\r\n        try {\r\n            const { error } = await supabaseClient.auth.signInWithPassword({\r\n                email,\r\n                password,\r\n            });\r\n\r\n            if (error) throw error;\r\n\r\n            // Navigation is handled by the auth listener in the root layout (to be implemented)\r\n            // or we can manually push if we don't have a listener redirect\r\n            router.replace('/(tabs)');\r\n        } catch (error: any) {\r\n            Alert.alert('Login Failed', error.message);\r\n        } finally {\r\n            setLoading(false);\r\n        }\r\n    };\r\n\r\n    return (\r\n        <KeyboardAvoidingView\r\n            behavior={Platform.OS === 'ios' ? 'padding' : 'height'}\r\n            style={styles.container}\r\n        >\r\n            <ScrollView contentContainerStyle={styles.scrollContent}>\r\n                <View style={styles.header}>\r\n                    <Text style={styles.title}>Welcome Back!</Text>\r\n                    <Text style={styles.subtitle}>Sign in to continue your fitness journey</Text>\r\n                </View>\r\n\r\n                <View style={styles.form}>\r\n                    <View style={styles.inputGroup}>\r\n                        <Text style={styles.label}>Email</Text>\r\n                        <TextInput\r\n                            style={styles.input}\r\n                            placeholder=\"Enter your email\"\r\n                            placeholderTextColor={colors.text.tertiary}\r\n                            value={email}\r\n                            onChangeText={setEmail}\r\n                            autoCapitalize=\"none\"\r\n                            keyboardType=\"email-address\"\r\n                        />\r\n                    </View>\r\n\r\n                    <View style={styles.inputGroup}>\r\n                        <Text style={styles.label}>Password</Text>\r\n                        <TextInput\r\n                            style={styles.input}\r\n                            placeholder=\"Enter your password\"\r\n                            placeholderTextColor={colors.text.tertiary}\r\n                            value={password}\r\n                            onChangeText={setPassword}\r\n                            secureTextEntry\r\n                        />\r\n                    </View>\r\n\r\n                    <TouchableOpacity\r\n                        style={styles.button}\r\n                        onPress={handleLogin}\r\n                        disabled={loading}\r\n                    >\r\n                        {loading ? (\r\n                            <ActivityIndicator color=\"#fff\" />\r\n                        ) : (\r\n                            <Text style={styles.buttonText}>Sign In</Text>\r\n                        )}\r\n                    </TouchableOpacity>\r\n\r\n                    <View style={styles.footer}>\r\n                        <Text style={styles.footerText}>Don&apos;t have an account? </Text>\r\n                        <Link href=\"/auth/signup\" asChild>\r\n                            <TouchableOpacity>\r\n                                <Text style={styles.linkText}>Sign Up</Text>\r\n                            </TouchableOpacity>\r\n                        </Link>\r\n                    </View>\r\n                </View>\r\n            </ScrollView>\r\n        </KeyboardAvoidingView>\r\n    );\r\n}\r\n\r\nconst styles = StyleSheet.create({\r\n    container: {\r\n        flex: 1,\r\n        backgroundColor: colors.primary.bg,\r\n    },\r\n    scrollContent: {\r\n        flexGrow: 1,\r\n        justifyContent: 'center',\r\n        padding: spacing.lg,\r\n    },\r\n    header: {\r\n        marginBottom: spacing.xl,\r\n        alignItems: 'center',\r\n    },\r\n    title: {\r\n        ...typography.heading1,\r\n        color: colors.text.primary,\r\n        marginBottom: spacing.sm,\r\n        textAlign: 'center',\r\n    },\r\n    subtitle: {\r\n        ...typography.body,\r\n        color: colors.text.secondary,\r\n        textAlign: 'center',\r\n    },\r\n    form: {\r\n        width: '100%',\r\n    },\r\n    inputGroup: {\r\n        marginBottom: spacing.md,\r\n    },\r\n    label: {\r\n        ...typography.labelMedium,\r\n        color: colors.text.primary,\r\n        marginBottom: spacing.xs,\r\n    },\r\n    input: {\r\n        height: sizing.inputHeight,\r\n        borderWidth: 1,\r\n        borderColor: colors.neutral.gray200,\r\n        borderRadius: radius.md,\r\n        paddingHorizontal: spacing.md,\r\n        fontSize: 16,\r\n        color: colors.text.primary,\r\n        backgroundColor: colors.surface.card,\r\n    },\r\n    button: {\r\n        height: sizing.buttonLG,\r\n        backgroundColor: colors.accent.primary,\r\n        borderRadius: radius.full,\r\n        justifyContent: 'center',\r\n        alignItems: 'center',\r\n        marginTop: spacing.md,\r\n        shadowColor: colors.accent.primary,\r\n        shadowOffset: { width: 0, height: 4 },\r\n        shadowOpacity: 0.3,\r\n        shadowRadius: 8,\r\n        elevation: 4,\r\n    },\r\n    buttonText: {\r\n        ...typography.bodySemibold,\r\n        color: '#fff',\r\n    },\r\n    footer: {\r\n        flexDirection: 'row',\r\n        justifyContent: 'center',\r\n        marginTop: spacing.xl,\r\n    },\r\n    footerText: {\r\n        ...typography.body,\r\n        color: colors.text.secondary,\r\n    },\r\n    linkText: {\r\n        ...typography.bodySemibold,\r\n        color: colors.accent.primary,\r\n    },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\app\\auth\\signup.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\app\\create-plan.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'withSpring' is defined but never used.","line":19,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'zIndex' is defined but never used.","line":37,"column":43,"nodeType":null,"messageId":"unusedVar","endLine":37,"endColumn":49},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'isPremadeReview'. Either include it or remove the dependency array.","line":362,"column":6,"nodeType":"ArrayExpression","endLine":362,"endColumn":102,"suggestions":[{"desc":"Update the dependencies array to be: [editingPlanCreatedAt, editingPlanId, isPremadeReview, persistPlan, planName, selectedExercises, updatePlanStore]","fix":{"range":[11980,12076],"text":"[editingPlanCreatedAt, editingPlanId, isPremadeReview, persistPlan, planName, selectedExercises, updatePlanStore]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport {\n  Dimensions,\n  KeyboardAvoidingView,\n  Platform,\n  Pressable,\n  ScrollView,\n  StyleSheet,\n  View,\n  BackHandler,\n} from 'react-native';\nimport { useLocalSearchParams, useRouter } from 'expo-router';\nimport { triggerHaptic } from '@/utils/haptics';\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\nimport Animated, {\n  runOnJS,\n  useAnimatedStyle,\n  useSharedValue,\n  withSpring,\n  withTiming,\n} from 'react-native-reanimated';\n\nimport { Text } from '@/components/atoms/Text';\nimport { SurfaceCard } from '@/components/atoms/SurfaceCard';\nimport { Button } from '@/components/atoms/Button';\nimport { IconSymbol } from '@/components/ui/icon-symbol';\nimport { PlanQuickBuilderCard } from '@/components/molecules/PlanQuickBuilderCard';\nimport type { PlanQuickBuilderField } from '@/types/planQuickBuilder';\nimport { PlanSelectedExerciseList } from '@/components/molecules/PlanSelectedExerciseList';\nimport { PremiumLimitModal } from '@/components/molecules/PremiumLimitModal';\nimport { DeleteConfirmationModal } from '@/components/molecules/DeleteConfirmationModal';\nimport { useSemanticExerciseSearch } from '@/hooks/useSemanticExerciseSearch';\nimport { type Plan, type PlansState, usePlansStore } from '@/store/plansStore';\nimport { useProgramsStore } from '@/store/programsStore';\nimport { exercises, type Exercise, type ExerciseCatalogItem } from '@/constants/exercises';\nimport { timingSlow } from '@/constants/animations';\nimport { colors, radius, spacing, sizing, zIndex } from '@/constants/theme';\n\nconst SCREEN_HEIGHT = Dimensions.get('window').height;\n\ntype SubmitPlanResult = 'success' | 'missing-name' | 'no-exercises' | 'error';\n\nconst styles = StyleSheet.create({\n  container: {\n    ...StyleSheet.absoluteFillObject,\n    backgroundColor: colors.primary.bg,\n    paddingHorizontal: spacing.md,\n    paddingBottom: spacing.lg,\n  },\n  scrollContent: {\n    flexGrow: 1,\n    gap: spacing.sm,\n    paddingBottom: spacing['2xl'] * 4,\n  },\n  keyboardAvoider: {\n    flex: 1,\n  },\n  topSection: {\n    width: '100%',\n    marginTop: spacing.md,\n    marginBottom: spacing.sm,\n    gap: spacing.md,\n    flexDirection: 'row',\n    alignItems: 'flex-start',\n    justifyContent: 'space-between',\n  },\n  backButtonContainer: {\n    borderRadius: radius.lg,\n    marginLeft: spacing.sm,\n    paddingTop: spacing.xs,\n  },\n  backButtonPressable: {\n    paddingVertical: spacing.xs,\n    paddingRight: spacing.sm,\n    paddingLeft: 0,\n    borderRadius: radius.lg,\n    alignItems: 'flex-start',\n    justifyContent: 'center',\n  },\n  headerContent: {\n    gap: spacing.sm,\n    alignItems: 'flex-start',\n    flex: 1,\n  },\n  headerTitle: {\n    textAlign: 'left',\n  },\n  headerSubtitle: {\n    textAlign: 'left',\n    maxWidth: 320,\n  },\n  builderContainer: {\n    marginTop: -spacing.sm,\n  },\n  missingPlanCard: {\n    gap: spacing.md,\n    borderWidth: StyleSheet.hairlineWidth,\n    borderColor: colors.border.light,\n    borderRadius: radius.lg,\n    backgroundColor: colors.surface.card,\n    position: 'relative',\n  },\n});\n\nconst CreatePlanScreen: React.FC = () => {\n  const router = useRouter();\n  const insets = useSafeAreaInsets();\n  const { planId, premadeWorkoutId } = useLocalSearchParams<{ planId?: string; premadeWorkoutId?: string }>();\n  const editingPlanId = useMemo(() => {\n    if (!planId) {\n      return null;\n    }\n\n    return Array.isArray(planId) ? planId[0] ?? null : planId;\n  }, [planId]);\n\n  const targetPremadeWorkoutId = useMemo(() => {\n    if (!premadeWorkoutId) {\n      return null;\n    }\n    return Array.isArray(premadeWorkoutId) ? premadeWorkoutId[0] ?? null : premadeWorkoutId;\n  }, [premadeWorkoutId]);\n  const scrollRef = useRef<ScrollView | null>(null);\n  const cardOffset = useRef<number>(0);\n  const fieldPositions = useRef<Record<PlanQuickBuilderField, number>>({\n    planName: 0,\n    search: 0,\n  });\n  const containerTranslateY = useSharedValue(SCREEN_HEIGHT);\n  const [planName, setPlanName] = useState<string>('');\n  const [searchTerm, setSearchTerm] = useState<string>('');\n  const [selectedExercises, setSelectedExercises] = useState<Exercise[]>([]);\n  const [isSaving, setIsSaving] = useState<boolean>(false);\n  const [focusedField, setFocusedField] = useState<PlanQuickBuilderField | null>(null);\n  const hasInitializedFromPlan = useRef<boolean>(false);\n  const [isNameDuplicate, setIsNameDuplicate] = useState<boolean>(false);\n  const [showLimitModal, setShowLimitModal] = useState<boolean>(false);\n\n  const persistPlan = usePlansStore((state: PlansState) => state.addPlan);\n  const updatePlanStore = usePlansStore((state: PlansState) => state.updatePlan);\n  const plans = usePlansStore((state: PlansState) => state.plans);\n  const editingPlan = useMemo<Plan | null>(() => {\n    if (!editingPlanId) {\n      return null;\n    }\n\n    return plans.find((plan) => plan.id === editingPlanId) ?? null;\n  }, [plans, editingPlanId]);\n\n  const premadeWorkouts = useProgramsStore((state) => state.premadeWorkouts);\n  const premadeWorkout = useMemo(() => {\n    if (!targetPremadeWorkoutId) return null;\n    return premadeWorkouts.find(w => w.id === targetPremadeWorkoutId) ?? null;\n  }, [premadeWorkouts, targetPremadeWorkoutId]);\n\n  // Check if this premade workout has already been added to My Workouts\n  const isAlreadyAdded = useMemo(() => {\n    if (!premadeWorkout) return false;\n    const addedWorkoutNames = new Set(\n      plans\n        .filter(plan => plan.source === 'premade' || plan.source === 'library' || plan.source === 'recommended')\n        .map(plan => plan.name.trim().toLowerCase())\n    );\n    return addedWorkoutNames.has(premadeWorkout.name.trim().toLowerCase());\n  }, [premadeWorkout, plans]);\n  const selectedIds = selectedExercises.map((exercise) => exercise.id);\n  const suggestedExercises = useSemanticExerciseSearch(searchTerm, exercises, {\n    excludeIds: selectedIds,\n    limit: 6,\n  });\n\n  const isEditing = Boolean(editingPlanId);\n  const isPremadeReview = Boolean(targetPremadeWorkoutId);\n\n  const nameFieldLabel = 'Name';\n  const namePlaceholder = 'e.g. Push Day';\n  const selectedListTitle = 'Plan exercises';\n  const selectedListSubtitle = 'Tap to remove. Use arrows to reorder.';\n\n  let saveCtaLabel = 'Save Workout';\n  let headerTitle = 'Create Workout';\n  let headerSubtitle = 'Build your workout template';\n\n  if (isEditing) {\n    saveCtaLabel = 'Update Workout';\n    headerTitle = 'Edit Workout';\n    headerSubtitle = 'Update your workout template';\n  } else if (isPremadeReview) {\n    saveCtaLabel = 'Add Workout';\n    headerTitle = 'Review Workout';\n    headerSubtitle = 'Review and customize this workout template';\n  }\n\n  const animatedContainerStyle = useAnimatedStyle(() => ({\n    transform: [{ translateY: containerTranslateY.value }],\n  }));\n\n  useEffect(() => {\n    containerTranslateY.value = withTiming(0, timingSlow);\n  }, [containerTranslateY]);\n\n  useEffect(() => {\n    if (hasInitializedFromPlan.current) {\n      return;\n    }\n\n    if (isEditing && editingPlan) {\n      setPlanName(editingPlan.name);\n      setSelectedExercises(editingPlan.exercises);\n      setSearchTerm('');\n      hasInitializedFromPlan.current = true;\n    } else if (premadeWorkout) {\n      // If this premade workout has already been added, redirect back\n      if (isAlreadyAdded) {\n        router.back();\n        return;\n      }\n\n      setPlanName(premadeWorkout.name);\n\n      // Map premade exercises (which might just have IDs) to full Exercise objects\n      const mappedExercises = premadeWorkout.exercises.map(ex => {\n        const fullExercise = exercises.find(e => e.id === ex.id);\n        return fullExercise ? { ...fullExercise } : null;\n      }).filter((ex): ex is ExerciseCatalogItem => ex !== null);\n\n      setSelectedExercises(mappedExercises);\n      setSearchTerm('');\n      hasInitializedFromPlan.current = true;\n    }\n  }, [editingPlan, isEditing, premadeWorkout, isAlreadyAdded, router]);\n\n  useEffect(() => {\n    const trimmedName = planName.trim();\n\n    if (!trimmedName) {\n      setIsNameDuplicate(false);\n      return;\n    }\n\n    // Check if name is duplicate (excluding current plan if editing)\n    const isDuplicate = plans.some((plan) => {\n      if (isEditing && plan.id === editingPlanId) {\n        return false;\n      }\n      return plan.name.toLowerCase() === trimmedName.toLowerCase();\n    });\n\n    setIsNameDuplicate(isDuplicate);\n  }, [planName, plans, isEditing, editingPlanId]);\n\n  const handleAddExercise = useCallback((exercise: Exercise) => {\n    setSelectedExercises((prev) => {\n      const exists = prev.some((item) => item.id === exercise.id);\n\n      if (exists) {\n        return prev;\n      }\n\n      return [...prev, exercise];\n    });\n  }, []);\n\n  const [exerciseToDelete, setExerciseToDelete] = useState<string | null>(null);\n\n  const initiateRemoveExercise = useCallback((exerciseId: string) => {\n    console.log('[create-plan] initiateRemoveExercise called for:', exerciseId);\n    triggerHaptic('warning');\n    setExerciseToDelete(exerciseId);\n  }, []);\n\n  const confirmRemoveExercise = useCallback(() => {\n    console.log('[create-plan] confirmRemoveExercise called. exerciseToDelete:', exerciseToDelete);\n    if (exerciseToDelete) {\n      console.log('[create-plan] Removing exercise with ID:', exerciseToDelete);\n      setSelectedExercises((prev) => {\n        const next = prev.filter((exercise) => exercise.id !== exerciseToDelete);\n        console.log('[create-plan] New exercises length:', next.length);\n        return next;\n      });\n      setExerciseToDelete(null);\n    }\n  }, [exerciseToDelete]);\n\n  const handleReorderList = useCallback((newExercises: Exercise[]) => {\n    setSelectedExercises(newExercises);\n  }, []);\n\n  const handleCardLayout = useCallback((positionY: number) => {\n    cardOffset.current = positionY;\n  }, []);\n\n  const handleFieldLayout = useCallback((field: PlanQuickBuilderField, positionY: number) => {\n    fieldPositions.current[field] = positionY;\n  }, []);\n\n  const handleFieldFocus = useCallback((field: PlanQuickBuilderField) => {\n    const scrollView = scrollRef.current;\n    const fieldOffset = cardOffset.current + fieldPositions.current[field];\n    const desiredOffset = Math.max(fieldOffset - spacing.xs, cardOffset.current);\n\n    setFocusedField(field);\n\n    if (scrollView) {\n      scrollView.scrollTo({ y: Math.max(desiredOffset, 0), animated: true });\n    }\n  }, []);\n\n  const handleFieldBlur = useCallback(() => {\n    setFocusedField(null);\n  }, []);\n\n  const editingPlanCreatedAt = editingPlan?.createdAt ?? null;\n\n  const submitPlan = useCallback(async (): Promise<SubmitPlanResult> => {\n    const trimmedName = planName.trim();\n\n    if (!trimmedName) {\n      return 'missing-name';\n    }\n\n    if (selectedExercises.length === 0) {\n      return 'no-exercises';\n    }\n\n    const isEditingPlan = Boolean(editingPlanId);\n    const createdAtTimestamp = isEditingPlan && editingPlanCreatedAt\n      ? editingPlanCreatedAt\n      : Date.now();\n\n    try {\n      console.log('[create-plan] Submitting plan', { name: trimmedName, exerciseCount: selectedExercises.length });\n\n      if (isEditingPlan) {\n        // Update existing plan - the store handles Supabase sync\n        await updatePlanStore({\n          id: editingPlanId as string,\n          name: trimmedName,\n          exercises: selectedExercises,\n          createdAt: createdAtTimestamp,\n        });\n      } else {\n        // Create new plan - the store handles Supabase sync\n        await persistPlan({\n          name: trimmedName,\n          exercises: selectedExercises,\n          createdAt: createdAtTimestamp,\n          source: isPremadeReview ? 'premade' : 'custom',\n        });\n      }\n\n      await triggerHaptic('success');\n      return 'success';\n    } catch (error: any) {\n      if (error?.message === 'FREE_LIMIT_REACHED') {\n        setShowLimitModal(true);\n        return 'error';\n      }\n      console.error('[create-plan] Failed to persist plan', error);\n      return 'error';\n    }\n  }, [editingPlanCreatedAt, editingPlanId, persistPlan, planName, selectedExercises, updatePlanStore]);\n\n  const handleSavePlan = useCallback(async () => {\n    const trimmedName = planName.trim();\n\n    if (trimmedName.length === 0 || selectedExercises.length === 0) {\n      return;\n    }\n\n    setIsSaving(true);\n\n    try {\n      const result = await submitPlan();\n\n      if (result === 'success') {\n        if (!isEditing) {\n          setPlanName('');\n          setSearchTerm('');\n          setSelectedExercises([]);\n        }\n        router.back();\n      }\n    } finally {\n      setIsSaving(false);\n    }\n  }, [isEditing, planName, router, selectedExercises, submitPlan]);\n\n  const handleBackPress = useCallback(() => {\n    triggerHaptic('selection');\n\n    containerTranslateY.value = withTiming(\n      SCREEN_HEIGHT,\n      timingSlow,\n      (finished) => {\n        if (finished) {\n          runOnJS(router.back)();\n        }\n      }\n    );\n  }, [containerTranslateY, router]);\n\n  // Handle Android hardware back button\n  useEffect(() => {\n    const backAction = () => {\n      handleBackPress();\n      return true;\n    };\n\n    const backHandler = BackHandler.addEventListener('hardwareBackPress', backAction);\n    return () => backHandler.remove();\n  }, [handleBackPress]);\n\n  return (\n    <>\n      <PremiumLimitModal\n        visible={showLimitModal}\n        onClose={() => setShowLimitModal(false)}\n        limitType=\"workout\"\n      />\n      <Animated.View style={[styles.container, { paddingTop: spacing.lg + insets.top, paddingBottom: insets.bottom + sizing.tabBarHeight }, animatedContainerStyle]}>\n        <KeyboardAvoidingView\n          style={styles.keyboardAvoider}\n          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}\n          keyboardVerticalOffset={spacing['2xl']}\n        >\n          <ScrollView\n            ref={scrollRef}\n            contentContainerStyle={styles.scrollContent}\n            showsVerticalScrollIndicator={false}\n            keyboardShouldPersistTaps=\"handled\"\n            keyboardDismissMode=\"on-drag\"\n          >\n            <View style={styles.topSection}>\n              <View style={styles.headerContent}>\n                <Text variant=\"heading1\" color=\"primary\" style={styles.headerTitle} fadeIn>\n                  {headerTitle}\n                </Text>\n                <Text variant=\"body\" color=\"secondary\" style={styles.headerSubtitle} fadeIn>\n                  {headerSubtitle}\n                </Text>\n              </View>\n\n              <Pressable\n                accessibilityRole=\"button\"\n                accessibilityLabel=\"Go Back\"\n                style={styles.backButtonContainer}\n                onPress={handleBackPress}\n              >\n                <IconSymbol name=\"arrow-back\" size={sizing.iconMD} color={colors.text.primary} />\n              </Pressable>\n            </View>\n\n            {isEditing && !editingPlan ? (\n              <SurfaceCard tone=\"neutral\" padding=\"xl\" showAccentStripe={false} style={styles.missingPlanCard}>\n                <Text variant=\"bodySemibold\" color=\"primary\">\n                  Plan unavailable\n                </Text>\n                <Text variant=\"body\" color=\"secondary\">\n                  We couldnt find the plan youre trying to edit. Please go back and select another plan.\n                </Text>\n                <Button label=\"Go Back\" variant=\"secondary\" onPress={router.back} />\n              </SurfaceCard>\n            ) : isPremadeReview && isAlreadyAdded ? (\n              <SurfaceCard tone=\"neutral\" padding=\"xl\" showAccentStripe={false} style={styles.missingPlanCard}>\n                <Text variant=\"bodySemibold\" color=\"primary\">\n                  Workout Already Added\n                </Text>\n                <Text variant=\"body\" color=\"secondary\">\n                  This workout has already been added to your My Workouts. You can find it in the Plans tab.\n                </Text>\n                <Button label=\"Go Back\" variant=\"secondary\" onPress={router.back} />\n              </SurfaceCard>\n            ) : null}\n\n            {!(isPremadeReview && isAlreadyAdded) && (\n              <View style={styles.builderContainer}>\n                <PlanQuickBuilderCard\n                  planName={planName}\n                  onPlanNameChange={setPlanName}\n                  searchTerm={searchTerm}\n                  onSearchTermChange={setSearchTerm}\n                  suggestions={suggestedExercises}\n                  onAddExercise={handleAddExercise}\n                  onCardLayout={handleCardLayout}\n                  onFieldLayout={handleFieldLayout}\n                  onFieldFocus={handleFieldFocus}\n                  onFieldBlur={handleFieldBlur}\n                  onFocusSearch={() => handleFieldFocus('search')}\n                  isFieldFocused={focusedField !== null}\n                  planNameLabel={nameFieldLabel}\n                  planNamePlaceholder={namePlaceholder}\n                  isNameDuplicate={isNameDuplicate}\n                />\n              </View>\n            )}\n\n            {!(isPremadeReview && isAlreadyAdded) && (\n              <PlanSelectedExerciseList\n                exercises={selectedExercises}\n                onRemoveExercise={initiateRemoveExercise}\n                onAddExercises={() => handleFieldFocus('search')}\n                onReorder={handleReorderList}\n                onReorderExercises={(fromIndex, toIndex) => {\n                  const newExercises = [...selectedExercises];\n                  const [moved] = newExercises.splice(fromIndex, 1);\n                  newExercises.splice(toIndex, 0, moved);\n                  handleReorderList(newExercises);\n                }}\n                onSave={handleSavePlan}\n                isSaveDisabled={planName.trim().length === 0 || selectedExercises.length === 0 || isSaving || isNameDuplicate}\n                isSaving={isSaving}\n                title={selectedListTitle}\n                subtitle={selectedListSubtitle}\n                saveLabel={saveCtaLabel}\n              />\n            )}\n          </ScrollView>\n        </KeyboardAvoidingView>\n      </Animated.View>\n      <DeleteConfirmationModal\n        visible={!!exerciseToDelete}\n        onClose={() => setExerciseToDelete(null)}\n        onConfirm={confirmRemoveExercise}\n        title=\"Remove Exercise?\"\n        message=\"Are you sure you want to remove this exercise from the workout?\"\n        confirmLabel=\"Remove\"\n        cancelLabel=\"Keep\"\n      />\n    </>\n  );\n};\n\nexport default CreatePlanScreen;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\app\\hercules-ai.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ChatUsageBanner' is defined but never used.","line":36,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":36,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isDarkMode' is assigned a value but never used.","line":148,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":148,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'usage' is assigned a value but never used.","line":174,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":174,"endColumn":15},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'insets.bottom'. Either include it or remove the dependency array.","line":265,"column":6,"nodeType":"ArrayExpression","endLine":265,"endColumn":22,"suggestions":[{"desc":"Update the dependencies array to be: [insets.bottom, keyboardHeight]","fix":{"range":[9997,10013],"text":"[insets.bottom, keyboardHeight]"}}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'messageListAnimatedStyle' is assigned a value but never used.","line":271,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":271,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Hercules AI Chat Screen\r\n * Full-screen AI chat interface with premium gating and action handling\r\n */\r\n\r\nimport React, { useState, useRef, useCallback, useEffect } from 'react';\r\nimport {\r\n  View,\r\n  StyleSheet,\r\n  TextInput,\r\n  FlatList,\r\n  Platform,\r\n  Pressable,\r\n  ActivityIndicator,\r\n  Keyboard,\r\n  NativeSyntheticEvent,\r\n  NativeScrollEvent,\r\n} from 'react-native';\r\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\r\nimport { router } from 'expo-router';\r\nimport { LinearGradient } from 'expo-linear-gradient';\r\nimport Animated, {\r\n  FadeIn,\r\n  useSharedValue,\r\n  useAnimatedStyle,\r\n  withTiming,\r\n  Easing,\r\n} from 'react-native-reanimated';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { Button } from '@/components/atoms/Button';\r\nimport { SurfaceCard } from '@/components/atoms/SurfaceCard';\r\nimport { PremiumLock } from '@/components/atoms/PremiumLock';\r\nimport { ChatMessageBubble } from '@/components/molecules/ChatMessageBubble';\r\nimport { ActionApprovalCard } from '@/components/molecules/ActionApprovalCard';\r\nimport { ChatUsageBanner } from '@/components/molecules/ChatUsageBanner';\r\nimport { TypingIndicator } from '@/components/molecules/TypingIndicator';\r\nimport { ChatHistoryModal } from '@/components/molecules/ChatHistoryModal';\r\nimport { IconSymbol } from '@/components/ui/icon-symbol';\r\nimport { useTheme } from '@/hooks/useTheme';\r\nimport { usePremiumStatus } from '@/hooks/usePremiumStatus';\r\nimport { spacing, radius, typography, shadows } from '@/constants/theme';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\nimport {\r\n  sendChatMessage,\r\n  submitActionDecision,\r\n  fetchUsageStats,\r\n  fetchChatMessages,\r\n} from '@/services/herculesAIService';\r\nimport { sanitizeMessageForDisplay } from '@/utils/messageSanitizer';\r\nimport { usePlansStore } from '@/store/plansStore';\r\nimport { useProgramsStore } from '@/store/programsStore';\r\nimport { useSchedulesStore } from '@/store/schedulesStore';\r\nimport { useWorkoutSessionsStore } from '@/store/workoutSessionsStore';\r\nimport type { ChatMessage, ActionProposal, UsageInfo } from '@/types/herculesAI';\r\n\r\n/**\r\n * CRITICAL: Detects if a message looks like an action proposal that should have buttons.\r\n * This is a frontend safety net for when the AI forgets to include the action payload.\r\n */\r\nconst looksLikeActionProposal = (content: string): boolean => {\r\n  const lowerContent = content.toLowerCase();\r\n  \r\n  // Check for confirmation questions that indicate a proposal\r\n  const confirmationPatterns = [\r\n    'would you like me to create',\r\n    'would you like me to set up',\r\n    'would you like me to schedule',\r\n    'would you like me to log',\r\n    'would you like me to add',\r\n    'shall i create',\r\n    'shall i set up',\r\n    'want me to create',\r\n    'ready to create',\r\n    'create this for you',\r\n    'set this up for you',\r\n  ];\r\n  \r\n  return confirmationPatterns.some(pattern => lowerContent.includes(pattern));\r\n};\r\n\r\n/**\r\n * MissingActionFallback\r\n * Shows when message looks like a proposal but no action payload was included.\r\n * This prevents the infinite loop where user types \"yes\" and AI repeats.\r\n */\r\nconst MissingActionFallback: React.FC<{\r\n  onRetry: () => void;\r\n  onDismiss: () => void;\r\n  isLoading: boolean;\r\n  theme: any;\r\n}> = ({ onRetry, onDismiss, isLoading, theme }) => {\r\n  return (\r\n    <View style={{\r\n      flexDirection: 'row',\r\n      alignItems: 'center',\r\n      justifyContent: 'space-between',\r\n      paddingVertical: spacing.sm,\r\n      paddingHorizontal: spacing.md,\r\n      marginHorizontal: spacing.md,\r\n      marginTop: spacing.sm,\r\n      borderRadius: radius.lg,\r\n      borderWidth: 1,\r\n      borderColor: theme.border.light,\r\n      backgroundColor: theme.surface.elevated,\r\n    }}>\r\n      <Text variant=\"caption\" color=\"secondary\" style={{ flex: 1 }}>\r\n        Ready to create?\r\n      </Text>\r\n      <View style={{ flexDirection: 'row', gap: spacing.sm }}>\r\n        <Pressable\r\n          onPress={onDismiss}\r\n          disabled={isLoading}\r\n          style={[{\r\n            paddingVertical: spacing.xs,\r\n            paddingHorizontal: spacing.md,\r\n            borderRadius: radius.md,\r\n            borderWidth: 1,\r\n            borderColor: theme.border.medium,\r\n            opacity: isLoading ? 0.5 : 1,\r\n          }]}\r\n        >\r\n          <Text variant=\"bodySemibold\" color=\"secondary\">\r\n            No thanks\r\n          </Text>\r\n        </Pressable>\r\n        <Pressable\r\n          onPress={onRetry}\r\n          disabled={isLoading}\r\n          style={[{\r\n            paddingVertical: spacing.xs,\r\n            paddingHorizontal: spacing.md,\r\n            borderRadius: radius.md,\r\n            backgroundColor: theme.accent.primary,\r\n            opacity: isLoading ? 0.5 : 1,\r\n          }]}\r\n        >\r\n          <Text variant=\"bodySemibold\" color=\"onAccent\">\r\n            Yes, create it\r\n          </Text>\r\n        </Pressable>\r\n      </View>\r\n    </View>\r\n  );\r\n};\r\n\r\nconst HerculesAIScreen: React.FC = () => {\r\n  const { theme, isDarkMode } = useTheme();\r\n  const { isPremium, isLoading: isPremiumLoading } = usePremiumStatus();\r\n  const insets = useSafeAreaInsets();\r\n  const flatListRef = useRef<FlatList>(null);\r\n  const inputRef = useRef<TextInput>(null);\r\n\r\n  // Track if user has manually scrolled - only reset when user sends a new message\r\n  const userHasScrolled = useRef(false);\r\n  \r\n  // CRITICAL: Counter to trigger scroll to end when user sends a message\r\n  // Incrementing this triggers a useEffect that scrolls after render\r\n  const [scrollTrigger, setScrollTrigger] = useState(0);\r\n  \r\n  // Track scroll dimensions for smart scrolling\r\n  const scrollMetrics = useRef<{\r\n    contentHeight: number;\r\n    layoutHeight: number;\r\n    currentOffset: number;\r\n  }>({ contentHeight: 0, layoutHeight: 0, currentOffset: 0 });\r\n\r\n  const [messages, setMessages] = useState<ChatMessage[]>([]);\r\n  const [inputText, setInputText] = useState('');\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const [sessionId, setSessionId] = useState<string | null>(null);\r\n  const [pendingAction, setPendingAction] = useState<ActionProposal | null>(null);\r\n  const [actionLoading, setActionLoading] = useState(false);\r\n  const [usage, setUsage] = useState<UsageInfo | null>(null);\r\n  const [disclaimerAccepted, setDisclaimerAccepted] = useState(false);\r\n  const [historyModalVisible, setHistoryModalVisible] = useState(false);\r\n  const [newMessageIds, setNewMessageIds] = useState<Set<string>>(new Set());\r\n  const [animationCompleteIds, setAnimationCompleteIds] = useState<Set<string>>(new Set());\r\n\r\n  // CRITICAL: Trigger scroll to end when user sends a message\r\n  // This function increments the trigger which fires a useEffect after React's render cycle\r\n  const scrollToUserMessageTop = useCallback(() => {\r\n    setScrollTrigger((prev) => prev + 1);\r\n  }, []);\r\n  \r\n  // CRITICAL: useEffect that fires AFTER React has processed the state update\r\n  // This ensures the FlatList has the new message before we scroll\r\n  useEffect(() => {\r\n    if (scrollTrigger === 0) return; // Skip initial render\r\n    \r\n    // Use multiple timeouts to ensure scroll happens after render is complete\r\n    // First timeout: Allow React to commit the update\r\n    const timer1 = setTimeout(() => {\r\n      flatListRef.current?.scrollToEnd({ animated: false });\r\n    }, 50);\r\n    \r\n    // Second timeout: Ensure scroll sticks after any layout adjustments\r\n    const timer2 = setTimeout(() => {\r\n      flatListRef.current?.scrollToEnd({ animated: false });\r\n    }, 150);\r\n    \r\n    // Third timeout: Final scroll to guarantee position\r\n    const timer3 = setTimeout(() => {\r\n      flatListRef.current?.scrollToEnd({ animated: false });\r\n    }, 300);\r\n    \r\n    return () => {\r\n      clearTimeout(timer1);\r\n      clearTimeout(timer2);\r\n      clearTimeout(timer3);\r\n    };\r\n  }, [scrollTrigger]);\r\n  \r\n  // Called when content size changes - update metrics\r\n  const handleContentSizeChange = useCallback((width: number, height: number) => {\r\n    scrollMetrics.current.contentHeight = height;\r\n  }, []);\r\n\r\n  // Smooth half-page scroll: only scroll when content is within threshold of bottom\r\n  // Scrolls by half the visible height with smooth animation\r\n  const scrollChunkedIfNeeded = useCallback(() => {\r\n    if (userHasScrolled.current) return;\r\n    \r\n    const { contentHeight, layoutHeight, currentOffset } = scrollMetrics.current;\r\n    const visibleBottom = currentOffset + layoutHeight;\r\n    const distanceFromBottom = contentHeight - visibleBottom;\r\n    \r\n    // Only scroll if content is within 80px of being hidden (positive = content below visible area)\r\n    if (distanceFromBottom < 80) return;\r\n    \r\n    // Scroll by half the visible page height for smooth, substantial movement\r\n    const scrollAmount = layoutHeight / 2;\r\n    const newOffset = currentOffset + scrollAmount;\r\n    \r\n    flatListRef.current?.scrollToOffset({ offset: newOffset, animated: true });\r\n  }, []);\r\n\r\n  // Keyboard handling with Reanimated\r\n  const keyboardHeight = useSharedValue(0);\r\n\r\n  useEffect(() => {\r\n    const showEvent = Platform.OS === 'ios' ? 'keyboardWillShow' : 'keyboardDidShow';\r\n    const hideEvent = Platform.OS === 'ios' ? 'keyboardWillHide' : 'keyboardDidHide';\r\n\r\n    const showSubscription = Keyboard.addListener(showEvent, (e) => {\r\n      // Add extra padding between input and keyboard for visual buffer\r\n      keyboardHeight.value = withTiming(e.endCoordinates.height - (insets.bottom || 0) + 60, {\r\n        duration: Platform.OS === 'ios' ? 250 : 150,\r\n        easing: Easing.out(Easing.cubic),\r\n      });\r\n      // Don't auto-scroll or reset here - let user control scroll behavior\r\n    });\r\n\r\n    const hideSubscription = Keyboard.addListener(hideEvent, () => {\r\n      keyboardHeight.value = withTiming(0, {\r\n        duration: Platform.OS === 'ios' ? 250 : 150,\r\n        easing: Easing.out(Easing.cubic),\r\n      });\r\n    });\r\n\r\n    return () => {\r\n      showSubscription.remove();\r\n      hideSubscription.remove();\r\n    };\r\n  }, [keyboardHeight]);\r\n\r\n  const inputContainerAnimatedStyle = useAnimatedStyle(() => ({\r\n    transform: [{ translateY: -keyboardHeight.value }],\r\n  }));\r\n\r\n  const messageListAnimatedStyle = useAnimatedStyle(() => ({\r\n    paddingBottom: keyboardHeight.value,\r\n  }));\r\n\r\n  useEffect(() => {\r\n    if (isPremium && disclaimerAccepted) {\r\n      loadUsage();\r\n    }\r\n  }, [isPremium, disclaimerAccepted]);\r\n\r\n  const loadUsage = async () => {\r\n    const { data } = await fetchUsageStats();\r\n    if (data) {\r\n      setUsage(data);\r\n    }\r\n  };\r\n\r\n  const handleSend = useCallback(async () => {\r\n    if (!inputText.trim() || isLoading) return;\r\n\r\n    // Reset scroll behavior when user sends a message - they want to see the response\r\n    userHasScrolled.current = false;\r\n\r\n    // CRITICAL: Clear any pending action when user types a new message\r\n    // This removes the action buttons since user chose to continue conversation instead\r\n    if (pendingAction) {\r\n      console.log('[HerculesAI] User typed instead of clicking action buttons - clearing pending action');\r\n      setPendingAction(null);\r\n      \r\n      // Also mark the action in messages as dismissed (not pending anymore)\r\n      setMessages((prev) =>\r\n        prev.map((msg) =>\r\n          msg.action?.status === 'pending'\r\n            ? { ...msg, action: { ...msg.action, status: 'dismissed' as const } }\r\n            : msg\r\n        )\r\n      );\r\n    }\r\n\r\n    const userMessage: ChatMessage = {\r\n      id: `user-${Date.now()}`,\r\n      role: 'user',\r\n      content: inputText.trim(),\r\n      createdAt: new Date().toISOString(),\r\n    };\r\n\r\n    setMessages((prev) => [...prev, userMessage]);\r\n    setInputText('');\r\n    setIsLoading(true);\r\n    triggerHaptic('light');\r\n\r\n    // CRITICAL: Scroll user's message to top of visible area\r\n    // This triggers a useEffect that scrolls AFTER the state update is processed\r\n    scrollToUserMessageTop();\r\n\r\n    const { data, error } = await sendChatMessage(userMessage.content, sessionId ?? undefined);\r\n\r\n    if (error) {\r\n      const errorMessage: ChatMessage = {\r\n        id: `error-${Date.now()}`,\r\n        role: 'assistant',\r\n        content: `Sorry, something went wrong: ${error.message}`,\r\n        createdAt: new Date().toISOString(),\r\n      };\r\n      setMessages((prev) => [...prev, errorMessage]);\r\n    } else if (data) {\r\n      // CRITICAL DEBUG: Log what the backend returned\r\n      console.log('[HerculesAI] Backend response:', {\r\n        sessionId: data.sessionId,\r\n        hasAction: !!data.action,\r\n        actionType: data.action?.actionType,\r\n        messageLength: data.message?.length,\r\n      });\r\n\r\n      if (!sessionId) {\r\n        setSessionId(data.sessionId);\r\n      }\r\n\r\n      const assistantMessage: ChatMessage = {\r\n        id: `assistant-${Date.now()}`,\r\n        role: 'assistant',\r\n        // CRITICAL: Sanitize message to ensure no JSON is ever shown to users\r\n        content: sanitizeMessageForDisplay(data.message),\r\n        createdAt: new Date().toISOString(),\r\n        action: data.action\r\n          ? { ...data.action, status: 'pending' as const }\r\n          : null,\r\n      };\r\n\r\n      setMessages((prev) => [...prev, assistantMessage]);\r\n      setNewMessageIds((prev) => new Set(prev).add(assistantMessage.id));\r\n\r\n      if (data.action) {\r\n        console.log('[HerculesAI] Setting pendingAction:', data.action.actionType);\r\n        setPendingAction({ ...data.action, status: 'pending' });\r\n      } else {\r\n        console.log('[HerculesAI] NO ACTION in response - buttons will NOT show');\r\n      }\r\n\r\n      loadUsage();\r\n    }\r\n\r\n    setIsLoading(false);\r\n    // Don't scroll here - typing animation will handle scrolling via scrollChunkedIfNeeded\r\n  }, [inputText, isLoading, sessionId, scrollToUserMessageTop, pendingAction]);\r\n\r\n  const handleActionDecision = useCallback(\r\n    async (decision: 'approve' | 'reject', actionFromCard?: ActionProposal | null) => {\r\n      // CRITICAL FIX: Use action passed from card if pendingAction is null\r\n      const actionToUse = actionFromCard || pendingAction;\r\n      \r\n      console.log('[HerculesAI] handleActionDecision called:', {\r\n        decision,\r\n        hasPendingAction: !!pendingAction,\r\n        hasActionFromCard: !!actionFromCard,\r\n        actionId: actionToUse?.id,\r\n        actionType: actionToUse?.actionType,\r\n      });\r\n      \r\n      if (!actionToUse) {\r\n        console.error('[HerculesAI] CRITICAL: No action available for decision!');\r\n        return;\r\n      }\r\n\r\n      setActionLoading(true);\r\n      triggerHaptic(decision === 'approve' ? 'success' : 'light');\r\n\r\n      // Mark the action in the message as no longer pending\r\n      setMessages((prev) =>\r\n        prev.map((msg) =>\r\n          msg.action?.id === actionToUse.id\r\n            ? { ...msg, action: { ...msg.action, status: decision === 'approve' ? 'approved' : 'rejected' } }\r\n            : msg\r\n        )\r\n      );\r\n\r\n      if (decision === 'reject') {\r\n        // Show feedback prompt for rejection\r\n        const feedbackMessage: ChatMessage = {\r\n          id: `feedback-prompt-${Date.now()}`,\r\n          role: 'assistant',\r\n          content: \"No problem! What would you like me to change? You can ask for different exercises, more or fewer sets, a different workout type, or anything else.\",\r\n          createdAt: new Date().toISOString(),\r\n        };\r\n        setMessages((prev) => [...prev, feedbackMessage]);\r\n        setNewMessageIds((prev) => new Set(prev).add(feedbackMessage.id));\r\n        setPendingAction(null);\r\n        setActionLoading(false);\r\n        // Don't scroll - typing animation will handle it\r\n        return;\r\n      }\r\n\r\n      console.log('[HerculesAI] Submitting action decision:', {\r\n        actionId: actionToUse.id,\r\n        actionType: actionToUse.actionType,\r\n        decision,\r\n      });\r\n\r\n      const { data, error } = await submitActionDecision(actionToUse.id, decision);\r\n\r\n      console.log('[HerculesAI] Action decision response:', {\r\n        hasData: !!data,\r\n        hasError: !!error,\r\n        status: data?.status,\r\n        summary: data?.summary,\r\n        errorMessage: error?.message,\r\n      });\r\n\r\n      if (data) {\r\n        const resultMessage: ChatMessage = {\r\n          id: `action-result-${Date.now()}`,\r\n          role: 'assistant',\r\n          // CRITICAL: Sanitize message to ensure no JSON is ever shown to users\r\n          content: sanitizeMessageForDisplay(data.summary),\r\n          createdAt: new Date().toISOString(),\r\n        };\r\n        setMessages((prev) => [...prev, resultMessage]);\r\n        setNewMessageIds((prev) => new Set(prev).add(resultMessage.id));\r\n\r\n        // Refresh relevant stores after successful action execution\r\n        if (decision === 'approve' && data.status === 'executed') {\r\n          const actionType = actionToUse.actionType;\r\n          console.log('[HerculesAI] Action executed successfully, refreshing stores for:', actionType);\r\n\r\n          try {\r\n            if (actionType === 'create_workout_template') {\r\n              await usePlansStore.getState().hydratePlans();\r\n              console.log('[HerculesAI] Workout templates refreshed');\r\n            } else if (actionType === 'create_program_plan') {\r\n              await useProgramsStore.getState().hydratePrograms();\r\n              await usePlansStore.getState().hydratePlans();\r\n              console.log('[HerculesAI] Programs and plans refreshed');\r\n            } else if (actionType === 'create_schedule') {\r\n              await useSchedulesStore.getState().hydrateSchedules();\r\n              console.log('[HerculesAI] Schedules refreshed');\r\n            } else if (\r\n              actionType === 'add_workout_session' ||\r\n              actionType === 'edit_workout_session' ||\r\n              actionType === 'delete_workout_session'\r\n            ) {\r\n              await useWorkoutSessionsStore.getState().hydrateWorkouts();\r\n              console.log('[HerculesAI] Workout sessions refreshed');\r\n            }\r\n          } catch (hydrateError) {\r\n            console.error('[HerculesAI] Store hydration failed:', hydrateError);\r\n          }\r\n        } else if (data.status !== 'executed') {\r\n          console.warn('[HerculesAI] Action was not executed, status:', data.status);\r\n        }\r\n      } else if (error) {\r\n        console.error('[HerculesAI] Action execution failed:', error);\r\n        const errorMessage: ChatMessage = {\r\n          id: `action-error-${Date.now()}`,\r\n          role: 'assistant',\r\n          content: `Action failed: ${error.message}`,\r\n          createdAt: new Date().toISOString(),\r\n        };\r\n        setMessages((prev) => [...prev, errorMessage]);\r\n        setNewMessageIds((prev) => new Set(prev).add(errorMessage.id));\r\n      }\r\n\r\n      setPendingAction(null);\r\n      setActionLoading(false);\r\n      // Don't scroll - typing animation will handle it\r\n    },\r\n    [pendingAction]\r\n  );\r\n\r\n  const handleBack = () => {\r\n    triggerHaptic('light');\r\n    router.back();\r\n  };\r\n\r\n  const handleAcceptDisclaimer = () => {\r\n    setDisclaimerAccepted(true);\r\n    triggerHaptic('light');\r\n  };\r\n\r\n  const handleUpgrade = () => {\r\n    triggerHaptic('light');\r\n    router.push('/premium');\r\n  };\r\n\r\n  const handleOpenHistory = () => {\r\n    triggerHaptic('light');\r\n    setHistoryModalVisible(true);\r\n  };\r\n\r\n  const handleSelectSession = async (selectedSessionId: string) => {\r\n    setSessionId(selectedSessionId);\r\n    setMessages([]);\r\n    setNewMessageIds(new Set());\r\n    setIsLoading(true);\r\n\r\n    const { data } = await fetchChatMessages(selectedSessionId);\r\n    if (data) {\r\n      const loadedMessages: ChatMessage[] = data.map((msg) => ({\r\n        id: msg.id,\r\n        role: msg.role,\r\n        content: msg.content,\r\n        createdAt: msg.createdAt,\r\n      }));\r\n      setMessages(loadedMessages);\r\n    }\r\n\r\n    setIsLoading(false);\r\n    loadUsage();\r\n  };\r\n\r\n  const handleNewChat = () => {\r\n    setSessionId(null);\r\n    setMessages([]);\r\n    setNewMessageIds(new Set());\r\n    setAnimationCompleteIds(new Set());\r\n    setPendingAction(null);\r\n  };\r\n\r\n  const handleAnimationComplete = useCallback((messageId: string) => {\r\n    setAnimationCompleteIds((prev) => new Set(prev).add(messageId));\r\n    // Don't scroll here - chunked scroll during typing handles positioning\r\n  }, []);\r\n\r\n  // Handler for dismissing the fallback without taking action\r\n  const handleFallbackDismiss = useCallback(() => {\r\n    // Add a message acknowledging the dismissal\r\n    const dismissMessage: ChatMessage = {\r\n      id: `assistant-${Date.now()}`,\r\n      role: 'assistant',\r\n      content: 'No problem! Let me know if you\\'d like to make any changes or try something different.',\r\n      createdAt: new Date().toISOString(),\r\n    };\r\n    setMessages((prev) => [...prev, dismissMessage]);\r\n    setNewMessageIds((prev) => new Set(prev).add(dismissMessage.id));\r\n    triggerHaptic('light');\r\n    // Don't scroll - typing animation will handle it\r\n  }, []);\r\n\r\n  // Handler for fallback retry - sends a confirmation message to regenerate with action\r\n  const handleFallbackRetry = useCallback(async () => {\r\n    if (isLoading) return;\r\n    \r\n    // Reset scroll behavior - user is taking action\r\n    userHasScrolled.current = false;\r\n    \r\n    // Send a clear confirmation that should trigger action generation\r\n    const confirmMessage: ChatMessage = {\r\n      id: `user-${Date.now()}`,\r\n      role: 'user',\r\n      content: 'Yes, please create that for me now.',\r\n      createdAt: new Date().toISOString(),\r\n    };\r\n    \r\n    setMessages((prev) => [...prev, confirmMessage]);\r\n    setIsLoading(true);\r\n    triggerHaptic('light');\r\n    \r\n    // Scroll user's message to top\r\n    scrollToUserMessageTop();\r\n    \r\n    const { data, error } = await sendChatMessage(confirmMessage.content, sessionId ?? undefined);\r\n    \r\n    if (error) {\r\n      const errorMessage: ChatMessage = {\r\n        id: `error-${Date.now()}`,\r\n        role: 'assistant',\r\n        content: `Sorry, something went wrong: ${error.message}`,\r\n        createdAt: new Date().toISOString(),\r\n      };\r\n      setMessages((prev) => [...prev, errorMessage]);\r\n    } else if (data) {\r\n      console.log('[HerculesAI] Fallback retry response:', {\r\n        hasAction: !!data.action,\r\n        actionType: data.action?.actionType,\r\n      });\r\n      \r\n      if (!sessionId) {\r\n        setSessionId(data.sessionId);\r\n      }\r\n      \r\n      const assistantMessage: ChatMessage = {\r\n        id: `assistant-${Date.now()}`,\r\n        role: 'assistant',\r\n        content: sanitizeMessageForDisplay(data.message),\r\n        createdAt: new Date().toISOString(),\r\n        action: data.action\r\n          ? { ...data.action, status: 'pending' as const }\r\n          : null,\r\n      };\r\n      \r\n      setMessages((prev) => [...prev, assistantMessage]);\r\n      setNewMessageIds((prev) => new Set(prev).add(assistantMessage.id));\r\n      \r\n      if (data.action) {\r\n        console.log('[HerculesAI] Fallback retry succeeded - action received:', data.action.actionType);\r\n        setPendingAction({ ...data.action, status: 'pending' });\r\n      } else {\r\n        console.warn('[HerculesAI] Fallback retry failed - still no action in response');\r\n      }\r\n      \r\n      loadUsage();\r\n    }\r\n    \r\n    setIsLoading(false);\r\n    // Don't scroll here - typing animation will handle scrolling\r\n  }, [isLoading, sessionId, scrollToUserMessageTop]);\r\n\r\n  const renderMessage = ({ item, index }: { item: ChatMessage; index: number }) => {\r\n    const isAnimationComplete = animationCompleteIds.has(item.id) || !newMessageIds.has(item.id);\r\n    \r\n    // FIXED: Only show action card AFTER animation completes for smoother UX\r\n    const hasAction = item.action && item.action.status === 'pending';\r\n    const showActionCard = hasAction && isAnimationComplete;\r\n    \r\n    // CRITICAL: Detect if this message looks like a proposal but has no action\r\n    // Only show fallback after animation completes\r\n    const isLastAssistantMessage = item.role === 'assistant' && \r\n      messages.filter(m => m.role === 'assistant').slice(-1)[0]?.id === item.id;\r\n    const looksLikeProposal = item.role === 'assistant' && looksLikeActionProposal(item.content);\r\n    const showMissingActionFallback = isAnimationComplete && isLastAssistantMessage && looksLikeProposal && !hasAction && !pendingAction && !isLoading;\r\n\r\n    // Debug logging to track action detection\r\n    if (item.role === 'assistant') {\r\n      console.log('[HerculesAI] Rendering message:', {\r\n        hasAction: !!item.action,\r\n        actionStatus: item.action?.status,\r\n        isAnimationComplete,\r\n        showActionCard,\r\n        showMissingActionFallback,\r\n      });\r\n    }\r\n\r\n    return (\r\n      <>\r\n        <ChatMessageBubble\r\n          content={item.content}\r\n          role={item.role}\r\n          index={index}\r\n          isNewMessage={newMessageIds.has(item.id)}\r\n          onAnimationComplete={() => handleAnimationComplete(item.id)}\r\n          onTypingProgress={scrollChunkedIfNeeded} // Chunked scroll when content nears bottom\r\n        />\r\n        {showActionCard && (\r\n          <View style={{ paddingHorizontal: spacing.md, marginTop: spacing.sm }}>\r\n            <ActionApprovalCard\r\n              action={item.action!}\r\n              onApprove={() => handleActionDecision('approve', item.action)}\r\n              onReject={() => handleActionDecision('reject', item.action)}\r\n              isLoading={actionLoading}\r\n            />\r\n          </View>\r\n        )}\r\n        {showMissingActionFallback && (\r\n          <MissingActionFallback\r\n            onRetry={handleFallbackRetry}\r\n            onDismiss={handleFallbackDismiss}\r\n            isLoading={isLoading}\r\n            theme={theme}\r\n          />\r\n        )}\r\n      </>\r\n    );\r\n  };\r\n\r\n  const gradientColors: [string, string] = [theme.primary.bg, theme.surface.card];\r\n\r\n  if (isPremiumLoading) {\r\n    return (\r\n      <View style={[styles.centered, { backgroundColor: theme.primary.bg }]}>\r\n        <ActivityIndicator size=\"large\" color={theme.accent.primary} />\r\n      </View>\r\n    );\r\n  }\r\n\r\n  if (!isPremium) {\r\n    return (\r\n      <LinearGradient colors={gradientColors} style={styles.gradient}>\r\n        <View style={[styles.container, { paddingTop: insets.top }]}>\r\n          <View style={styles.header}>\r\n            <Pressable onPress={handleBack} hitSlop={12}>\r\n              <IconSymbol name=\"arrow-back\" size={24} color={theme.text.primary} />\r\n            </Pressable>\r\n            <Text variant=\"heading3\" color=\"primary\" style={styles.headerTitle}>\r\n              Hercules AI\r\n            </Text>\r\n            <View style={{ width: 24 }} />\r\n          </View>\r\n          <View style={styles.premiumGate}>\r\n            <PremiumLock\r\n              isLocked={true}\r\n              featureName=\"Hercules AI\"\r\n              ctaText=\"Unlock with Premium\"\r\n              onUnlock={handleUpgrade}\r\n            >\r\n              <Text variant=\"body\" color=\"secondary\">\r\n                Get personalized workout advice, track your progress, and let AI help you reach your fitness goals.\r\n              </Text>\r\n            </PremiumLock>\r\n          </View>\r\n        </View>\r\n      </LinearGradient>\r\n    );\r\n  }\r\n\r\n  if (!disclaimerAccepted) {\r\n    return (\r\n      <LinearGradient colors={gradientColors} style={styles.gradient}>\r\n        <View style={[styles.container, { paddingTop: insets.top }]}>\r\n          <View>\r\n            <View style={styles.header}>\r\n              <Pressable onPress={handleBack} hitSlop={12}>\r\n                <IconSymbol name=\"arrow-back\" size={24} color={theme.text.primary} />\r\n              </Pressable>\r\n              <View style={styles.headerTitleContainer}>\r\n                <Text variant=\"heading3\" color=\"primary\" style={styles.headerTitle}>\r\n                  Hercules AI\r\n                </Text>\r\n              </View>\r\n              <View style={{ width: 24 }} />\r\n            </View>\r\n            <View style={[styles.headerBorder, { backgroundColor: theme.text.tertiary }]} />\r\n          </View>\r\n          <View style={styles.disclaimerContainer}>\r\n            <SurfaceCard tone=\"card\" padding=\"xl\">\r\n              <Text variant=\"heading3\" color=\"primary\" style={styles.disclaimerTitle}>\r\n                Before You Start\r\n              </Text>\r\n              <Text variant=\"body\" color=\"secondary\" style={styles.disclaimerText}>\r\n                Hercules AI is designed to help with your fitness journey by providing\r\n                personalized workout suggestions and tracking insights.\r\n              </Text>\r\n              <Text variant=\"body\" color=\"secondary\" style={styles.disclaimerText}>\r\n                Please note that AI suggestions are not a substitute for professional\r\n                medical or fitness advice. Always consult with a qualified professional\r\n                before making significant changes to your exercise routine.\r\n              </Text>\r\n              <Text variant=\"caption\" color=\"tertiary\" style={styles.disclaimerNote}>\r\n                By continuing, you acknowledge that you understand these limitations.\r\n              </Text>\r\n              <Button\r\n                label=\"I Understand\"\r\n                variant=\"primary\"\r\n                size=\"lg\"\r\n                onPress={handleAcceptDisclaimer}\r\n                style={styles.disclaimerButton}\r\n              />\r\n            </SurfaceCard>\r\n          </View>\r\n        </View>\r\n      </LinearGradient>\r\n    );\r\n  }\r\n\r\n\r\n  // Calculate input area height for FlatList bottom padding\r\n  // Add buffer so content appears higher on screen, not hidden behind input\r\n  const inputAreaHeight = 52 + spacing.sm + (insets.bottom || spacing.xs) + spacing.sm + spacing.xl + 100;\r\n\r\n  return (\r\n    <LinearGradient colors={gradientColors} style={styles.gradient}>\r\n      <View style={[styles.container, { paddingTop: insets.top }]}>\r\n        <View>\r\n          <View style={styles.header}>\r\n            <Pressable onPress={handleBack} hitSlop={12}>\r\n              <IconSymbol name=\"arrow-back\" size={24} color={theme.text.primary} />\r\n            </Pressable>\r\n            <View style={styles.headerTitleContainer}>\r\n              <Text variant=\"heading3\" color=\"primary\" style={styles.headerTitle}>\r\n                Hercules AI\r\n              </Text>\r\n            </View>\r\n            <Pressable\r\n              onPress={handleOpenHistory}\r\n              hitSlop={12}\r\n            >\r\n              <IconSymbol name=\"menu\" size={24} color={theme.text.primary} />\r\n            </Pressable>\r\n          </View>\r\n          <View style={[styles.headerBorder, { backgroundColor: theme.text.tertiary }]} />\r\n        </View>\r\n\r\n        <Animated.FlatList\r\n          ref={flatListRef}\r\n          data={messages}\r\n          renderItem={renderMessage}\r\n          keyExtractor={(item) => item.id}\r\n          style={styles.messageListContainer}\r\n          contentContainerStyle={[styles.messageList, { paddingBottom: inputAreaHeight }]}\r\n          showsVerticalScrollIndicator={false}\r\n          keyboardShouldPersistTaps=\"handled\"\r\n          // Detect when user manually scrolls\r\n          onScrollBeginDrag={() => {\r\n            userHasScrolled.current = true;\r\n          }}\r\n          // Track scroll position for chunked scrolling\r\n          onScroll={(event: NativeSyntheticEvent<NativeScrollEvent>) => {\r\n            scrollMetrics.current.currentOffset = event.nativeEvent.contentOffset.y;\r\n          }}\r\n          scrollEventThrottle={16}\r\n          // Track content size changes and handle pending scroll-to-top\r\n          onContentSizeChange={handleContentSizeChange}\r\n          onLayout={(event) => {\r\n            scrollMetrics.current.layoutHeight = event.nativeEvent.layout.height;\r\n          }}\r\n          ListFooterComponent={<TypingIndicator isVisible={isLoading} />}\r\n          ListEmptyComponent={\r\n            <Animated.View entering={FadeIn.duration(500)} style={styles.emptyState}>\r\n              <Text variant=\"heading2\" color=\"primary\" style={styles.emptyTitle}>\r\n                Hey there! \r\n              </Text>\r\n              <Text variant=\"body\" color=\"secondary\" style={styles.emptyText}>\r\n                I&apos;m Hercules, your AI fitness assistant. Ask me anything about\r\n                workouts, form, nutrition, or let me help you plan your next session.\r\n              </Text>\r\n            </Animated.View>\r\n          }\r\n        />\r\n\r\n        <Animated.View\r\n          style={[\r\n            styles.inputContainerWrapper,\r\n            inputContainerAnimatedStyle,\r\n          ]}\r\n        >\r\n          <View style={[styles.headerBorder, { backgroundColor: theme.text.tertiary }]} />\r\n          <View\r\n            style={[\r\n              styles.inputContainer,\r\n              {\r\n                paddingBottom: insets.bottom || spacing.xs,\r\n                backgroundColor: theme.primary.bg,\r\n              },\r\n            ]}\r\n          >\r\n            <View style={[styles.inputWrapper, { backgroundColor: theme.surface.card, borderWidth: 1.5, borderColor: theme.accent.primary, ...shadows.sm }]} >\r\n              <TextInput\r\n                ref={inputRef}\r\n                style={[styles.input, { color: theme.text.primary }]}\r\n                placeholder=\"Ask Hercules anything...\"\r\n                placeholderTextColor={theme.text.tertiary}\r\n                value={inputText}\r\n                onChangeText={setInputText}\r\n                onFocus={() => {\r\n                  // Don't auto-scroll or reset on focus - let user control scroll\r\n                }}\r\n                multiline\r\n                maxLength={1000}\r\n                editable={!isLoading}\r\n              />\r\n              <Pressable\r\n                onPress={handleSend}\r\n                disabled={!inputText.trim() || isLoading}\r\n                style={[\r\n                  styles.sendButton,\r\n                  {\r\n                    backgroundColor:\r\n                      inputText.trim() && !isLoading\r\n                        ? theme.accent.primary\r\n                        : theme.surface.card,\r\n                  },\r\n                ]}\r\n              >\r\n                {isLoading ? (\r\n                  <ActivityIndicator size=\"small\" color={theme.text.primary} />\r\n                ) : (\r\n                  <IconSymbol\r\n                    name=\"arrow-upward\"\r\n                    size={20}\r\n                    color={inputText.trim() ? '#FFFFFF' : theme.text.tertiary}\r\n                  />\r\n                )}\r\n              </Pressable>\r\n            </View>\r\n          </View>\r\n        </Animated.View>\r\n      </View>\r\n      <ChatHistoryModal\r\n        visible={historyModalVisible}\r\n        onClose={() => setHistoryModalVisible(false)}\r\n        onSelectSession={handleSelectSession}\r\n        onNewChat={handleNewChat}\r\n      />\r\n    </LinearGradient>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  gradient: {\r\n    flex: 1,\r\n  },\r\n  container: {\r\n    flex: 1,\r\n  },\r\n  centered: {\r\n    flex: 1,\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n  },\r\n  header: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'space-between',\r\n    paddingHorizontal: spacing.md,\r\n    paddingVertical: spacing.sm,\r\n    minHeight: 56,\r\n  },\r\n  headerBorder: {\r\n    height: 1,\r\n    width: '100%',\r\n  },\r\n  headerButton: {\r\n    width: 40,\r\n    height: 40,\r\n    borderRadius: 20,\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n  },\r\n  headerTitle: {\r\n    textAlign: 'center',\r\n  },\r\n  headerTitleContainer: {\r\n    flex: 1,\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n  },\r\n  premiumGate: {\r\n    flex: 1,\r\n    justifyContent: 'center',\r\n    paddingHorizontal: spacing.lg,\r\n  },\r\n  disclaimerContainer: {\r\n    flex: 1,\r\n    justifyContent: 'center',\r\n    paddingHorizontal: spacing.lg,\r\n  },\r\n  disclaimerTitle: {\r\n    marginBottom: spacing.md,\r\n  },\r\n  disclaimerText: {\r\n    marginBottom: spacing.md,\r\n    lineHeight: 22,\r\n  },\r\n  disclaimerNote: {\r\n    marginBottom: spacing.lg,\r\n  },\r\n  disclaimerButton: {\r\n    marginTop: spacing.sm,\r\n  },\r\n  messageListContainer: {\r\n    flex: 1,\r\n  },\r\n  messageList: {\r\n    paddingTop: spacing.md,\r\n  },\r\n  emptyState: {\r\n    alignItems: 'center',\r\n    paddingHorizontal: spacing.xl,\r\n    paddingTop: spacing['2xl'],\r\n  },\r\n  emptyTitle: {\r\n    marginBottom: spacing.sm,\r\n    textAlign: 'center',\r\n  },\r\n  emptyText: {\r\n    textAlign: 'center',\r\n    lineHeight: 24,\r\n    maxWidth: 280,\r\n  },\r\n  inputContainerWrapper: {\r\n    position: 'absolute',\r\n    left: 0,\r\n    right: 0,\r\n    bottom: 0,\r\n  },\r\n  inputContainer: {\r\n    paddingHorizontal: spacing.md,\r\n    paddingTop: spacing.md,\r\n  },\r\n  inputWrapper: {\r\n    flexDirection: 'row',\r\n    alignItems: 'flex-end',\r\n    borderRadius: radius.lg,\r\n    paddingLeft: spacing.md,\r\n    paddingRight: spacing.xs,\r\n    paddingVertical: spacing.xs,\r\n    minHeight: 52,\r\n  },\r\n  input: {\r\n    flex: 1,\r\n    fontSize: typography.body.fontSize,\r\n    maxHeight: 120,\r\n    paddingVertical: spacing.sm,\r\n  },\r\n  sendButton: {\r\n    width: 40,\r\n    height: 40,\r\n    borderRadius: 20,\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n    marginLeft: spacing.sm,\r\n  },\r\n});\r\n\r\nexport default HerculesAIScreen;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\app\\modals\\_layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\app\\modals\\profile.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SurfaceCard' is defined but never used.","line":14,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'shadows' is defined but never used.","line":22,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":42},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sizing' is defined but never used.","line":22,"column":44,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":50},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'supabaseClient' is defined but never used.","line":26,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":26,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getBodyMetricsSubtitle' is assigned a value but never used.","line":211,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":211,"endColumn":31}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Profile Modal\r\n * A modal screen for displaying user profile and account preferences\r\n */\r\n\r\nimport React, { useState, useEffect, useCallback } from 'react';\r\nimport { StyleSheet, View, Pressable, ScrollView, Alert, ActivityIndicator, Switch } from 'react-native';\r\nimport { SafeAreaView } from 'react-native-safe-area-context';\r\nimport { useRouter } from 'expo-router';\r\nimport Animated, { useSharedValue, withSpring } from 'react-native-reanimated';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { SurfaceCard } from '@/components/atoms/SurfaceCard';\r\nimport { IconSymbol } from '@/components/ui/icon-symbol';\r\nimport { NameEditModal } from '@/components/molecules/NameEditModal';\r\nimport { BodyMetricsModal } from '@/components/molecules/BodyMetricsModal';\r\nimport { UnitsModal } from '@/components/molecules/UnitsModal';\r\nimport { NotificationsModal } from '@/components/molecules/NotificationsModal';\r\nimport { SignOutConfirmationModal } from '@/components/molecules/SignOutConfirmationModal';\r\nimport { FeedbackModal } from '@/components/molecules/FeedbackModal';\r\nimport { colors, spacing, radius, shadows, sizing } from '@/constants/theme';\r\nimport { useTheme } from '@/hooks/useTheme';\r\nimport { usePremiumStatus } from '@/hooks/usePremiumStatus';\r\nimport { useAuth } from '@/providers/AuthProvider';\r\nimport { supabaseClient } from '@/lib/supabaseClient';\r\nimport { useUserProfileStore } from '@/store/userProfileStore';\r\nimport { useSettingsStore } from '@/store/settingsStore';\r\nimport { useNotificationStore } from '@/store/notificationStore';\r\nimport { useDevToolsStore } from '@/store/devToolsStore';\r\n\r\nconst ProfileModal: React.FC = () => {\r\n  const router = useRouter();\r\n  const { theme } = useTheme();\r\n  const { user, signOut } = useAuth();\r\n  const { profile, fetchProfile, updateProfile, updateBodyMetrics } = useUserProfileStore();\r\n  const [isSigningOut, setIsSigningOut] = useState(false);\r\n  const [isNameModalVisible, setIsNameModalVisible] = useState(false);\r\n  const [isBodyMetricsModalVisible, setIsBodyMetricsModalVisible] = useState(false);\r\n  const [isUnitsModalVisible, setIsUnitsModalVisible] = useState(false);\r\n  const [isNotificationsModalVisible, setIsNotificationsModalVisible] = useState(false);\r\n  const [isSignOutModalVisible, setIsSignOutModalVisible] = useState(false);\r\n  const [isFeedbackModalVisible, setIsFeedbackModalVisible] = useState(false);\r\n  const [isDeleteAccountModalVisible, setIsDeleteAccountModalVisible] = useState(false);\r\n  const [isDeletingAccount, setIsDeletingAccount] = useState(false);\r\n  const { weightUnit, distanceUnit, sizeUnit, formatWeight, hapticsEnabled, setHapticsEnabled } = useSettingsStore();\r\n  const { notificationsEnabled, configs } = useNotificationStore();\r\n  const { isPremium, isLoading: isPremiumLoading } = usePremiumStatus();\r\n  const { premiumOverride, setPremiumOverride } = useDevToolsStore();\r\n  const backScale = useSharedValue(1);\r\n\r\n  const handleBackPress = () => {\r\n    backScale.value = withSpring(0.9, { damping: 15, stiffness: 300 });\r\n    triggerHaptic('selection');\r\n    setTimeout(() => {\r\n      backScale.value = withSpring(1, { damping: 15, stiffness: 300 });\r\n      router.back();\r\n    }, 100);\r\n  };\r\n\r\n  const handlePreferencePress = (title: string) => {\r\n    triggerHaptic('selection');\r\n\r\n    if (title === 'Send Feedback') {\r\n      setIsFeedbackModalVisible(true);\r\n    } else {\r\n      // TODO: Handle other preference items when implemented\r\n    }\r\n  };\r\n\r\n  const handleSignOut = () => {\r\n    triggerHaptic('warning');\r\n    setIsSignOutModalVisible(true);\r\n  };\r\n\r\n  const handleSignOutConfirm = async () => {\r\n    setIsSigningOut(true);\r\n    try {\r\n      await signOut();\r\n      // Navigation will be handled automatically by the auth state change\r\n    } catch (error) {\r\n      console.error('Sign out error:', error);\r\n      Alert.alert('Error', 'Failed to sign out. Please try again.');\r\n      setIsSigningOut(false);\r\n    }\r\n  };\r\n\r\n  const handleCloseSignOutModal = () => {\r\n    if (!isSigningOut) {\r\n      setIsSignOutModalVisible(false);\r\n    }\r\n  };\r\n\r\n  const handleDeleteAccount = () => {\r\n    triggerHaptic('warning');\r\n    setIsDeleteAccountModalVisible(true);\r\n  };\r\n\r\n  const handleDeleteAccountConfirm = async () => {\r\n    setIsDeletingAccount(true);\r\n    try {\r\n      // TODO: Implement account deletion logic\r\n      // This should:\r\n      // 1. Delete user data from profiles table\r\n      // 2. Delete user data from workouts table\r\n      // 3. Delete user from auth\r\n      // 4. Sign out and redirect\r\n      \r\n      // For now, just show a placeholder\r\n      Alert.alert('Coming Soon', 'Account deletion will be implemented in a future update.');\r\n      setIsDeleteAccountModalVisible(false);\r\n    } catch (error) {\r\n      console.error('Delete account error:', error);\r\n      Alert.alert('Error', 'Failed to delete account. Please contact support.');\r\n    } finally {\r\n      setIsDeletingAccount(false);\r\n    }\r\n  };\r\n\r\n  const handleCloseDeleteAccountModal = () => {\r\n    if (!isDeletingAccount) {\r\n      setIsDeleteAccountModalVisible(false);\r\n    }\r\n  };\r\n\r\n  // Fetch user profile data from store (which syncs with profiles table)\r\n  useEffect(() => {\r\n    if (user?.id) {\r\n      fetchProfile(user.id);\r\n    }\r\n  }, [user?.id, fetchProfile]);\r\n\r\n  // Format the account creation date\r\n  const formatMemberSince = (createdAt: string | undefined) => {\r\n    if (!createdAt) return 'Member';\r\n\r\n    const date = new Date(createdAt);\r\n    const month = date.toLocaleDateString('en-US', { month: 'long' });\r\n    const year = date.getFullYear();\r\n    return `Member since ${month} ${year}`;\r\n  };\r\n\r\n  // Get user's display name\r\n  const getUserDisplayName = () => {\r\n    // 1. Prefer store state (centralized, real-time updates)\r\n    if (profile?.fullName) {\r\n      return profile.fullName;\r\n    }\r\n    if (profile?.firstName || profile?.lastName) {\r\n      return `${profile.firstName || ''} ${profile.lastName || ''}`.trim();\r\n    }\r\n\r\n    // 2. Fallback to auth metadata\r\n    const meta = user?.user_metadata;\r\n    if (meta?.full_name) return meta.full_name;\r\n    if (meta?.first_name || meta?.last_name) {\r\n      return `${meta.first_name || ''} ${meta.last_name || ''}`.trim();\r\n    }\r\n\r\n    // 3. Fallback to email-based name\r\n    if (!user?.email) return 'User';\r\n    const emailName = user.email.split('@')[0];\r\n    return emailName.charAt(0).toUpperCase() + emailName.slice(1);\r\n  };\r\n\r\n  const handleNameEdit = () => {\r\n    triggerHaptic('selection');\r\n    setIsNameModalVisible(true);\r\n  };\r\n\r\n  const handleCloseNameModal = useCallback(() => {\r\n    setIsNameModalVisible(false);\r\n  }, []);\r\n\r\n  // Get current first/last name for modal prepopulation\r\n  const getCurrentFirstName = () => {\r\n    // Use store as source of truth\r\n    return profile?.firstName || '';\r\n  };\r\n\r\n  const getCurrentLastName = () => {\r\n    // Use store as source of truth\r\n    return profile?.lastName || '';\r\n  };\r\n\r\n  const handleNameSave = (firstName: string, lastName: string) => {\r\n    // Update the centralized store for real-time updates across the app\r\n    updateProfile(firstName, lastName);\r\n  };\r\n\r\n  const getFormattedHeight = () => {\r\n    const hasHeightData =\r\n      typeof profile?.heightFeet === 'number' && typeof profile?.heightInches === 'number';\r\n\r\n    if (!hasHeightData) {\r\n      return null;\r\n    }\r\n\r\n    const feet = profile?.heightFeet ?? 0;\r\n    const inches = profile?.heightInches ?? 0;\r\n    const totalInches = feet * 12 + inches;\r\n\r\n    if (sizeUnit === 'cm') {\r\n      const heightCm = Math.round(totalInches * 2.54);\r\n      return `${heightCm} cm`;\r\n    }\r\n\r\n    return `${totalInches} in`;\r\n  };\r\n\r\n  const getBodyMetricsSubtitle = () => {\r\n    const heightLabel = getFormattedHeight();\r\n    const weightLabel = profile?.weightLbs ? formatWeight(profile.weightLbs) : null;\r\n\r\n    if (heightLabel && weightLabel) {\r\n      return `${heightLabel}  ${weightLabel}`;\r\n    }\r\n\r\n    if (heightLabel) {\r\n      return heightLabel;\r\n    }\r\n\r\n    if (weightLabel) {\r\n      return weightLabel;\r\n    }\r\n\r\n    return 'Set height and weight for accurate stats';\r\n  };\r\n\r\n  const handleBodyMetricsSave = (heightFeet: number, heightInches: number, weightLbs: number) => {\r\n    updateBodyMetrics(heightFeet, heightInches, weightLbs);\r\n    setIsBodyMetricsModalVisible(false);\r\n  };\r\n\r\n  return (\r\n    <SafeAreaView style={[styles.container, { backgroundColor: theme.primary.bg }]}>\r\n      <View style={[styles.headerContainer, { backgroundColor: theme.primary.bg }]}>\r\n        <View style={[styles.header, { backgroundColor: theme.primary.bg }]}>\r\n          <Animated.View style={{ transform: [{ scale: backScale.value }] }}>\r\n            <Pressable\r\n              style={styles.backButton}\r\n              onPress={handleBackPress}\r\n              accessibilityRole=\"button\"\r\n              accessibilityLabel=\"Back to Dashboard\"\r\n            >\r\n              <IconSymbol\r\n                name=\"arrow-back\"\r\n                color={theme.text.primary}\r\n                size={22}\r\n              />\r\n            </Pressable>\r\n          </Animated.View>\r\n          <Text variant=\"heading3\" color=\"primary\" style={{ fontWeight: '600' }}>\r\n            Settings\r\n          </Text>\r\n          <View style={styles.headerSpacer} />\r\n        </View>\r\n        <View style={[styles.headerDivider, { backgroundColor: theme.text.tertiary }]} />\r\n      </View>\r\n\r\n      <ScrollView\r\n        style={styles.content}\r\n        showsVerticalScrollIndicator={false}\r\n        contentContainerStyle={styles.contentContainer}\r\n      >\r\n        {/* Profile Info */}\r\n        <View style={styles.profileHeader}>\r\n          <View style={[\r\n            profile?.firstName ? styles.avatarWithInitial : styles.avatar,\r\n            { backgroundColor: theme.accent.orange, borderColor: theme.accent.orange }\r\n          ]}>\r\n            {profile?.firstName ? (\r\n              <Text variant=\"heading2\" style={styles.avatarInitialText}>\r\n                {profile.firstName.charAt(0).toUpperCase()}\r\n              </Text>\r\n            ) : (\r\n              <IconSymbol\r\n                name=\"person\"\r\n                color=\"#FFFFFF\"\r\n                size={40}\r\n              />\r\n            )}\r\n          </View>\r\n          <View style={styles.profileInfo}>\r\n            <Text variant=\"heading3\" color=\"primary\" style={{ fontWeight: '600' }}>\r\n              {getUserDisplayName()}\r\n            </Text>\r\n            <Text variant=\"body\" color=\"secondary\" style={{ fontSize: 14 }}>\r\n              {user?.email || 'No email'}\r\n            </Text>\r\n            <Text variant=\"caption\" color=\"secondary\" style={{ fontSize: 12 }}>\r\n              {formatMemberSince(user?.created_at)}\r\n            </Text>\r\n          </View>\r\n        </View>\r\n\r\n        <View style={[styles.sectionDivider, { backgroundColor: theme.text.tertiary }]} />\r\n\r\n        {/* Premium Section */}\r\n        <View style={styles.section}>\r\n          <Text variant=\"caption\" color=\"secondary\" style={styles.sectionTitle}>\r\n            PREMIUM\r\n          </Text>\r\n\r\n          <View style={[styles.settingsGroup, { backgroundColor: theme.surface.card }]}>\r\n            {!isPremiumLoading && !isPremium ? (\r\n              <SettingsItem\r\n                title=\"Go Premium\"\r\n                subtitle=\"Unlock advanced analytics and unlimited workouts\"\r\n                onPress={() => router.push('/premium' as any)}\r\n              />\r\n            ) : isPremiumLoading ? (\r\n              <View style={styles.settingsItem}>\r\n                <View style={styles.settingsItemContent}>\r\n                  <Text variant=\"bodySemibold\" color=\"primary\" style={{ fontSize: 15 }}>\r\n                    Loading Premium Status\r\n                  </Text>\r\n                  <Text variant=\"caption\" color=\"secondary\" style={{ fontSize: 13 }}>\r\n                    Checking subscription details...\r\n                  </Text>\r\n                </View>\r\n              </View>\r\n            ) : (\r\n              <SettingsItem\r\n                title=\"Manage Subscription\"\r\n                subtitle=\"View billing history and manage your premium plan\"\r\n                onPress={() => router.push('/manage-subscription' as any)}\r\n              />\r\n            )}\r\n          </View>\r\n        </View>\r\n\r\n        <View style={[styles.sectionDivider, { backgroundColor: theme.text.tertiary }]} />\r\n\r\n        {/* Account Preferences */}\r\n        <View style={styles.section}>\r\n          <Text variant=\"caption\" color=\"secondary\" style={styles.sectionTitle}>\r\n            PREFERENCES\r\n          </Text>\r\n\r\n          <View style={[styles.settingsGroup, { backgroundColor: theme.surface.card }]}>\r\n            <SettingsItem\r\n              title=\"Name\"\r\n              subtitle={getUserDisplayName()}\r\n              onPress={handleNameEdit}\r\n              showDivider\r\n            />\r\n            <SettingsItem\r\n              title=\"Notifications\"\r\n              subtitle={notificationsEnabled ? `${configs.length} reminder${configs.length !== 1 ? 's' : ''} active` : 'Set workout reminders'}\r\n              onPress={() => {\r\n                triggerHaptic('selection');\r\n                setIsNotificationsModalVisible(true);\r\n              }}\r\n              showDivider\r\n            />\r\n            <SettingsItem\r\n              title=\"Units of Measurement\"\r\n              subtitle={`${weightUnit === 'kg' ? 'kg' : 'lbs'}  ${distanceUnit === 'km' ? 'km' : 'mi'}  ${sizeUnit === 'cm' ? 'cm' : 'in'}`}\r\n              onPress={() => {\r\n                triggerHaptic('selection');\r\n                setIsUnitsModalVisible(true);\r\n              }}\r\n              showDivider\r\n            />\r\n            <ToggleSettingsItem\r\n              title=\"Haptic Feedback\"\r\n              subtitle={hapticsEnabled ? \"Enabled\" : \"Disabled\"}\r\n              value={hapticsEnabled}\r\n              onValueChange={(val) => {\r\n                setHapticsEnabled(val);\r\n                if (val) triggerHaptic('selection');\r\n              }}\r\n            />\r\n          </View>\r\n        </View>\r\n\r\n        <View style={[styles.sectionDivider, { backgroundColor: theme.text.tertiary }]} />\r\n\r\n        {/* Support */}\r\n        <View style={styles.section}>\r\n          <Text variant=\"caption\" color=\"secondary\" style={styles.sectionTitle}>\r\n            SUPPORT\r\n          </Text>\r\n\r\n          <View style={[styles.settingsGroup, { backgroundColor: theme.surface.card }]}>\r\n            <SettingsItem\r\n              title=\"Send Feedback\"\r\n              subtitle=\"Help us improve the app\"\r\n              onPress={() => handlePreferencePress('Send Feedback')}\r\n              showDivider\r\n            />\r\n            <SettingsItem\r\n              title=\"FAQ\"\r\n              subtitle=\"Frequently asked questions\"\r\n              onPress={() => handlePreferencePress('FAQ')}\r\n              showDivider\r\n            />\r\n            <SettingsItem\r\n              title=\"About\"\r\n              subtitle=\"App version and legal information\"\r\n              onPress={() => handlePreferencePress('About')}\r\n            />\r\n          </View>\r\n        </View>\r\n\r\n        <View style={[styles.sectionDivider, { backgroundColor: theme.text.tertiary }]} />\r\n\r\n        {/* Dev Tools (only in development) */}\r\n        {__DEV__ && (\r\n          <View style={styles.section}>\r\n            <Text variant=\"caption\" color=\"secondary\" style={styles.sectionTitle}>\r\n              DEVELOPER TOOLS\r\n            </Text>\r\n\r\n            <View style={[styles.settingsGroup, { backgroundColor: theme.surface.card }]}>\r\n              <Pressable\r\n                style={styles.devToggleRow}\r\n                onPress={() => {\r\n                  triggerHaptic('selection');\r\n                  const newValue = premiumOverride === 'premium' ? 'free' : 'premium';\r\n                  setPremiumOverride(newValue);\r\n                }}\r\n              >\r\n                <View style={styles.devToggleInfo}>\r\n                  <View style={{ flex: 1 }}>\r\n                    <Text variant=\"bodySemibold\" color=\"primary\">Premium Status</Text>\r\n                    <Text variant=\"caption\" color=\"secondary\" style={{ fontSize: 13 }}>\r\n                      {premiumOverride === 'premium' ? 'Premium' : 'Free'}\r\n                    </Text>\r\n                  </View>\r\n                </View>\r\n                <View style={[\r\n                  styles.devToggleBadge,\r\n                  { backgroundColor: premiumOverride === 'premium' ? theme.accent.orange : theme.surface.elevated }\r\n                ]}>\r\n                  <Text variant=\"captionSmall\" style={{ color: premiumOverride === 'premium' ? '#FFF' : theme.text.secondary }}>\r\n                    {premiumOverride === 'premium' ? 'PRO' : 'FREE'}\r\n                  </Text>\r\n                </View>\r\n              </Pressable>\r\n            </View>\r\n          </View>\r\n        )}\r\n\r\n        <View style={[styles.sectionDivider, { backgroundColor: theme.text.tertiary }]} />\r\n\r\n        {/* Account */}\r\n        <View style={styles.section}>\r\n          <Text variant=\"caption\" color=\"secondary\" style={styles.sectionTitle}>\r\n            ACCOUNT\r\n          </Text>\r\n\r\n          <View style={[styles.settingsGroup, { backgroundColor: theme.surface.card }]}>\r\n            <SettingsItem\r\n              title=\"Sign Out\"\r\n              subtitle=\"Sign out of your account\"\r\n              onPress={handleSignOut}\r\n              showDivider\r\n            />\r\n            <SettingsItem\r\n              title=\"Delete Account\"\r\n              subtitle=\"Permanently delete your account and data\"\r\n              onPress={handleDeleteAccount}\r\n            />\r\n          </View>\r\n        </View>\r\n      </ScrollView>\r\n\r\n      <View style={[styles.bottomDivider, { backgroundColor: theme.text.tertiary }]} />\r\n\r\n      <NameEditModal\r\n        visible={isNameModalVisible}\r\n        firstName={getCurrentFirstName()}\r\n        lastName={getCurrentLastName()}\r\n        onClose={handleCloseNameModal}\r\n        onSave={handleNameSave}\r\n      />\r\n\r\n      <BodyMetricsModal\r\n        visible={isBodyMetricsModalVisible}\r\n        heightFeet={profile?.heightFeet || 5}\r\n        heightInches={profile?.heightInches || 9}\r\n        weightLbs={profile?.weightLbs || 0}\r\n        onClose={() => setIsBodyMetricsModalVisible(false)}\r\n        onSave={handleBodyMetricsSave}\r\n      />\r\n\r\n      <UnitsModal\r\n        visible={isUnitsModalVisible}\r\n        onClose={() => setIsUnitsModalVisible(false)}\r\n      />\r\n\r\n      <NotificationsModal\r\n        visible={isNotificationsModalVisible}\r\n        onClose={() => setIsNotificationsModalVisible(false)}\r\n      />\r\n\r\n      <SignOutConfirmationModal\r\n        visible={isSignOutModalVisible}\r\n        onClose={handleCloseSignOutModal}\r\n        onConfirm={handleSignOutConfirm}\r\n        isLoading={isSigningOut}\r\n      />\r\n\r\n      <FeedbackModal\r\n        visible={isFeedbackModalVisible}\r\n        onClose={() => setIsFeedbackModalVisible(false)}\r\n      />\r\n\r\n      <DeleteAccountConfirmationModal\r\n        visible={isDeleteAccountModalVisible}\r\n        onClose={handleCloseDeleteAccountModal}\r\n        onConfirm={handleDeleteAccountConfirm}\r\n        isLoading={isDeletingAccount}\r\n      />\r\n    </SafeAreaView>\r\n  );\r\n};\r\n\r\ninterface SettingsItemProps {\r\n  title: string;\r\n  subtitle: string;\r\n  onPress: () => void;\r\n  showDivider?: boolean;\r\n}\r\n\r\nconst SettingsItem: React.FC<SettingsItemProps> = ({ title, subtitle, onPress, showDivider }) => {\r\n  const { theme } = useTheme();\r\n\r\n  return (\r\n    <>\r\n      <Pressable\r\n        onPress={() => {\r\n          triggerHaptic('selection');\r\n          onPress();\r\n        }}\r\n        accessibilityRole=\"button\"\r\n        accessibilityLabel={title}\r\n        style={({ pressed }) => [\r\n          styles.settingsItem,\r\n          { backgroundColor: pressed ? theme.surface.elevated : 'transparent' }\r\n        ]}\r\n      >\r\n        <View style={styles.settingsItemContent}>\r\n          <Text variant=\"bodySemibold\" color=\"primary\" style={{ fontSize: 15 }}>\r\n            {title}\r\n          </Text>\r\n          <Text variant=\"caption\" color=\"secondary\" style={{ fontSize: 13 }}>\r\n            {subtitle}\r\n          </Text>\r\n        </View>\r\n        <IconSymbol\r\n          name=\"chevron-right\"\r\n          color={theme.text.tertiary}\r\n          size={18}\r\n        />\r\n      </Pressable>\r\n      {showDivider && (\r\n        <View style={[styles.settingsItemDivider, { backgroundColor: theme.surface.elevated }]} />\r\n      )}\r\n    </>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    flex: 1,\r\n    backgroundColor: colors.primary.bg,\r\n  },\r\n  headerContainer: {\r\n    backgroundColor: colors.primary.bg,\r\n  },\r\n  header: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'space-between',\r\n    paddingHorizontal: spacing.lg,\r\n    paddingTop: spacing.sm,\r\n    paddingBottom: spacing.xs,\r\n    backgroundColor: colors.primary.bg,\r\n  },\r\n  backButton: {\r\n    width: spacing.xl,\r\n    height: spacing.xl,\r\n    borderRadius: radius.full,\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n  },\r\n  headerSpacer: {\r\n    width: spacing.xl,\r\n  },\r\n  content: {\r\n    flex: 1,\r\n  },\r\n  contentContainer: {\r\n    paddingTop: spacing.sm,\r\n    paddingBottom: spacing.xl + spacing.lg,\r\n  },\r\n  profileHeader: {\r\n    alignItems: 'center',\r\n    gap: spacing.md,\r\n    paddingHorizontal: spacing.lg,\r\n    paddingTop: spacing.lg,\r\n    paddingBottom: spacing.lg,\r\n  },\r\n  avatar: {\r\n    width: 80,\r\n    height: 80,\r\n    borderRadius: radius.full,\r\n    backgroundColor: colors.surface.card,\r\n    borderWidth: 2,\r\n    borderColor: colors.accent.orange,\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n  },\r\n  avatarWithInitial: {\r\n    width: 80,\r\n    height: 80,\r\n    borderRadius: radius.full,\r\n    backgroundColor: colors.surface.card,\r\n    borderWidth: 2,\r\n    borderColor: colors.accent.orange,\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n  },\r\n  avatarInitialText: {\r\n    color: '#FFFFFF',\r\n    fontSize: 32,\r\n    fontWeight: '600',\r\n  },\r\n  profileInfo: {\r\n    alignItems: 'center',\r\n    gap: spacing.xs,\r\n  },\r\n  section: {\r\n    marginBottom: spacing.sm,\r\n  },\r\n  sectionDivider: {\r\n    height: 1,\r\n    marginVertical: spacing.lg,\r\n    opacity: 0.15,\r\n  },\r\n  headerDivider: {\r\n    height: 1,\r\n    opacity: 0.15,\r\n  },\r\n  bottomDivider: {\r\n    height: 1,\r\n    opacity: 0.15,\r\n  },\r\n  sectionTitle: {\r\n    paddingHorizontal: spacing.lg,\r\n    paddingBottom: spacing.sm,\r\n    fontSize: 12,\r\n    fontWeight: '600',\r\n    letterSpacing: 0.5,\r\n    textTransform: 'uppercase',\r\n  },\r\n  settingsGroup: {\r\n    marginHorizontal: spacing.lg,\r\n    marginTop: spacing.xs,\r\n    borderRadius: radius.lg,\r\n    overflow: 'hidden',\r\n  },\r\n  settingsItem: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    paddingVertical: spacing.md + 2,\r\n    paddingHorizontal: spacing.lg,\r\n    minHeight: 64,\r\n  },\r\n  settingsItemDivider: {\r\n    height: 0.5,\r\n    marginLeft: spacing.lg,\r\n    opacity: 0.5,\r\n  },\r\n  settingsItemContent: {\r\n    flex: 1,\r\n    gap: 3,\r\n    justifyContent: 'center',\r\n  },\r\n  preferencesList: {\r\n    gap: spacing.md,\r\n  },\r\n  preferenceItemContent: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    flex: 1,\r\n  },\r\n  preferenceIcon: {\r\n    width: spacing.xl,\r\n    height: spacing.xl,\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n    marginRight: spacing.lg,\r\n  },\r\n  preferenceContent: {\r\n    flex: 1,\r\n    gap: spacing.xxs,\r\n  },\r\n  devToggleRow: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'space-between',\r\n    paddingVertical: spacing.md + 2,\r\n    paddingHorizontal: spacing.lg,\r\n    minHeight: 64,\r\n  },\r\n  devToggleInfo: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    flex: 1,\r\n  },\r\n  devToggleBadge: {\r\n    paddingHorizontal: spacing.md,\r\n    paddingVertical: spacing.xs,\r\n    borderRadius: radius.full,\r\n  },\r\n  toggleContainer: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'space-between',\r\n    paddingVertical: spacing.sm,\r\n    flex: 1,\r\n  },\r\n});\r\n\r\ninterface ToggleSettingsItemProps {\r\n  title: string;\r\n  subtitle: string;\r\n  value: boolean;\r\n  onValueChange: (value: boolean) => void;\r\n  showDivider?: boolean;\r\n}\r\n\r\nconst ToggleSettingsItem: React.FC<ToggleSettingsItemProps> = ({\r\n  title,\r\n  subtitle,\r\n  value,\r\n  onValueChange,\r\n  showDivider\r\n}) => {\r\n  const { theme } = useTheme();\r\n\r\n  return (\r\n    <>\r\n      <View style={styles.settingsItem}>\r\n        <View style={styles.settingsItemContent}>\r\n          <Text variant=\"bodySemibold\" color=\"primary\" style={{ fontSize: 15 }}>\r\n            {title}\r\n          </Text>\r\n          <Text variant=\"caption\" color=\"secondary\" style={{ fontSize: 13 }}>\r\n            {subtitle}\r\n          </Text>\r\n        </View>\r\n        <Switch\r\n          value={value}\r\n          onValueChange={onValueChange}\r\n          trackColor={{ false: theme.surface.subtle, true: theme.accent.orange }}\r\n          thumbColor={'#FFFFFF'}\r\n          ios_backgroundColor={theme.surface.subtle}\r\n        />\r\n      </View>\r\n      {showDivider && (\r\n        <View style={[styles.settingsItemDivider, { backgroundColor: theme.surface.elevated }]} />\r\n      )}\r\n    </>\r\n  );\r\n};\r\n\r\ninterface DeleteAccountConfirmationModalProps {\r\n  visible: boolean;\r\n  onClose: () => void;\r\n  onConfirm: () => void;\r\n  isLoading: boolean;\r\n}\r\n\r\nconst DeleteAccountConfirmationModal: React.FC<DeleteAccountConfirmationModalProps> = ({\r\n  visible,\r\n  onClose,\r\n  onConfirm,\r\n  isLoading\r\n}) => {\r\n  const { theme } = useTheme();\r\n\r\n  if (!visible) return null;\r\n\r\n  return (\r\n    <View style={modalStyles.overlay}>\r\n      <View style={[modalStyles.container, { backgroundColor: theme.surface.card }]}>\r\n        <View style={modalStyles.header}>\r\n          <IconSymbol name=\"warning\" size={32} color=\"#FF3B30\" />\r\n          <Text variant=\"heading3\" color=\"primary\" style={{ marginTop: spacing.md }}>\r\n            Delete Account\r\n          </Text>\r\n        </View>\r\n\r\n        <View style={modalStyles.content}>\r\n          <Text variant=\"body\" color=\"secondary\" style={{ textAlign: 'center', lineHeight: 22 }}>\r\n            This action cannot be undone. Deleting your account will permanently remove:\r\n          </Text>\r\n          \r\n          <View style={modalStyles.warningList}>\r\n            <Text variant=\"body\" color=\"secondary\" style={modalStyles.warningItem}>\r\n               All your workout data and history\r\n            </Text>\r\n            <Text variant=\"body\" color=\"secondary\" style={modalStyles.warningItem}>\r\n               Personal profile information\r\n            </Text>\r\n            <Text variant=\"body\" color=\"secondary\" style={modalStyles.warningItem}>\r\n               Premium subscription (if active)\r\n            </Text>\r\n            <Text variant=\"body\" color=\"secondary\" style={modalStyles.warningItem}>\r\n               All app preferences and settings\r\n            </Text>\r\n          </View>\r\n\r\n          <Text variant=\"body\" color=\"secondary\" style={{ textAlign: 'center', lineHeight: 22 }}>\r\n            Are you sure you want to continue?\r\n          </Text>\r\n        </View>\r\n\r\n        <View style={modalStyles.actions}>\r\n          <Pressable\r\n            style={[modalStyles.button, modalStyles.cancelButton, { backgroundColor: theme.surface.elevated }]}\r\n            onPress={onClose}\r\n            disabled={isLoading}\r\n          >\r\n            <Text variant=\"bodySemibold\" color=\"primary\">\r\n              Cancel\r\n            </Text>\r\n          </Pressable>\r\n\r\n          <Pressable\r\n            style={[modalStyles.button, modalStyles.deleteButton, { backgroundColor: '#FF3B30' }]}\r\n            onPress={onConfirm}\r\n            disabled={isLoading}\r\n          >\r\n            {isLoading ? (\r\n              <ActivityIndicator color=\"#FFFFFF\" />\r\n            ) : (\r\n              <Text variant=\"bodySemibold\" style={{ color: '#FFFFFF' }}>\r\n                Delete Account\r\n              </Text>\r\n            )}\r\n          </Pressable>\r\n        </View>\r\n      </View>\r\n    </View>\r\n  );\r\n};\r\n\r\nconst modalStyles = StyleSheet.create({\r\n  overlay: {\r\n    position: 'absolute',\r\n    top: 0,\r\n    left: 0,\r\n    right: 0,\r\n    bottom: 0,\r\n    backgroundColor: 'rgba(0, 0, 0, 0.5)',\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n    padding: spacing.lg,\r\n  },\r\n  container: {\r\n    borderRadius: radius.lg,\r\n    padding: spacing.xl,\r\n    maxWidth: 400,\r\n    width: '100%',\r\n  },\r\n  header: {\r\n    alignItems: 'center',\r\n    marginBottom: spacing.lg,\r\n  },\r\n  content: {\r\n    gap: spacing.md,\r\n    marginBottom: spacing.xl,\r\n  },\r\n  warningList: {\r\n    gap: spacing.xs,\r\n    marginVertical: spacing.md,\r\n  },\r\n  warningItem: {\r\n    fontSize: 14,\r\n    lineHeight: 20,\r\n  },\r\n  actions: {\r\n    gap: spacing.md,\r\n  },\r\n  button: {\r\n    paddingVertical: spacing.md,\r\n    paddingHorizontal: spacing.lg,\r\n    borderRadius: radius.lg,\r\n    alignItems: 'center',\r\n    minHeight: 48,\r\n    justifyContent: 'center',\r\n  },\r\n  cancelButton: {\r\n    borderWidth: 1,\r\n    borderColor: colors.surface.elevated,\r\n  },\r\n  deleteButton: {},\r\n});\r\n\r\nexport default ProfileModal;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\app\\plan-detail.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'handleBackPress'. Either include it or remove the dependency array.","line":166,"column":6,"nodeType":"ArrayExpression","endLine":166,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [handleBackPress]","fix":{"range":[4855,4857],"text":"[handleBackPress]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * plan-detail\n * Modal-style screen that presents a saved workout plan with matching styling to the builder screens.\n */\nimport React, { useEffect, useMemo, useRef, useCallback } from 'react';\nimport {\n  BackHandler,\n  Dimensions,\n  KeyboardAvoidingView,\n  Platform,\n  Pressable,\n  ScrollView,\n  StyleSheet,\n  View,\n} from 'react-native';\nimport { useFocusEffect } from '@react-navigation/native';\nimport { useLocalSearchParams, useRouter } from 'expo-router';\nimport { triggerHaptic } from '@/utils/haptics';\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\nimport Animated, {\n  runOnJS,\n  useAnimatedStyle,\n  useSharedValue,\n  withSpring,\n  withTiming,\n} from 'react-native-reanimated';\n\nimport { Text } from '@/components/atoms/Text';\nimport { SurfaceCard } from '@/components/atoms/SurfaceCard';\nimport { IconSymbol } from '@/components/ui/icon-symbol';\nimport { usePlansStore, type PlansState } from '@/store/plansStore';\nimport { buttonPressAnimation, springTight, timingSlow } from '@/constants/animations';\nimport { colors, radius, spacing } from '@/constants/theme';\nimport hierarchyData from '@/data/hierarchy.json';\n\nconst BACK_ENTRY_OFFSET = spacing['2xl'];\nconst SCREEN_HEIGHT = Dimensions.get('window').height;\n\nconst styles = StyleSheet.create({\n  container: {\n    ...StyleSheet.absoluteFillObject,\n    backgroundColor: colors.primary.bg,\n    paddingHorizontal: spacing.md,\n    paddingBottom: spacing.lg,\n  },\n  keyboardAvoider: {\n    flex: 1,\n  },\n  scrollContent: {\n    flexGrow: 1,\n    gap: spacing.lg,\n    paddingBottom: spacing['2xl'] * 4,\n  },\n  topSection: {\n    width: '100%',\n    marginTop: spacing.md,\n    marginBottom: spacing.md,\n    gap: spacing.md,\n  },\n  backButtonContainer: {\n    alignSelf: 'flex-start',\n    borderRadius: radius.lg,\n  },\n  backButtonPressable: {\n    paddingVertical: spacing.xs,\n    paddingRight: spacing.sm,\n    paddingLeft: 0,\n    borderRadius: radius.lg,\n    alignItems: 'flex-start',\n    justifyContent: 'center',\n  },\n  headerContent: {\n    gap: spacing.xs,\n    alignItems: 'flex-start',\n  },\n  exercisesCard: {\n    gap: spacing.md,\n    borderWidth: StyleSheet.hairlineWidth,\n    borderColor: colors.border.light,\n    borderRadius: radius.lg,\n    backgroundColor: colors.surface.card,\n  },\n  exerciseRow: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    paddingVertical: spacing.sm,\n    paddingHorizontal: spacing.md,\n    borderRadius: radius.md,\n    backgroundColor: colors.surface.subtle,\n  },\n  exerciseInfo: {\n    gap: spacing.xs,\n    flex: 1,\n  },\n  placeholderCard: {\n    alignItems: 'flex-start',\n    gap: spacing.sm,\n    borderWidth: StyleSheet.hairlineWidth,\n    borderColor: colors.border.light,\n    borderRadius: radius.lg,\n    backgroundColor: colors.surface.card,\n  },\n});\n\nconst PlanDetailScreen: React.FC = () => {\n  const router = useRouter();\n  const insets = useSafeAreaInsets();\n  const { planId } = useLocalSearchParams<{ planId?: string }>();\n  const plans = usePlansStore((state: PlansState) => state.plans);\n  const backScale = useSharedValue(1);\n  const backTranslateY = useSharedValue(-BACK_ENTRY_OFFSET);\n  const containerTranslateY = useSharedValue(SCREEN_HEIGHT);\n\n  // Build muscle to mid-level group mapping\n  const muscleToMidLevelMap = useMemo(() => {\n    const map: Record<string, string> = {};\n    const hierarchy = hierarchyData.muscle_hierarchy;\n\n    Object.entries(hierarchy).forEach(([l1, l1Data]: [string, any]) => {\n      if (l1Data?.muscles) {\n        Object.entries(l1Data.muscles).forEach(([midLevel, midLevelData]: [string, any]) => {\n          // Map the mid-level group to itself\n          map[midLevel] = midLevel;\n          \n          // Map all low-level muscles to their mid-level parent\n          if (midLevelData?.muscles) {\n            Object.keys(midLevelData.muscles).forEach(lowLevel => {\n              map[lowLevel] = midLevel;\n            });\n          }\n        });\n      }\n    });\n    return map;\n  }, []);\n\n  const plan = useMemo(() => plans.find((item) => item.id === planId), [planId, plans]);\n\n  const scrollRef = useRef<ScrollView>(null);\n\n  useEffect(() => {\n    backTranslateY.value = withTiming(0, timingSlow);\n    containerTranslateY.value = withTiming(0, timingSlow);\n  }, [backTranslateY, containerTranslateY]);\n\n  // Reset scroll position when screen gains focus\n  useFocusEffect(\n    useCallback(() => {\n      const timeout = setTimeout(() => {\n        scrollRef.current?.scrollTo({ y: 0, animated: false });\n      }, 50);\n      return () => clearTimeout(timeout);\n    }, [])\n  );\n\n  // Handle Android hardware back button\n  useEffect(() => {\n    const backAction = () => {\n      handleBackPress();\n      return true;\n    };\n\n    const backHandler = BackHandler.addEventListener('hardwareBackPress', backAction);\n    return () => backHandler.remove();\n  }, []);\n\n  const animatedBackStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateY: backTranslateY.value },\n      { scale: backScale.value },\n    ],\n  }));\n\n  const animatedContainerStyle = useAnimatedStyle(() => ({\n    transform: [{ translateY: containerTranslateY.value }],\n  }));\n\n  const handleBackPress = () => {\n    triggerHaptic('selection');\n    backScale.value = withSpring(0.92, springTight);\n\n    setTimeout(() => {\n      backScale.value = withSpring(1, springTight);\n      backTranslateY.value = withTiming(BACK_ENTRY_OFFSET, timingSlow);\n      containerTranslateY.value = withTiming(\n        SCREEN_HEIGHT,\n        timingSlow,\n        (finished) => {\n          if (finished) {\n            runOnJS(router.back)();\n          }\n        },\n      );\n    }, buttonPressAnimation.duration);\n  };\n\n  return (\n    <Animated.View style={[styles.container, { paddingTop: spacing.lg + insets.top }, animatedContainerStyle]}>\n      <KeyboardAvoidingView\n        style={styles.keyboardAvoider}\n        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}\n        keyboardVerticalOffset={spacing['2xl']}\n      >\n        <ScrollView\n          ref={scrollRef}\n          contentContainerStyle={styles.scrollContent}\n          showsVerticalScrollIndicator={false}\n          keyboardShouldPersistTaps=\"handled\"\n          keyboardDismissMode=\"on-drag\"\n        >\n          <View style={styles.topSection}>\n            <Animated.View style={[styles.backButtonContainer, animatedBackStyle]}>\n              <Pressable\n                accessibilityRole=\"button\"\n                accessibilityLabel=\"Go back to plans\"\n                onPress={handleBackPress}\n                hitSlop={spacing.sm}\n                style={styles.backButtonPressable}\n              >\n                <IconSymbol name=\"arrow-back\" color={colors.text.primary} size={24} />\n              </Pressable>\n            </Animated.View>\n\n            <View style={styles.headerContent}>\n              <Text variant=\"display1\" color=\"primary\">\n                {plan?.name ?? 'Workout'}\n              </Text>\n              <Text variant=\"body\" color=\"secondary\">\n                {plan\n                  ? `${plan.exercises.length} exercise${plan.exercises.length === 1 ? '' : 's'} saved.`\n                  : 'No exercises found for this plan.'}\n              </Text>\n            </View>\n          </View>\n\n          {plan ? (\n            <SurfaceCard tone=\"neutral\" padding=\"xl\" showAccentStripe={false} style={styles.exercisesCard}>\n              {plan.exercises.map((exercise) => {\n                // Get all muscle names from the exercise's muscles object\n                const muscleNames = Object.keys(exercise.muscles || {});\n                \n                // Map each muscle to its mid-level parent group\n                const midLevelGroups = muscleNames.map(muscle => muscleToMidLevelMap[muscle]).filter(Boolean);\n                \n                // Remove duplicates and sort for consistency\n                const uniqueGroups = [...new Set(midLevelGroups)];\n                const midLevelMusclesLabel = uniqueGroups.length > 0 ? uniqueGroups.join('  ') : 'General';\n\n                return (\n                  <View key={exercise.id} style={styles.exerciseRow}>\n                    <View style={styles.exerciseInfo}>\n                      <Text variant=\"bodySemibold\" color=\"primary\">\n                        {exercise.name}\n                      </Text>\n                      <Text variant=\"caption\" color=\"secondary\">\n                        {midLevelMusclesLabel}\n                      </Text>\n                    </View>\n                  </View>\n                );\n              })}\n            </SurfaceCard>\n          ) : (\n            <SurfaceCard tone=\"neutral\" padding=\"xl\" showAccentStripe={false} style={styles.placeholderCard}>\n              <Text variant=\"bodySemibold\" color=\"primary\">\n                Workout not available\n              </Text>\n              <Text variant=\"body\" color=\"secondary\">\n                This workout couldnt be found. Please return and select another.\n              </Text>\n            </SurfaceCard>\n          )}\n        </ScrollView>\n      </KeyboardAvoidingView>\n    </Animated.View>\n  );\n};\n\nexport default PlanDetailScreen;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\app\\premium.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'typography' is defined but never used.","line":22,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'shadows' is defined but never used.","line":22,"column":47,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":54},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sizing' is defined but never used.","line":22,"column":56,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":62},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isDarkMode' is assigned a value but never used.","line":54,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":54,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isPro' is assigned a value but never used.","line":56,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":56,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useCallback } from 'react';\r\nimport {\r\n  View,\r\n  ScrollView,\r\n  StyleSheet,\r\n  TouchableOpacity,\r\n  BackHandler,\r\n} from 'react-native';\r\nimport { router } from 'expo-router';\r\nimport { LinearGradient } from 'expo-linear-gradient';\r\nimport { Ionicons } from '@expo/vector-icons';\r\nimport Animated, { FadeInDown, FadeInUp } from 'react-native-reanimated';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { Button } from '@/components/atoms/Button';\r\nimport { SurfaceCard } from '@/components/atoms/SurfaceCard';\r\nimport { InputField } from '@/components/atoms/InputField';\r\nimport { useTheme } from '@/hooks/useTheme';\r\nimport { useSettingsStore } from '@/store/settingsStore';\r\nimport { colors, spacing, radius, typography, shadows, sizing } from '@/constants/theme';\r\n\r\ninterface FeatureItemProps {\r\n  icon: keyof typeof Ionicons.glyphMap;\r\n  title: string;\r\n  description: string;\r\n  index: number;\r\n}\r\n\r\nconst FeatureItem: React.FC<FeatureItemProps> = ({ icon, title, description, index }) => {\r\n  const { theme } = useTheme();\r\n\r\n  return (\r\n    <Animated.View entering={FadeInDown.delay(index * 100).springify()}>\r\n      <View style={styles.featureItem}>\r\n        <View style={[styles.iconContainer, { backgroundColor: theme.surface.tint }]}>\r\n          <Ionicons name={icon} size={24} color={theme.accent.orange} />\r\n        </View>\r\n        <View style={styles.featureText}>\r\n          <Text variant=\"heading4\" style={{ marginBottom: spacing.xs }}>\r\n            {title}\r\n          </Text>\r\n          <Text variant=\"body\" color=\"secondary\">\r\n            {description}\r\n          </Text>\r\n        </View>\r\n      </View>\r\n    </Animated.View>\r\n  );\r\n};\r\n\r\nexport default function PremiumScreen() {\r\n  const { theme, isDarkMode } = useTheme();\r\n  const insets = useSafeAreaInsets();\r\n  const { isPro, setPro } = useSettingsStore();\r\n  const [promoCode, setPromoCode] = useState('');\r\n  const [isSubmittingPromo, setIsSubmittingPromo] = useState(false);\r\n  const [promoError, setPromoError] = useState('');\r\n\r\n  const handlePurchase = () => {\r\n    triggerHaptic('medium');\r\n    console.log('Purchase premium');\r\n  };\r\n\r\n  const handleBack = useCallback(() => {\r\n    triggerHaptic('selection');\r\n    router.back();\r\n  }, []);\r\n\r\n  // Handle Android hardware back button\r\n  useEffect(() => {\r\n    const backAction = () => {\r\n      handleBack();\r\n      return true;\r\n    };\r\n\r\n    const backHandler = BackHandler.addEventListener('hardwareBackPress', backAction);\r\n    return () => backHandler.remove();\r\n  }, [handleBack]);\r\n\r\n  const handlePromoCodeSubmit = async () => {\r\n    if (!promoCode.trim()) {\r\n      setPromoError('Please enter a promo code');\r\n      return;\r\n    }\r\n\r\n    setIsSubmittingPromo(true);\r\n    setPromoError('');\r\n\r\n    // Simulate API call delay\r\n    await new Promise(resolve => setTimeout(resolve, 1000));\r\n\r\n    if (promoCode.toUpperCase() === 'OWEN2026') {\r\n      triggerHaptic('success');\r\n      await setPro(true);\r\n      router.back();\r\n    } else {\r\n      triggerHaptic('error');\r\n      setPromoError('Invalid promo code');\r\n    }\r\n\r\n    setIsSubmittingPromo(false);\r\n  };\r\n\r\n  const features = [\r\n    {\r\n      icon: 'analytics' as const,\r\n      title: 'Advanced Analytics',\r\n      description: 'Deep insights with detailed charts and progress tracking',\r\n    },\r\n    {\r\n      icon: 'create' as const,\r\n      title: 'Create Unlimited Workouts and Plans',\r\n      description: 'Build and save as many workouts and plans as you want',\r\n    },\r\n    {\r\n      icon: 'lock-open' as const,\r\n      title: 'Unlock all Premium Workouts and Plans',\r\n      description: 'Get full access to the entire premium library',\r\n    },\r\n    {\r\n      icon: 'sparkles' as const,\r\n      title: 'Access to all future premium updates',\r\n      description: 'All new premium features and content included',\r\n    },\r\n  ];\r\n\r\n  return (\r\n    <View style={[styles.root, { paddingTop: insets.top, paddingBottom: insets.bottom, backgroundColor: theme.primary.bg }]}>\r\n      <LinearGradient\r\n        colors={[theme.accent.orange, theme.primary.bg]}\r\n        start={{ x: 0, y: 0 }}\r\n        end={{ x: 0, y: 0.6 }}\r\n        style={StyleSheet.absoluteFillObject}\r\n      />\r\n\r\n      <View style={styles.header}>\r\n        <TouchableOpacity\r\n          style={styles.backButton}\r\n          onPress={handleBack}\r\n          activeOpacity={0.7}\r\n        >\r\n          <Ionicons name=\"arrow-back\" size={24} color={theme.text.primary} />\r\n        </TouchableOpacity>\r\n      </View>\r\n\r\n      <ScrollView \r\n        style={styles.container}\r\n        contentContainerStyle={styles.scrollContent}\r\n        showsVerticalScrollIndicator={false}\r\n      >\r\n        <Animated.View entering={FadeInUp.springify()} style={styles.heroSection}>\r\n          <Ionicons name=\"diamond\" size={80} color={colors.text.primary} />\r\n          <Text variant=\"display1\" style={[styles.heroTitle, { color: theme.text.primary }]}>\r\n            Hercules Pro\r\n          </Text>\r\n          <Text variant=\"body\" style={[styles.heroSubtitle, { color: theme.text.secondary }]}>\r\n            Unlock your full potential\r\n          </Text>\r\n        </Animated.View>\r\n\r\n        <View style={styles.featuresSection}>\r\n          {features.map((feature, index) => (\r\n            <FeatureItem\r\n              key={feature.title}\r\n              icon={feature.icon}\r\n              title={feature.title}\r\n              description={feature.description}\r\n              index={index}\r\n            />\r\n          ))}\r\n        </View>\r\n\r\n        <Animated.View entering={FadeInDown.delay(500).springify()} style={styles.promoSection}>\r\n          <SurfaceCard tone=\"elevated\" style={styles.promoCard}>\r\n            <Text variant=\"heading4\" style={styles.promoTitle}>\r\n              Have a promo code?\r\n            </Text>\r\n            <InputField\r\n              label=\"Promo Code\"\r\n              value={promoCode}\r\n              onChangeText={setPromoCode}\r\n              placeholder=\"Enter promo code\"\r\n              autoCapitalize=\"characters\"\r\n              editable={!isSubmittingPromo}\r\n              helperText={promoError}\r\n            />\r\n            <Button\r\n              label={isSubmittingPromo ? \"Applying...\" : \"Apply Promo Code\"}\r\n              onPress={handlePromoCodeSubmit}\r\n              variant=\"secondary\"\r\n              size=\"md\"\r\n              disabled={isSubmittingPromo}\r\n              style={styles.promoButton}\r\n            />\r\n          </SurfaceCard>\r\n        </Animated.View>\r\n\r\n        <Animated.View entering={FadeInDown.delay(600).springify()} style={styles.footer}>\r\n          <Button\r\n            label=\"Unlock Hercules Pro\"\r\n            onPress={handlePurchase}\r\n            variant=\"primary\"\r\n            size=\"xl\"\r\n            style={styles.purchaseButton}\r\n          />\r\n        </Animated.View>\r\n      </ScrollView>\r\n    </View>\r\n  );\r\n}\r\n\r\nconst styles = StyleSheet.create({\r\n  root: {\r\n    flex: 1,\r\n  },\r\n  header: {\r\n    width: '100%',\r\n    zIndex: 10,\r\n  },\r\n  backButton: {\r\n    padding: spacing.md,\r\n    marginTop: spacing.sm,\r\n  },\r\n  container: {\r\n    flex: 1,\r\n    paddingHorizontal: spacing.xl,\r\n  },\r\n  scrollContent: {\r\n    paddingTop: spacing.lg,\r\n    paddingBottom: spacing.xl,\r\n    justifyContent: 'space-between',\r\n    minHeight: '100%',\r\n  },\r\n  heroSection: {\r\n    alignItems: 'center',\r\n    paddingTop: 0,\r\n  },\r\n  heroTitle: {\r\n    marginTop: spacing.md,\r\n    marginBottom: spacing.xs,\r\n    textAlign: 'center',\r\n  },\r\n  heroSubtitle: {\r\n    textAlign: 'center',\r\n    fontSize: 18,\r\n    opacity: 0.9,\r\n  },\r\n  featuresSection: {\r\n    gap: spacing.md,\r\n    marginVertical: spacing.xl,\r\n  },\r\n  featureItem: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    gap: spacing.md,\r\n  },\r\n  iconContainer: {\r\n    width: 44,\r\n    height: 44,\r\n    borderRadius: radius.md,\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n  },\r\n  featureText: {\r\n    flex: 1,\r\n  },\r\n  footer: {\r\n    width: '100%',\r\n    paddingTop: spacing.md,\r\n  },\r\n  promoSection: {\r\n    width: '100%',\r\n    marginBottom: spacing.lg,\r\n  },\r\n  promoCard: {\r\n    padding: spacing.lg,\r\n    gap: spacing.md,\r\n  },\r\n  promoTitle: {\r\n    textAlign: 'center',\r\n    marginBottom: spacing.xs,\r\n  },\r\n  promoButton: {\r\n    width: '100%',\r\n  },\r\n  purchaseButton: {\r\n    width: '100%',\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\app\\program-view.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\app\\workout-edit.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'exercises' is defined but never used.","line":22,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useWorkoutSessionsStore' is defined but never used.","line":24,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":24,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Exercise' is defined but never used.","line":27,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":27,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'openPicker' is assigned a value but never used.","line":47,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":47,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'closePicker' is assigned a value but never used.","line":48,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":48,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'muscleToMidLevelMap' is assigned a value but never used.","line":55,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":55,"endColumn":28}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * workout-edit\r\n * Screen for editing an existing workout session.\r\n */\r\n\r\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\r\nimport { FlatList, Pressable, StyleSheet, TextInput, View, BackHandler } from 'react-native';\r\nimport { useLocalSearchParams, useRouter } from 'expo-router';\r\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\nimport { LinearGradient } from 'expo-linear-gradient';\r\nimport { MaterialCommunityIcons } from '@expo/vector-icons';\r\n\r\nimport { Button } from '@/components/atoms/Button';\r\nimport { SurfaceCard } from '@/components/atoms/SurfaceCard';\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { EditableWorkoutExerciseCard } from '@/components/molecules/EditableWorkoutExerciseCard';\r\nimport { CreateExerciseModal } from '@/components/molecules/CreateExerciseModal';\r\nimport { DeleteConfirmationModal } from '@/components/molecules/DeleteConfirmationModal';\r\nimport { colors, radius, spacing, sizing } from '@/constants/theme';\r\nimport { useWorkoutEditor } from '@/hooks/useWorkoutEditor';\r\nimport { exercises, createCustomExerciseCatalogItem } from '@/constants/exercises';\r\nimport { useCustomExerciseStore } from '@/store/customExerciseStore';\r\nimport { useWorkoutSessionsStore } from '@/store/workoutSessionsStore';\r\nimport { searchExercises } from '@/utils/exerciseSearch';\r\nimport { getExerciseDisplayTagText } from '@/utils/exerciseDisplayTags';\r\nimport type { Exercise } from '@/constants/exercises';\r\nimport hierarchyData from '@/data/hierarchy.json';\r\n\r\nconst WorkoutEditScreen: React.FC = () => {\r\n  const router = useRouter();\r\n  const insets = useSafeAreaInsets();\r\n  const { workoutId } = useLocalSearchParams<{ workoutId?: string }>();\r\n\r\n  const {\r\n    workout,\r\n    planName,\r\n    exerciseDrafts,\r\n    exerciseCount,\r\n    expandedExercise,\r\n    toggleExercise,\r\n    updateExerciseSets,\r\n    removeExercise,\r\n    moveExercise,\r\n    addExercise,\r\n    saveWorkout,\r\n    openPicker,\r\n    closePicker,\r\n    filteredExercises,\r\n    searchTerm,\r\n    setSearchTerm,\r\n  } = useWorkoutEditor(workoutId);\r\n\r\n  // Build muscle to mid-level group mapping\r\n  const muscleToMidLevelMap = useMemo(() => {\r\n    const map: Record<string, string> = {};\r\n    const hierarchy = hierarchyData.muscle_hierarchy;\r\n\r\n    Object.entries(hierarchy).forEach(([l1, l1Data]: [string, any]) => {\r\n      if (l1Data?.muscles) {\r\n        Object.entries(l1Data.muscles).forEach(([midLevel, midLevelData]: [string, any]) => {\r\n          // Map the mid-level group to itself\r\n          map[midLevel] = midLevel;\r\n\r\n          // Map all low-level muscles to their mid-level parent\r\n          if (midLevelData?.muscles) {\r\n            Object.keys(midLevelData.muscles).forEach(lowLevel => {\r\n              map[lowLevel] = midLevel;\r\n            });\r\n          }\r\n        });\r\n      }\r\n    });\r\n    return map;\r\n  }, []);\r\n\r\n  const handleSelectExercise = useCallback(\r\n    (exercise: any) => {\r\n      addExercise(exercise);\r\n      triggerHaptic('selection');\r\n    },\r\n    [addExercise],\r\n  );\r\n\r\n  const handleSaveWorkout = useCallback(async () => {\r\n    const success = await saveWorkout();\r\n\r\n    if (!success) {\r\n      return;\r\n    }\r\n\r\n    triggerHaptic('success');\r\n    router.back();\r\n  }, [router, saveWorkout]);\r\n\r\n  // Handle Android hardware back button\r\n  useEffect(() => {\r\n    const backAction = () => {\r\n      router.back();\r\n      return true;\r\n    };\r\n\r\n    const backHandler = BackHandler.addEventListener('hardwareBackPress', backAction);\r\n    return () => backHandler.remove();\r\n  }, [router]);\r\n\r\n  const [isInteractionLocked, setInteractionLocked] = React.useState(false);\r\n  const [isPickerVisible, setIsPickerVisible] = React.useState(false);\r\n  const [isCreateExerciseModalVisible, setIsCreateExerciseModalVisible] = useState(false);\r\n  const [exerciseToRemove, setExerciseToRemove] = useState<string | null>(null);\r\n  const pickerListRef = useRef<FlatList>(null);\r\n  const customExercises = useCustomExerciseStore((state) => state.customExercises);\r\n\r\n  // Merge custom exercises with filtered exercises and apply search\r\n  const allFilteredExercises = useMemo(() => {\r\n    const customCatalogItems = customExercises.map((ce) =>\r\n      createCustomExerciseCatalogItem(ce.id, ce.name, ce.exerciseType)\r\n    );\r\n    const combinedExercises = [...filteredExercises, ...customCatalogItems];\r\n    // Use unified search with fuzzy matching and relevance ranking\r\n    return searchExercises(searchTerm, combinedExercises);\r\n  }, [filteredExercises, customExercises, searchTerm]);\r\n\r\n  const handleOpenPicker = useCallback(() => {\r\n    setIsPickerVisible(true);\r\n    // Scroll to top on next frame to ensure list is rendered\r\n    requestAnimationFrame(() => {\r\n      pickerListRef.current?.scrollToOffset({ offset: 0, animated: false });\r\n    });\r\n  }, []);\r\n\r\n  const handleClosePicker = useCallback(() => {\r\n    setIsPickerVisible(false);\r\n  }, []);\r\n\r\n  if (!workout) {\r\n    return (\r\n      <View style={styles.emptyContainer}>\r\n        <SurfaceCard padding=\"xl\" showAccentStripe={false} style={styles.emptyCard}>\r\n          <Text variant=\"heading3\">Workout not found</Text>\r\n          <Text color=\"secondary\">Return to the dashboard and select a workout to edit.</Text>\r\n          <Button label=\"Go Back\" onPress={router.back} />\r\n        </SurfaceCard>\r\n      </View>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <View style={styles.container}>\r\n      <FlatList\r\n        data={exerciseDrafts}\r\n        keyExtractor={(item) => item.name}\r\n        contentContainerStyle={[styles.listContent, { paddingTop: spacing.md + insets.top }]}\r\n        ListHeaderComponent={(\r\n          <View style={styles.headerSection}>\r\n            <SurfaceCard tone=\"neutral\" padding=\"lg\" showAccentStripe={false} style={styles.headerCard}>\r\n              <View style={styles.headerTextGroup}>\r\n                <Text variant=\"heading3\" color=\"primary\">\r\n                  {planName ?? 'Workout Session'}\r\n                </Text>\r\n                <Text variant=\"body\" color=\"secondary\">\r\n                  {`${exerciseCount} exercise${exerciseCount === 1 ? '' : 's'} in this session`}\r\n                </Text>\r\n              </View>\r\n            </SurfaceCard>\r\n            <LinearGradient\r\n              colors={[colors.accent.gradientStart, colors.accent.gradientEnd]}\r\n              start={{ x: 0, y: 0 }}\r\n              end={{ x: 1, y: 1 }}\r\n              style={styles.headerDivider}\r\n            />\r\n            <View style={styles.headerActions}>\r\n              <Button label=\"Add Exercise\" variant=\"ghost\" size=\"md\" onPress={handleOpenPicker} />\r\n            </View>\r\n          </View>\r\n        )}\r\n        ListFooterComponent={(\r\n          <View style={styles.footerSection}>\r\n            <Button label=\"Save Changes\" onPress={handleSaveWorkout} disabled={exerciseDrafts.length === 0} />\r\n          </View>\r\n        )}\r\n        onScrollBeginDrag={() => setInteractionLocked(true)}\r\n        onScrollEndDrag={() => setInteractionLocked(false)}\r\n        onMomentumScrollEnd={() => setInteractionLocked(false)}\r\n        onMomentumScrollBegin={() => setInteractionLocked(true)}\r\n        renderItem={({ item, index }) => (\r\n          <EditableWorkoutExerciseCard\r\n            exercise={item}\r\n            index={index}\r\n            isExpanded={expandedExercise === item.name}\r\n            onToggle={() => toggleExercise(item.name)}\r\n            onSaveSets={(sets) => {\r\n              updateExerciseSets(item.name, sets);\r\n              triggerHaptic('selection');\r\n            }}\r\n            onRemove={() => {\r\n              console.log('[workout-edit] onRemove triggered for:', item.name);\r\n              setExerciseToRemove(item.name);\r\n              triggerHaptic('selection');\r\n            }}\r\n            onMoveUp={() => {\r\n              moveExercise(item.name, 'up');\r\n              triggerHaptic('selection');\r\n            }}\r\n            onMoveDown={() => {\r\n              moveExercise(item.name, 'down');\r\n              triggerHaptic('selection');\r\n            }}\r\n            canMoveUp={index > 0}\r\n            canMoveDown={index < exerciseDrafts.length - 1}\r\n            onProgressChange={() => undefined}\r\n            isInteractionDisabled={isInteractionLocked}\r\n          />\r\n        )}\r\n        ItemSeparatorComponent={() => <View style={styles.itemSeparator} />}\r\n      />\r\n\r\n      {isPickerVisible ? (\r\n        <Pressable style={styles.overlay} onPress={handleClosePicker}>\r\n          <Pressable style={styles.modal} onPress={() => undefined}>\r\n            <Text variant=\"heading3\">Add Exercise</Text>\r\n            <TextInput\r\n              value={searchTerm}\r\n              onChangeText={setSearchTerm}\r\n              placeholder=\"Search by name or category\"\r\n              placeholderTextColor={colors.text.tertiary}\r\n              style={styles.searchInput}\r\n            />\r\n            <FlatList\r\n              ref={pickerListRef}\r\n              data={allFilteredExercises}\r\n              keyExtractor={(item) => item.id}\r\n              style={styles.modalList}\r\n              keyboardShouldPersistTaps=\"handled\"\r\n              renderItem={({ item }) => {\r\n                const musclesLabel = getExerciseDisplayTagText({\r\n                  muscles: item.muscles,\r\n                  exerciseType: item.exerciseType || 'weight',\r\n                });\r\n\r\n                return (\r\n                  <Pressable\r\n                    key={item.id}\r\n                    style={styles.modalItem}\r\n                    onPress={() => handleSelectExercise(item)}\r\n                  >\r\n                    <Text variant=\"bodySemibold\" color=\"primary\">\r\n                      {item.name}\r\n                    </Text>\r\n                    <Text variant=\"caption\" color=\"secondary\">\r\n                      {musclesLabel || 'General'}\r\n                    </Text>\r\n                  </Pressable>\r\n                );\r\n              }}\r\n              ListFooterComponent={(\r\n                <Pressable\r\n                  style={styles.createExerciseButton}\r\n                  onPress={() => {\r\n                    triggerHaptic('selection');\r\n                    setIsPickerVisible(false);\r\n                    setIsCreateExerciseModalVisible(true);\r\n                  }}\r\n                  accessibilityRole=\"button\"\r\n                  accessibilityLabel=\"Create a new custom exercise\"\r\n                >\r\n                  <MaterialCommunityIcons\r\n                    name=\"plus-circle-outline\"\r\n                    size={sizing.iconMD}\r\n                    color={colors.accent.primary}\r\n                  />\r\n                  <Text variant=\"bodySemibold\" style={{ color: colors.accent.primary }}>\r\n                    Create Exercise\r\n                  </Text>\r\n                </Pressable>\r\n              )}\r\n            />\r\n            <Button label=\"Close\" variant=\"ghost\" onPress={handleClosePicker} />\r\n          </Pressable>\r\n        </Pressable>\r\n      ) : null}\r\n      <CreateExerciseModal\r\n        visible={isCreateExerciseModalVisible}\r\n        onClose={() => setIsCreateExerciseModalVisible(false)}\r\n        onExerciseCreated={(exerciseName, exerciseType) => {\r\n          // Find the newly created exercise and add it\r\n          const newExercise = customExercises.find(e => e.name === exerciseName);\r\n          if (newExercise) {\r\n            const catalogItem = createCustomExerciseCatalogItem(\r\n              newExercise.id,\r\n              newExercise.name,\r\n              newExercise.exerciseType\r\n            );\r\n            handleSelectExercise(catalogItem);\r\n          }\r\n          setIsCreateExerciseModalVisible(false);\r\n        }}\r\n      />\r\n      <DeleteConfirmationModal\r\n        visible={!!exerciseToRemove}\r\n        onClose={() => setExerciseToRemove(null)}\r\n        onConfirm={() => {\r\n          if (exerciseToRemove) {\r\n            removeExercise(exerciseToRemove);\r\n            setExerciseToRemove(null);\r\n            triggerHaptic('success');\r\n          }\r\n        }}\r\n        title=\"Remove Exercise?\"\r\n        message=\"Are you sure you want to remove this exercise from your workout?\"\r\n        confirmLabel=\"Remove\"\r\n        cancelLabel=\"Keep\"\r\n      />\r\n    </View>\r\n  );\r\n};\r\n\r\nexport default WorkoutEditScreen;\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    flex: 1,\r\n    backgroundColor: colors.primary.bg,\r\n  },\r\n  listContent: {\r\n    padding: spacing.md,\r\n    gap: spacing.md,\r\n  },\r\n  headerSection: {\r\n    gap: spacing.md,\r\n  },\r\n  headerCard: {\r\n    gap: spacing.xs,\r\n    borderWidth: StyleSheet.hairlineWidth,\r\n    borderColor: colors.border.light,\r\n    borderRadius: radius.lg,\r\n    backgroundColor: colors.surface.card,\r\n  },\r\n  headerTextGroup: {\r\n    gap: spacing.xxxs,\r\n  },\r\n  headerDivider: {\r\n    height: spacing.xs,\r\n    borderRadius: radius.full,\r\n  },\r\n  headerActions: {\r\n    flexDirection: 'row',\r\n    justifyContent: 'flex-end',\r\n  },\r\n  itemSeparator: {\r\n    height: spacing.sm,\r\n  },\r\n  footerSection: {\r\n    paddingVertical: spacing.lg,\r\n    gap: spacing.md,\r\n  },\r\n  overlay: {\r\n    ...StyleSheet.absoluteFillObject,\r\n    backgroundColor: colors.overlay.scrim,\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n    padding: spacing.md,\r\n  },\r\n  modal: {\r\n    width: '100%',\r\n    maxHeight: '80%',\r\n    backgroundColor: colors.surface.card,\r\n    borderRadius: radius.lg,\r\n    padding: spacing.lg,\r\n    gap: spacing.md,\r\n  },\r\n  searchInput: {\r\n    width: '100%',\r\n    borderRadius: radius.md,\r\n    borderWidth: 1,\r\n    borderColor: colors.border.light,\r\n    paddingHorizontal: spacing.md,\r\n    paddingVertical: spacing.xs,\r\n    color: colors.text.primary,\r\n  },\r\n  modalList: {\r\n    maxHeight: 400,\r\n  },\r\n  modalItem: {\r\n    paddingVertical: spacing.sm,\r\n    borderBottomWidth: 1,\r\n    borderBottomColor: colors.border.light,\r\n    gap: spacing.xxxs,\r\n  },\r\n  emptyContainer: {\r\n    flex: 1,\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n    backgroundColor: colors.primary.bg,\r\n    padding: spacing.lg,\r\n  },\r\n  emptyCard: {\r\n    gap: spacing.md,\r\n  },\r\n  createExerciseButton: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    gap: spacing.sm,\r\n    paddingVertical: spacing.md,\r\n    marginTop: spacing.sm,\r\n    borderTopWidth: 1,\r\n    borderTopColor: colors.border.light,\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\app\\workout-session.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\app\\workout-success.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useEffect' is defined but never used.","line":1,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":39},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'radius' is defined but never used.","line":22,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useCallback, useEffect, useMemo } from 'react';\r\nimport { StyleSheet, View } from 'react-native';\r\nimport Animated, {\r\n  Easing,\r\n  runOnJS,\r\n  useAnimatedProps,\r\n  useAnimatedStyle,\r\n  useSharedValue,\r\n  withDelay,\r\n  withSpring,\r\n  withTiming,\r\n} from 'react-native-reanimated';\r\nimport { useRouter } from 'expo-router';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\nimport { MaterialCommunityIcons } from '@expo/vector-icons';\r\nimport Svg, { Circle } from 'react-native-svg';\r\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\r\n\r\nimport { useFocusEffect } from '@react-navigation/native';\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { springGentle } from '@/constants/animations';\r\nimport { colors, radius, sizing, spacing } from '@/constants/theme';\r\n\r\nconst AnimatedCircle = Animated.createAnimatedComponent(Circle);\r\n\r\nconst WorkoutSuccessScreen: React.FC = () => {\r\n  const router = useRouter();\r\n  const scale = useSharedValue(0.92);\r\n  const opacity = useSharedValue(0);\r\n  const ringProgress = useSharedValue(0);\r\n  const insets = useSafeAreaInsets();\r\n\r\n  const navigateHome = useCallback(() => {\r\n    router.replace('/(tabs)');\r\n  }, [router]);\r\n\r\n  const { circumference, radiusValue } = useMemo(() => {\r\n    const ringRadius = sizing.iconXL / 2;\r\n    return {\r\n      radiusValue: ringRadius,\r\n      circumference: 2 * Math.PI * ringRadius,\r\n    };\r\n  }, []);\r\n\r\n  useFocusEffect(\r\n    useCallback(() => {\r\n      // Reset animation state immediately on focus\r\n      opacity.value = 0;\r\n      scale.value = 0.92;\r\n      ringProgress.value = 0;\r\n\r\n      triggerHaptic('success');\r\n\r\n      opacity.value = withSpring(1, springGentle);\r\n      scale.value = withSpring(1, springGentle);\r\n      ringProgress.value = withDelay(400, withTiming(1, {\r\n        duration: 900,\r\n        easing: Easing.inOut(Easing.linear),\r\n      }, (finished) => {\r\n        if (finished) {\r\n          runOnJS(navigateHome)();\r\n        }\r\n      }));\r\n\r\n      // Safety fallback: Ensure we navigate home even if animation is interrupted\r\n      const timer = setTimeout(() => {\r\n        navigateHome();\r\n      }, 1600);\r\n\r\n      return () => clearTimeout(timer);\r\n    }, [navigateHome, opacity, ringProgress, scale])\r\n  );\r\n\r\n  const cardAnimatedStyle = useAnimatedStyle(() => ({\r\n    opacity: opacity.value,\r\n    transform: [{ scale: scale.value }],\r\n  }));\r\n\r\n  const animatedCircleProps = useAnimatedProps(() => ({\r\n    strokeDashoffset: circumference * (1 - ringProgress.value),\r\n  }));\r\n\r\n  return (\r\n    <View style={[styles.container, { paddingTop: insets.top, paddingBottom: insets.bottom + sizing.tabBarHeight }]}>\r\n      <Animated.View style={[styles.messageStack, cardAnimatedStyle]}>\r\n        <Text variant=\"display1\" color=\"orange\" style={styles.successTitle}>\r\n          Great Work!\r\n        </Text>\r\n        <View style={styles.checkContainer}>\r\n          <Svg width={sizing.iconXL} height={sizing.iconXL}>\r\n            <AnimatedCircle\r\n              cx={radiusValue}\r\n              cy={radiusValue}\r\n              r={radiusValue - spacing.xxxs}\r\n              stroke={colors.accent.orange}\r\n              strokeWidth={spacing.xxs}\r\n              fill=\"none\"\r\n              strokeDasharray={`${circumference}`}\r\n              animatedProps={animatedCircleProps}\r\n              strokeLinecap=\"round\"\r\n              rotation=\"-90\"\r\n              origin={`${radiusValue}, ${radiusValue}`}\r\n            />\r\n          </Svg>\r\n          <MaterialCommunityIcons\r\n            name=\"check\"\r\n            size={sizing.iconLG}\r\n            color={colors.accent.orange}\r\n            accessibilityLabel=\"Workout complete\"\r\n            style={styles.checkIcon}\r\n          />\r\n        </View>\r\n      </Animated.View>\r\n    </View>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    flex: 1,\r\n    backgroundColor: colors.primary.bg,\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    paddingHorizontal: spacing.lg,\r\n  },\r\n  messageStack: {\r\n    width: '100%',\r\n    maxWidth: 360,\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    gap: spacing.lg,\r\n    paddingHorizontal: spacing.lg,\r\n  },\r\n  successTitle: {\r\n    textAlign: 'center',\r\n    fontSize: sizing.iconXL,\r\n    lineHeight: sizing.iconXL + spacing.sm,\r\n  },\r\n  checkContainer: {\r\n    width: sizing.iconXL,\r\n    height: sizing.iconXL,\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n  },\r\n  checkIcon: {\r\n    position: 'absolute',\r\n  },\r\n});\r\n\r\nexport default WorkoutSuccessScreen;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\babel.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\expo-env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\scripts\\reset-project.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\scripts\\update-exercise-metadata.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\scripts\\validate-exercises.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\atoms\\AccordionRow.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'rotation'. Either include it or remove the dependency array.","line":56,"column":6,"nodeType":"ArrayExpression","endLine":56,"endColumn":18,"suggestions":[{"desc":"Update the dependencies array to be: [isExpanded, rotation]","fix":{"range":[1522,1534],"text":"[isExpanded, rotation]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * AccordionRow\r\n * A single expandable row showing a muscle group with progress bar\r\n * \r\n * @param name - Muscle group name\r\n * @param percentage - Percentage of total sets (0-100)\r\n * @param isExpanded - Whether children are visible\r\n * @param hasChildren - Whether this row can expand\r\n * @param depth - Nesting level (0 = root, 1 = child, 2 = grandchild)\r\n * @param onPress - Callback when row is tapped\r\n */\r\n\r\nimport React, { useEffect } from 'react';\r\nimport { View, StyleSheet, TouchableOpacity } from 'react-native';\r\nimport Animated, {\r\n  useAnimatedStyle,\r\n  useSharedValue,\r\n  withSpring,\r\n} from 'react-native-reanimated';\r\nimport { Ionicons } from '@expo/vector-icons';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { colors, spacing, radius } from '@/constants/theme';\r\n\r\ninterface AccordionRowProps {\r\n  name: string;\r\n  percentage: number;\r\n  isExpanded: boolean;\r\n  hasChildren: boolean;\r\n  depth: number;\r\n  onPress: () => void;\r\n}\r\n\r\nconst INDENT_PER_LEVEL = spacing.md;\r\nconst BAR_HEIGHT = 8;\r\nconst MAX_BAR_WIDTH = 120;\r\n\r\nexport const AccordionRow: React.FC<AccordionRowProps> = ({\r\n  name,\r\n  percentage,\r\n  isExpanded,\r\n  hasChildren,\r\n  depth,\r\n  onPress,\r\n}) => {\r\n  // Shared value for chevron rotation\r\n  const rotation = useSharedValue(0);\r\n\r\n  // Update rotation when isExpanded changes\r\n  useEffect(() => {\r\n    rotation.value = withSpring(isExpanded ? 90 : 0, {\r\n      damping: 15,\r\n      stiffness: 150,\r\n    });\r\n  }, [isExpanded]);\r\n\r\n  const handlePress = () => {\r\n    triggerHaptic('light');\r\n    onPress();\r\n  };\r\n\r\n  // Animated chevron rotation\r\n  const chevronStyle = useAnimatedStyle(() => {\r\n    return {\r\n      transform: [{ rotate: `${rotation.value}deg` }],\r\n    };\r\n  });\r\n\r\n  // Calculate bar width based on percentage\r\n  const barWidth = Math.max(4, (percentage / 100) * MAX_BAR_WIDTH);\r\n\r\n  // Opacity based on depth for visual hierarchy\r\n  const rowOpacity = depth === 0 ? 1 : depth === 1 ? 0.9 : 0.8;\r\n\r\n  // Color intensity based on percentage\r\n  const getBarColor = () => {\r\n    if (percentage >= 30) return colors.accent.orange;\r\n    if (percentage >= 15) return colors.accent.orangeLight;\r\n    return `rgba(255, 107, 74, 0.5)`;\r\n  };\r\n\r\n  return (\r\n    <TouchableOpacity\r\n      style={[\r\n        styles.container,\r\n        { paddingLeft: spacing.md + depth * INDENT_PER_LEVEL },\r\n        { opacity: rowOpacity },\r\n      ]}\r\n      onPress={handlePress}\r\n      activeOpacity={0.7}\r\n    >\r\n      {/* Chevron or spacer */}\r\n      <View style={styles.chevronContainer}>\r\n        {hasChildren ? (\r\n          <Animated.View style={chevronStyle}>\r\n            <Ionicons\r\n              name=\"chevron-forward\"\r\n              size={16}\r\n              color={colors.text.secondary}\r\n            />\r\n          </Animated.View>\r\n        ) : (\r\n          <View style={styles.leafIndicator} />\r\n        )}\r\n      </View>\r\n\r\n      {/* Name */}\r\n      <Text\r\n        variant={depth === 0 ? 'bodySemibold' : 'body'}\r\n        color=\"primary\"\r\n        style={styles.name}\r\n        numberOfLines={1}\r\n      >\r\n        {name}\r\n      </Text>\r\n\r\n      {/* Progress bar */}\r\n      <View style={styles.barContainer}>\r\n        <View\r\n          style={[\r\n            styles.bar,\r\n            { width: barWidth, backgroundColor: getBarColor() },\r\n          ]}\r\n        />\r\n      </View>\r\n\r\n      {/* Percentage */}\r\n      <Text variant=\"caption\" color=\"secondary\" style={styles.percentage}>\r\n        {Math.round(percentage)}%\r\n      </Text>\r\n    </TouchableOpacity>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    paddingVertical: spacing.sm,\r\n    paddingRight: spacing.md,\r\n    minHeight: 44,\r\n  },\r\n  chevronContainer: {\r\n    width: 20,\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    marginRight: spacing.xs,\r\n  },\r\n  leafIndicator: {\r\n    width: 6,\r\n    height: 6,\r\n    borderRadius: radius.full,\r\n    backgroundColor: colors.neutral.gray400,\r\n  },\r\n  name: {\r\n    flex: 1,\r\n    marginRight: spacing.sm,\r\n  },\r\n  barContainer: {\r\n    width: MAX_BAR_WIDTH,\r\n    height: BAR_HEIGHT,\r\n    backgroundColor: colors.neutral.gray200,\r\n    borderRadius: radius.full,\r\n    overflow: 'hidden',\r\n    marginRight: spacing.sm,\r\n  },\r\n  bar: {\r\n    height: '100%',\r\n    borderRadius: radius.full,\r\n  },\r\n  percentage: {\r\n    width: 36,\r\n    textAlign: 'right',\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\atoms\\AnalyticsCard.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'radius' is defined but never used.","line":22,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * AnalyticsCard\r\n * Tappable card component for analytics sections that navigates to category screens\r\n * \r\n * @param title - Card header title\r\n * @param subtitle - Optional subtitle\r\n * @param onPress - Navigation callback when card is tapped\r\n * @param showChevron - Whether to show navigation chevron\r\n * @param disabled - Disable tap interaction\r\n * @param children - Card content\r\n */\r\n\r\nimport React from 'react';\r\nimport { View, StyleSheet, TouchableOpacity, Pressable } from 'react-native';\r\nimport { Ionicons } from '@expo/vector-icons';\r\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { SurfaceCard } from '@/components/atoms/SurfaceCard';\r\nimport { HorizontalAccentBar } from '@/components/atoms/HorizontalAccentBar';\r\nimport { colors, spacing, radius } from '@/constants/theme';\r\nimport { useTheme } from '@/hooks/useTheme';\r\n\r\ninterface AnalyticsCardProps {\r\n  title: string;\r\n  subtitle?: string;\r\n  onPress?: () => void;\r\n  showChevron?: boolean;\r\n  disabled?: boolean;\r\n  headerRight?: React.ReactNode;\r\n  isEmpty?: boolean;\r\n  showAccentStripe?: boolean;\r\n  titleCentered?: boolean;\r\n  showHorizontalAccentBar?: boolean;\r\n  children: React.ReactNode;\r\n}\r\n\r\nconst AnimatedTouchable = Animated.createAnimatedComponent(TouchableOpacity);\r\n\r\nexport const AnalyticsCard: React.FC<AnalyticsCardProps> = ({\r\n  title,\r\n  subtitle,\r\n  onPress,\r\n  showChevron = true,\r\n  disabled = false,\r\n  headerRight,\r\n  isEmpty = false,\r\n  showAccentStripe = true,\r\n  titleCentered = false,\r\n  showHorizontalAccentBar = false,\r\n  children,\r\n}) => {\r\n  const { theme } = useTheme();\r\n  const scale = useSharedValue(1);\r\n\r\n  const animatedStyle = useAnimatedStyle(() => ({\r\n    transform: [{ scale: scale.value }],\r\n  }));\r\n\r\n  const handlePressIn = () => {\r\n    if (!disabled && onPress) {\r\n      scale.value = withSpring(0.98, { damping: 15, stiffness: 300 });\r\n    }\r\n  };\r\n\r\n  const handlePressOut = () => {\r\n    scale.value = withSpring(1, { damping: 15, stiffness: 300 });\r\n  };\r\n\r\n  const handlePress = () => {\r\n    if (!disabled && onPress) {\r\n      triggerHaptic('light');\r\n      onPress();\r\n    }\r\n  };\r\n\r\n  const isInteractive = !disabled && onPress;\r\n\r\n  return (\r\n    <AnimatedTouchable\r\n      style={animatedStyle}\r\n      onPressIn={handlePressIn}\r\n      onPressOut={handlePressOut}\r\n      onPress={handlePress}\r\n      activeOpacity={1}\r\n      disabled={!isInteractive}\r\n    >\r\n      <SurfaceCard tone=\"neutral\" padding=\"md\" showAccentStripe={showAccentStripe}>\r\n        <View style={styles.cardContent}>\r\n          {/* Header */}\r\n          <View style={styles.header}>\r\n            <View style={[styles.headerText, titleCentered && styles.headerTextCentered]}>\r\n              <Text variant=\"heading3\" color=\"primary\">\r\n                {title}\r\n              </Text>\r\n              {showHorizontalAccentBar && <HorizontalAccentBar />}\r\n            </View>\r\n          </View>\r\n\r\n          {/* Header right content */}\r\n          {headerRight && (\r\n            <Pressable\r\n              style={styles.headerRightContainer}\r\n              onPress={(e) => e.stopPropagation()}\r\n            >\r\n              {headerRight}\r\n            </Pressable>\r\n          )}\r\n\r\n          {/* Content */}\r\n          <View style={styles.content}>\r\n            {children}\r\n          </View>\r\n\r\n          {/* Subtitle below content */}\r\n          {subtitle && !isEmpty && (\r\n            <View style={styles.subtitleRow}>\r\n              <Text variant=\"caption\" color=\"secondary\" style={styles.subtitle}>\r\n                {subtitle}\r\n              </Text>\r\n            </View>\r\n          )}\r\n\r\n          {/* Tap for details at bottom */}\r\n          {isInteractive && showChevron && (\r\n            <View style={styles.footerHint}>\r\n              <Text variant=\"caption\" color=\"secondary\" style={styles.tapHint}>\r\n                Tap for details\r\n              </Text>\r\n              <Ionicons\r\n                name=\"chevron-forward\"\r\n                size={16}\r\n                color={theme.text.tertiary}\r\n              />\r\n            </View>\r\n          )}\r\n        </View>\r\n      </SurfaceCard>\r\n    </AnimatedTouchable>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  cardContent: {\r\n    gap: spacing.md,\r\n    paddingHorizontal: spacing.lg,\r\n  },\r\n  header: {\r\n    flexDirection: 'row',\r\n    justifyContent: 'space-between',\r\n    alignItems: 'flex-start',\r\n    paddingTop: spacing.md,\r\n    paddingBottom: spacing.xs,\r\n  },\r\n  headerText: {\r\n    flex: 1,\r\n  },\r\n  headerTextCentered: {\r\n    alignItems: 'center',\r\n  },\r\n  chevronContainer: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    marginLeft: spacing.md,\r\n    paddingTop: spacing.xs,\r\n  },\r\n  tapHint: {\r\n    marginRight: spacing.xs,\r\n  },\r\n  footerHint: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    paddingTop: spacing.sm,\r\n    marginTop: spacing.sm,\r\n    borderTopWidth: 1,\r\n    borderTopColor: colors.border.light,\r\n  },\r\n  headerRightContainer: {\r\n    alignSelf: 'center',\r\n  },\r\n  subtitleRow: {\r\n    alignItems: 'center',\r\n    paddingHorizontal: spacing.lg,\r\n    marginTop: -spacing.sm,\r\n  },\r\n  subtitle: {\r\n    // Subtitle text\r\n  },\r\n  content: {\r\n    // Content area for charts/data\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\atoms\\AnimatedAccentStripe.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\atoms\\Badge.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'colors' is defined but never used.","line":4,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useMemo } from 'react';\r\nimport { StyleSheet, View, ViewStyle } from 'react-native';\r\nimport { Text } from './Text';\r\nimport { colors, radius, spacing } from '@/constants/theme';\r\nimport { useTheme } from '@/hooks/useTheme';\r\n\r\nexport type BadgeVariant = 'primary' | 'accent' | 'neutral' | 'outline' | 'success' | 'warning' | 'workout';\r\nexport type BadgeSize = 'sm' | 'md';\r\n\r\ninterface BadgeProps {\r\n  label: string;\r\n  variant?: BadgeVariant;\r\n  size?: BadgeSize;\r\n  style?: ViewStyle;\r\n}\r\n\r\nexport const Badge: React.FC<BadgeProps> = ({\r\n  label,\r\n  variant = 'neutral',\r\n  size = 'sm',\r\n  style\r\n}) => {\r\n  const { theme } = useTheme();\r\n\r\n  const getTextColor = () => {\r\n    switch (variant) {\r\n      case 'outline': return 'secondary';\r\n      case 'neutral': return 'primary';\r\n      case 'workout': return 'primary'; // overridden below\r\n      default: return 'onAccent';\r\n    }\r\n  };\r\n\r\n  const variantStyles = useMemo(() => {\r\n    switch (variant) {\r\n      case 'workout':\r\n        return {\r\n          backgroundColor: '#FFFFFF',\r\n          borderWidth: 1,\r\n          borderColor: theme.border.light,\r\n        };\r\n      case 'neutral':\r\n        return {\r\n          backgroundColor: theme.surface.elevated,\r\n          borderWidth: 1,\r\n          borderColor: theme.border.light,\r\n        };\r\n      case 'outline':\r\n        return {\r\n          backgroundColor: 'transparent',\r\n          borderWidth: 1,\r\n          borderColor: theme.border.medium,\r\n        };\r\n      case 'accent':\r\n      case 'primary':\r\n        return {\r\n          backgroundColor: theme.accent.primary,\r\n          borderWidth: 1,\r\n          borderColor: 'rgba(255, 255, 255, 0.2)',\r\n        };\r\n      case 'success':\r\n        return {\r\n          backgroundColor: theme.accent.success,\r\n          borderWidth: 1,\r\n          borderColor: 'rgba(255, 255, 255, 0.2)',\r\n        };\r\n      case 'warning':\r\n        return {\r\n          backgroundColor: theme.accent.warning,\r\n          borderWidth: 1,\r\n          borderColor: 'rgba(255, 255, 255, 0.2)',\r\n        };\r\n      default:\r\n        return {};\r\n    }\r\n  }, [variant, theme]);\r\n\r\n  const containerStyles = [\r\n    styles.container,\r\n    size === 'sm' ? styles.sizeSm : styles.sizeMd,\r\n    variantStyles,\r\n    style,\r\n  ];\r\n\r\n  return (\r\n    <View style={containerStyles}>\r\n      <Text\r\n        variant={size === 'sm' ? 'caption' : 'body'}\r\n        color={variant === 'workout' ? undefined : getTextColor()}\r\n        style={{\r\n          textTransform: 'capitalize',\r\n          ...(variant === 'workout' ? { color: '#000000' } : {})\r\n        }}\r\n      >\r\n        {label}\r\n      </Text>\r\n    </View>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    alignSelf: 'flex-start',\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n  },\r\n  sizeSm: {\r\n    paddingVertical: 2,\r\n    paddingHorizontal: spacing.sm,\r\n    borderRadius: radius.sm,\r\n  },\r\n  sizeMd: {\r\n    paddingVertical: spacing.xs,\r\n    paddingHorizontal: spacing.md,\r\n    borderRadius: radius.md,\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\atoms\\Button.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\atoms\\CalendarDayCell.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useDerivedValue' is defined but never used.","line":9,"column":54,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":69},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'spacing' is defined but never used.","line":14,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":34}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * CalendarDayCell\n * Atom representing a single day cell inside the monthly calendar grid.\n * Provides animated press feedback, haptic response, and visual states.\n */\n\nimport React, { useMemo } from 'react';\nimport { StyleProp, StyleSheet, TouchableOpacity, View, ViewStyle } from 'react-native';\nimport Animated, { useAnimatedStyle, useSharedValue, useDerivedValue, withSpring } from 'react-native-reanimated';\nimport { triggerHaptic } from '@/utils/haptics';\n\nimport { Text } from '@/components/atoms/Text';\nimport { buttonPressAnimation, springSmooth } from '@/constants/animations';\nimport { opacity, radius, spacing } from '@/constants/theme';\nimport { useTheme } from '@/hooks/useTheme';\n\ninterface CalendarDayCellProps {\n  /** ISO string for the date represented by this cell */\n  isoDate: string;\n  /** Day number displayed to the user */\n  dayLabel: string;\n  /** Whether the day belongs to the active month */\n  isCurrentMonth: boolean;\n  /** Whether the date matches today's date */\n  isToday: boolean;\n  /** Whether the date is currently selected */\n  isSelected: boolean;\n  /** Whether the day has a marker (e.g. workout logged) */\n  hasMarker?: boolean;\n  /** Callback fired when the user selects the day */\n  onSelect: (isoDate: string) => void;\n  /** Optional long press handler for contextual actions */\n  onLongPress?: (isoDate: string) => void;\n}\n\nexport const CalendarDayCell: React.FC<CalendarDayCellProps> = ({\n  isoDate,\n  dayLabel,\n  isCurrentMonth,\n  isToday,\n  isSelected,\n  hasMarker = false,\n  onSelect,\n  onLongPress,\n}) => {\n  const { theme } = useTheme();\n  const scale = useSharedValue(1);\n\n  const handlePress = () => {\n    scale.value = withSpring(0.94, springSmooth);\n    triggerHaptic('selection');\n\n    setTimeout(() => {\n      scale.value = withSpring(1, springSmooth);\n      onSelect(isoDate);\n    }, buttonPressAnimation.duration);\n  };\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  const showMarkerFill = hasMarker && !isSelected;\n  const showSelectedTodayMarkerFill = hasMarker && isSelected && isToday;\n\n  const dayContainerStyle = useMemo<StyleProp<ViewStyle>>(() => {\n    const states: ViewStyle[] = [\n      styles.dayContainer,\n      { backgroundColor: theme.surface.elevated, borderColor: theme.border.light },\n    ];\n\n    if (isToday) {\n      states.push({ borderColor: theme.accent.orange });\n    }\n\n    if (showMarkerFill) {\n      states.push({ backgroundColor: theme.accent.orange, borderColor: theme.accent.orange });\n    }\n\n    if (isSelected) {\n      // Selected always has muted orange fill and orange outline\n      states.push({\n        backgroundColor: theme.accent.orangeMuted,\n        borderColor: theme.accent.orange\n      });\n    }\n\n    if (!isCurrentMonth) {\n      states.push(styles.outsideMonthDay);\n    }\n\n    return states;\n  }, [isCurrentMonth, isSelected, isToday, showMarkerFill, theme]);\n\n  const textColor = useMemo(() => {\n    if (!isCurrentMonth) {\n      return 'tertiary';\n    }\n\n    // Selected always uses primary text now because background is tinted, not solid orange\n    if (isSelected) {\n      return 'primary';\n    }\n\n    if (showMarkerFill || showSelectedTodayMarkerFill) {\n      return 'onAccent';\n    }\n\n    return 'primary';\n  }, [isCurrentMonth, isSelected, showMarkerFill, showSelectedTodayMarkerFill]);\n\n  const todayLabelStyle = useMemo(() => {\n    if (isToday && !showMarkerFill && !showSelectedTodayMarkerFill && !isSelected) {\n      return styles.todayLabelText;\n    }\n\n    return undefined;\n  }, [isToday, showMarkerFill, showSelectedTodayMarkerFill, isSelected]);\n\n  const dayContent = (\n    <View style={dayContainerStyle}>\n      <Text\n        variant=\"bodySemibold\"\n        color={textColor}\n        style={todayLabelStyle}\n      >\n        {dayLabel}\n      </Text>\n    </View>\n  );\n\n  return (\n    <Animated.View style={[styles.wrapper, animatedStyle]}>\n      <TouchableOpacity\n        activeOpacity={0.9}\n        onPress={handlePress}\n        onLongPress={\n          onLongPress\n            ? () => {\n              triggerHaptic('medium');\n              onLongPress(isoDate);\n            }\n            : undefined\n        }\n        delayLongPress={150}\n        style={styles.touchable}\n      >\n        {dayContent}\n      </TouchableOpacity>\n    </Animated.View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  wrapper: {\n    width: '100%',\n    alignItems: 'center',\n  },\n  touchable: {\n    width: '100%',\n    aspectRatio: 1,\n    alignItems: 'stretch',\n  },\n  dayContainer: {\n    flex: 1,\n    alignSelf: 'stretch',\n    borderRadius: radius.md,\n    justifyContent: 'center',\n    alignItems: 'center',\n    gap: 0,\n    borderWidth: 1,\n    overflow: 'hidden',\n  },\n  outsideMonthDay: {\n    opacity: opacity.tertiary,\n  },\n  todayLabelText: {\n    // Dynamic color applied inline\n  },\n});\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\atoms\\ChartWrapper.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\atoms\\FilterChip.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'View' is defined but never used.","line":6,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":37}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * FilterChip\r\n * Atom component for displaying active filters with remove functionality\r\n */\r\nimport React, { useCallback } from 'react';\r\nimport { Pressable, StyleSheet, View } from 'react-native';\r\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { IconSymbol } from '@/components/ui/icon-symbol';\r\nimport { colors, radius, spacing, sizing } from '@/constants/theme';\r\nimport { springBouncy, buttonPressAnimation } from '@/constants/animations';\r\n\r\ninterface FilterChipProps {\r\n  label: string;\r\n  onRemove: () => void;\r\n  testID?: string;\r\n}\r\n\r\nexport const FilterChip: React.FC<FilterChipProps> = ({ label, onRemove, testID }) => {\r\n  const scale = useSharedValue(1);\r\n\r\n  const animatedStyle = useAnimatedStyle(() => ({\r\n    transform: [{ scale: scale.value }],\r\n  }));\r\n\r\n  const handlePress = useCallback(() => {\r\n    triggerHaptic('selection');\r\n    scale.value = withSpring(0.95, springBouncy);\r\n\r\n    setTimeout(() => {\r\n      scale.value = withSpring(1, springBouncy);\r\n      onRemove();\r\n    }, buttonPressAnimation.duration);\r\n  }, [onRemove, scale]);\r\n\r\n  return (\r\n    <Animated.View style={[styles.wrapper, animatedStyle]}>\r\n      <Pressable\r\n        accessibilityRole=\"button\"\r\n        accessibilityLabel={`Remove ${label} filter`}\r\n        style={styles.chip}\r\n        onPress={handlePress}\r\n        testID={testID}\r\n      >\r\n        <Text variant=\"caption\" color=\"primary\">\r\n          {label}\r\n        </Text>\r\n        <IconSymbol name=\"close\" color={colors.text.primary} size={sizing.iconXS} />\r\n      </Pressable>\r\n    </Animated.View>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  wrapper: {\r\n    borderRadius: radius.full,\r\n  },\r\n  chip: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    gap: spacing.xxs,\r\n    borderRadius: radius.full,\r\n    borderWidth: 1,\r\n    borderColor: colors.border.light,\r\n    backgroundColor: colors.surface.subtle,\r\n    paddingVertical: spacing.xs,\r\n    paddingLeft: spacing.md,\r\n    paddingRight: spacing.sm,\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\atoms\\GradientText.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\atoms\\HoldRepeatIconButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\atoms\\HorizontalAccentBar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\atoms\\InputField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\atoms\\PremiumLock.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\atoms\\QuickAddChip.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\atoms\\QuickFilterChip.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\atoms\\SurfaceCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\atoms\\Text.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'StyleSheet' is defined but never used.","line":11,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":13}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Text Component\n * Themed text with variants, colors, and fade-in animations\n * Supports heading1-3, body, caption variants\n */\n\nimport React, { useEffect } from 'react';\nimport {\n  Text as RNText,\n  TextProps,\n  StyleSheet,\n} from 'react-native';\nimport Animated, {\n  useSharedValue,\n  useAnimatedStyle,\n  withTiming,\n  Easing,\n} from 'react-native-reanimated';\n\nimport { typography } from '@/constants/theme';\nimport { useTheme } from '@/hooks/useTheme';\nimport { textFadeInAnimation } from '@/constants/animations';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\ntype TextVariant =\n  | 'display1'\n  | 'heading1'\n  | 'heading2'\n  | 'heading3'\n  | 'heading4'\n  | 'label'\n  | 'labelMedium'\n  | 'statValue'\n  | 'captionMedium'\n  | 'body'\n  | 'bodySemibold'\n  | 'caption'\n  | 'captionSmall';\ntype TextColor =\n  | 'primary'\n  | 'secondary'\n  | 'tertiary'\n  | 'neutral'\n  | 'orange'\n  | 'red'\n  | 'success'\n  | 'warning'\n  | 'onAccent';\n\ninterface TextComponentProps extends TextProps {\n  /** Text variant (heading, body, caption) */\n  variant?: TextVariant;\n  /** Text color */\n  color?: TextColor;\n  /** Fade in animation on mount */\n  fadeIn?: boolean;\n  /** Animation delay (ms) */\n  delay?: number;\n}\n\n// ============================================================================\n// COMPONENT\n// ============================================================================\n\nexport const Text: React.FC<TextComponentProps> = ({\n  variant = 'body',\n  color = 'primary',\n  fadeIn = false,\n  delay = 0,\n  children,\n  style,\n  ...props\n}) => {\n  const { theme } = useTheme();\n  const opacity = useSharedValue(fadeIn ? 0 : 1);\n\n  // Fade-in animation on mount\n  useEffect(() => {\n    if (fadeIn) {\n      opacity.value = withTiming(1, {\n        duration: textFadeInAnimation.duration,\n        easing: Easing.out(Easing.ease),\n      });\n    }\n  }, [fadeIn, opacity]);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    opacity: opacity.value,\n  }));\n\n  // Get typography style and cast fontWeight properly\n  const typographyStyle = {\n    ...typography[variant],\n    fontWeight: typography[variant].fontWeight as any,\n  };\n\n  // Get color based on current theme\n  const colorMap: Record<TextColor, string> = {\n    primary: theme.text.primary,\n    secondary: theme.text.secondary,\n    tertiary: theme.text.tertiary,\n    neutral: theme.neutral.gray600,\n    orange: theme.accent.orange,\n    red: theme.accent.red,\n    success: theme.accent.success,\n    warning: theme.accent.warning,\n    onAccent: theme.text.onAccent,\n  };\n\n  const textColor = colorMap[color];\n\n  const textStyle = [\n    typographyStyle,\n    { color: textColor },\n    style,\n  ];\n\n  return (\n    <Animated.View style={animatedStyle}>\n      <RNText style={textStyle} {...props}>\n        {children}\n      </RNText>\n    </Animated.View>\n  );\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\atoms\\TimeRangeSelector.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useDerivedValue' is defined but never used.","line":9,"column":54,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":69}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * TimeRangeSelector\r\n * Pill-style buttons for selecting time ranges (Week, Month, Year, All Time)\r\n * Used in analytics cards and pages for filtering data by time period\r\n */\r\n\r\nimport React, { useCallback } from 'react';\r\nimport { View, Pressable, StyleSheet } from 'react-native';\r\nimport Animated, { useAnimatedStyle, useSharedValue, useDerivedValue, withSpring } from 'react-native-reanimated';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { colors, spacing, radius } from '@/constants/theme';\r\nimport { springBouncy, buttonPressAnimation } from '@/constants/animations';\r\nimport { TimeRange, TIME_RANGE_LABELS } from '@/types/analytics';\r\n\r\ninterface TimeRangeSelectorProps {\r\n  value: TimeRange;\r\n  onChange: (range: TimeRange) => void;\r\n}\r\n\r\nconst TIME_RANGES: TimeRange[] = ['week', 'month', 'year', 'all'];\r\n\r\ninterface TimeRangeChipProps {\r\n  label: string;\r\n  active: boolean;\r\n  onPress: () => void;\r\n}\r\n\r\nconst TimeRangeChip: React.FC<TimeRangeChipProps> = ({ label, active, onPress }) => {\r\n  const scale = useSharedValue(1);\r\n\r\n  const animatedStyle = useAnimatedStyle(() => ({\r\n    transform: [{ scale: scale.value }],\r\n  }));\r\n\r\n  const handlePress = useCallback(() => {\r\n    triggerHaptic('selection');\r\n    scale.value = withSpring(0.95, springBouncy);\r\n\r\n    setTimeout(() => {\r\n      scale.value = withSpring(1, springBouncy);\r\n      onPress();\r\n    }, buttonPressAnimation.duration);\r\n  }, [onPress, scale]);\r\n\r\n  return (\r\n    <Animated.View style={[styles.chipWrapper, animatedStyle]}>\r\n      <Pressable\r\n        accessibilityRole=\"button\"\r\n        accessibilityState={{ selected: active }}\r\n        style={[styles.chip, active && styles.chipActive]}\r\n        onPress={handlePress}\r\n      >\r\n        <Text variant=\"caption\" color={active ? 'primary' : 'secondary'}>\r\n          {label}\r\n        </Text>\r\n      </Pressable>\r\n    </Animated.View>\r\n  );\r\n};\r\n\r\nexport const TimeRangeSelector: React.FC<TimeRangeSelectorProps> = ({\r\n  value,\r\n  onChange,\r\n}) => {\r\n  return (\r\n    <View style={styles.container}>\r\n      {TIME_RANGES.map((range) => (\r\n        <TimeRangeChip\r\n          key={range}\r\n          label={TIME_RANGE_LABELS[range]}\r\n          active={range === value}\r\n          onPress={() => onChange(range)}\r\n        />\r\n      ))}\r\n    </View>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    flexDirection: 'row',\r\n    gap: spacing.xs,\r\n  },\r\n  chipWrapper: {\r\n    borderRadius: radius.full,\r\n  },\r\n  chip: {\r\n    borderRadius: radius.full,\r\n    borderWidth: 1,\r\n    borderColor: colors.accent.orangeMuted,\r\n    backgroundColor: colors.surface.card,\r\n    paddingVertical: spacing.xs,\r\n    paddingHorizontal: spacing.sm,\r\n  },\r\n  chipActive: {\r\n    backgroundColor: colors.accent.orangeMuted,\r\n    borderColor: colors.accent.orange,\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\atoms\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\ActionApprovalCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\AddExercisesHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\AddExercisesSearchCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\AddOverrideModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'IconSymbol' is defined but never used.","line":8,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useCallback, useMemo } from 'react';\r\nimport { View, StyleSheet, Pressable, ScrollView } from 'react-native';\r\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { Button } from '@/components/atoms/Button';\r\nimport { IconSymbol } from '@/components/ui/icon-symbol';\r\nimport { useActiveScheduleStore } from '@/store/activeScheduleStore';\r\nimport { useProgramsStore } from '@/store/programsStore';\r\nimport { usePlansStore } from '@/store/plansStore';\r\nimport { useTheme } from '@/hooks/useTheme';\r\nimport { spacing, radius, colors } from '@/constants/theme';\r\nimport type { ScheduleOverride } from '@/types/activeSchedule';\r\nimport { SheetModal } from './SheetModal';\r\n\r\ninterface AddOverrideModalProps {\r\n  visible: boolean;\r\n  onClose: () => void;\r\n  editingOverride?: ScheduleOverride | null;\r\n}\r\n\r\nconst getNextSevenDays = (): { date: string; label: string; isToday: boolean }[] => {\r\n  const days: { date: string; label: string; isToday: boolean }[] = [];\r\n  const today = new Date();\r\n\r\n  for (let i = 0; i < 7; i++) {\r\n    const d = new Date(today);\r\n    d.setDate(today.getDate() + i);\r\n\r\n    const year = d.getFullYear();\r\n    const month = String(d.getMonth() + 1).padStart(2, '0');\r\n    const day = String(d.getDate()).padStart(2, '0');\r\n    const dateStr = `${year}-${month}-${day}`;\r\n\r\n    let label: string;\r\n    if (i === 0) {\r\n      label = 'Today';\r\n    } else if (i === 1) {\r\n      label = 'Tomorrow';\r\n    } else {\r\n      label = d.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });\r\n    }\r\n\r\n    days.push({ date: dateStr, label, isToday: i === 0 });\r\n  }\r\n\r\n  return days;\r\n};\r\n\r\nexport const AddOverrideModal: React.FC<AddOverrideModalProps> = ({\r\n  visible,\r\n  onClose,\r\n  editingOverride,\r\n}) => {\r\n  const insets = useSafeAreaInsets();\r\n  const { theme } = useTheme();\r\n  const addOverride = useActiveScheduleStore((state) => state.addOverride);\r\n  const removeOverride = useActiveScheduleStore((state) => state.removeOverride);\r\n  const overrides = useActiveScheduleStore((state) => state.state.overrides);\r\n\r\n  const userPrograms = useProgramsStore((state) => state.userPrograms);\r\n  const plans = usePlansStore((state) => state.plans);\r\n\r\n  const [selectedDate, setSelectedDate] = useState<string | null>(\r\n    editingOverride?.date || null\r\n  );\r\n  const [selectedWorkoutId, setSelectedWorkoutId] = useState<string | null>(\r\n    editingOverride?.workoutId ?? null\r\n  );\r\n  const [isRest, setIsRest] = useState<boolean>(\r\n    editingOverride ? editingOverride.workoutId === null : false\r\n  );\r\n\r\n  const nextSevenDays = useMemo(() => getNextSevenDays(), []);\r\n\r\n  const allWorkouts = useMemo(() => {\r\n    const workouts: { id: string; name: string; source: string }[] = [];\r\n\r\n    userPrograms.forEach((program) => {\r\n      program.workouts.forEach((w) => {\r\n        if (w.exercises.length > 0) {\r\n          workouts.push({ id: w.id, name: w.name, source: program.name });\r\n        }\r\n      });\r\n    });\r\n\r\n    plans.forEach((plan) => {\r\n      workouts.push({ id: plan.id, name: plan.name, source: 'Custom' });\r\n    });\r\n\r\n    return workouts;\r\n  }, [userPrograms, plans]);\r\n\r\n  const existingOverrideDates = useMemo(() => {\r\n    return new Set(overrides.map((o) => o.date));\r\n  }, [overrides]);\r\n\r\n  const handleDateSelect = useCallback((date: string) => {\r\n    triggerHaptic('selection');\r\n    setSelectedDate(date);\r\n\r\n    // If this date has an existing override, load it for editing\r\n    const existingOverride = overrides.find(o => o.date === date);\r\n    if (existingOverride) {\r\n      setSelectedWorkoutId(existingOverride.workoutId);\r\n      setIsRest(existingOverride.workoutId === null);\r\n    } else {\r\n      setSelectedWorkoutId(null);\r\n      setIsRest(false);\r\n    }\r\n  }, [overrides]);\r\n\r\n  const handleWorkoutSelect = useCallback((workoutId: string | null) => {\r\n    triggerHaptic('selection');\r\n    if (workoutId === null) {\r\n      setIsRest(true);\r\n      setSelectedWorkoutId(null);\r\n    } else {\r\n      setIsRest(false);\r\n      setSelectedWorkoutId(workoutId);\r\n    }\r\n  }, []);\r\n\r\n  const handleSave = useCallback(async () => {\r\n    triggerHaptic('success');\r\n\r\n    if (!selectedDate) return;\r\n\r\n    const override: ScheduleOverride = {\r\n      date: selectedDate,\r\n      workoutId: isRest ? null : selectedWorkoutId,\r\n    };\r\n\r\n    await addOverride(override);\r\n    onClose();\r\n  }, [selectedDate, selectedWorkoutId, isRest, addOverride, onClose]);\r\n\r\n  const handleRemove = useCallback(async () => {\r\n    if (!selectedDate) return;\r\n\r\n    triggerHaptic('warning');\r\n    await removeOverride(selectedDate);\r\n    onClose();\r\n  }, [selectedDate, removeOverride, onClose]);\r\n\r\n  const handleClose = useCallback(() => {\r\n    triggerHaptic('selection');\r\n    setSelectedDate(null);\r\n    setSelectedWorkoutId(null);\r\n    setIsRest(false);\r\n    onClose();\r\n  }, [onClose]);\r\n\r\n  const canSave = selectedDate !== null;\r\n  const isEditing = selectedDate && overrides.find(o => o.date === selectedDate);\r\n\r\n  return (\r\n    <SheetModal\r\n      visible={visible}\r\n      onClose={handleClose}\r\n      title={isEditing ? 'Edit Override' : 'Add Override'}\r\n    >\r\n      <ScrollView style={styles.content} showsVerticalScrollIndicator={false}>\r\n        <View style={styles.section}>\r\n          <Text variant=\"bodySemibold\" color=\"primary\">\r\n            Select Date\r\n          </Text>\r\n          <View style={styles.dateGrid}>\r\n            {nextSevenDays.map(({ date, label, isToday }) => {\r\n              const isSelected = selectedDate === date;\r\n              const hasExistingOverride = existingOverrideDates.has(date);\r\n\r\n              return (\r\n                <Pressable\r\n                  key={date}\r\n                  style={[\r\n                    styles.dateChip,\r\n                    { backgroundColor: theme.surface.elevated },\r\n                    isSelected && { backgroundColor: theme.accent.orange },\r\n                    hasExistingOverride && !isSelected && { backgroundColor: theme.accent.warning + '20' },\r\n                  ]}\r\n                  onPress={() => handleDateSelect(date)}\r\n                >\r\n                  <Text\r\n                    variant=\"caption\"\r\n                    color={isSelected ? 'onAccent' : 'primary'}\r\n                  >\r\n                    {label}\r\n                  </Text>\r\n                  {hasExistingOverride && (\r\n                    <Text variant=\"captionSmall\" color=\"tertiary\">\r\n                      (has override)\r\n                    </Text>\r\n                  )}\r\n                </Pressable>\r\n              );\r\n            })}\r\n          </View>\r\n        </View>\r\n\r\n        <View style={styles.section}>\r\n          <Text variant=\"bodySemibold\" color=\"primary\">\r\n            What to Schedule\r\n          </Text>\r\n\r\n          <Pressable\r\n            style={[\r\n              styles.optionCard,\r\n              { backgroundColor: theme.surface.elevated },\r\n              isRest && { borderColor: theme.accent.orange, borderWidth: 2 },\r\n            ]}\r\n            onPress={() => handleWorkoutSelect(null)}\r\n          >\r\n            <View style={styles.optionContent}>\r\n              <Text variant=\"bodySemibold\" color=\"primary\">\r\n                Rest\r\n              </Text>\r\n            </View>\r\n          </Pressable>\r\n\r\n          <View style={styles.workoutList}>\r\n            {allWorkouts.map((workout) => {\r\n              const isSelected = !isRest && selectedWorkoutId === workout.id;\r\n\r\n              return (\r\n                <Pressable\r\n                  key={workout.id}\r\n                  style={[\r\n                    styles.optionCard,\r\n                    { backgroundColor: theme.surface.elevated },\r\n                    isSelected && { borderColor: theme.accent.orange, borderWidth: 2 },\r\n                  ]}\r\n                  onPress={() => handleWorkoutSelect(workout.id)}\r\n                >\r\n                  <View style={styles.optionContent}>\r\n                    <Text variant=\"bodySemibold\" color=\"primary\">\r\n                      {workout.name}\r\n                    </Text>\r\n                  </View>\r\n                </Pressable>\r\n              );\r\n            })}\r\n          </View>\r\n        </View>\r\n      </ScrollView>\r\n\r\n      <View style={[styles.footer, { paddingBottom: spacing.sm + insets.bottom }]}>\r\n        {isEditing && (\r\n          <Button\r\n            label=\"Remove Override\"\r\n            variant=\"ghost\"\r\n            size=\"md\"\r\n            onPress={handleRemove}\r\n            textColor={colors.accent.warning}\r\n            style={styles.removeButton}\r\n          />\r\n        )}\r\n        <Button\r\n          label={isEditing ? 'Update' : 'Add Override'}\r\n          variant=\"primary\"\r\n          size=\"lg\"\r\n          onPress={handleSave}\r\n          disabled={!canSave}\r\n        />\r\n      </View>\r\n    </SheetModal>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  content: {\r\n    padding: spacing.lg,\r\n    paddingBottom: spacing.md,\r\n  },\r\n  section: {\r\n    marginBottom: spacing.xl,\r\n    gap: spacing.sm,\r\n  },\r\n  dateGrid: {\r\n    flexDirection: 'row',\r\n    flexWrap: 'wrap',\r\n    gap: spacing.sm,\r\n  },\r\n  dateChip: {\r\n    paddingHorizontal: spacing.md,\r\n    paddingVertical: spacing.sm,\r\n    borderRadius: radius.md,\r\n    alignItems: 'center',\r\n    borderWidth: 1,\r\n    borderColor: colors.accent.orange,\r\n  },\r\n  optionCard: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    padding: spacing.md,\r\n    borderRadius: radius.lg,\r\n    borderWidth: 1,\r\n    borderColor: colors.accent.orange,\r\n    gap: spacing.md,\r\n  },\r\n  optionContent: {\r\n    flex: 1,\r\n  },\r\n  workoutList: {\r\n    gap: spacing.sm,\r\n  },\r\n  footer: {\r\n    padding: spacing.md,\r\n    borderTopWidth: StyleSheet.hairlineWidth,\r\n    borderTopColor: colors.border.light,\r\n    gap: spacing.sm,\r\n  },\r\n  removeButton: {\r\n    alignSelf: 'center',\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\AppearanceModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\BalanceScoreCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\BodyMetricsModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\CardioGoalModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ScrollView' is defined but never used.","line":7,"column":46,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":56}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * CardioGoalModal\r\n * Modal for setting weekly cardio time or distance goals.\r\n * Features numpad input similar to TimePickerModal with preset suggestions.\r\n */\r\nimport React, { useCallback, useEffect, useState } from 'react';\r\nimport { Modal, Pressable, StyleSheet, View, ScrollView } from 'react-native';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\nimport { MaterialCommunityIcons } from '@expo/vector-icons';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { colors, radius, spacing, sizing } from '@/constants/theme';\r\nimport { useTheme } from '@/hooks/useTheme';\r\nimport { useSettingsStore } from '@/store/settingsStore';\r\n\r\nexport type CardioGoalType = 'time' | 'distance';\r\n\r\ninterface CardioGoalModalProps {\r\n  visible: boolean;\r\n  onClose: () => void;\r\n  goalType: CardioGoalType;\r\n}\r\n\r\n// Preset suggestions for time goals (in minutes)\r\nconst TIME_PRESETS = [\r\n  { label: '75 min', value: 75 * 60 }, // 75 minutes in seconds\r\n  { label: '150 min', value: 150 * 60 }, // WHO recommendation\r\n  { label: '300 min', value: 300 * 60 }, // Extended goal\r\n];\r\n\r\n// Preset suggestions for distance goals (in miles)\r\nconst DISTANCE_PRESETS = [\r\n  { label: '5 mi', value: 5 },\r\n  { label: '10 mi', value: 10 },\r\n  { label: '20 mi', value: 20 },\r\n];\r\n\r\nconst formatTimeDigits = (value: number, length: number = 2): string => {\r\n  return value.toString().padStart(length, '0');\r\n};\r\n\r\nexport const CardioGoalModal: React.FC<CardioGoalModalProps> = ({\r\n  visible,\r\n  onClose,\r\n  goalType,\r\n}) => {\r\n  const { theme, isDarkMode } = useTheme();\r\n  const {\r\n    weeklyCardioTimeGoal,\r\n    weeklyCardioDistanceGoal,\r\n    setWeeklyCardioTimeGoal,\r\n    setWeeklyCardioDistanceGoal,\r\n    distanceUnit,\r\n    convertDistance,\r\n    convertDistanceToMiles,\r\n  } = useSettingsStore();\r\n\r\n  const [digits, setDigits] = useState<string>('');\r\n\r\n  // Initialize digits based on goal type and existing value\r\n  useEffect(() => {\r\n    if (visible) {\r\n      if (goalType === 'time') {\r\n        if (weeklyCardioTimeGoal && weeklyCardioTimeGoal > 0) {\r\n          const hours = Math.floor(weeklyCardioTimeGoal / 3600);\r\n          const mins = Math.floor((weeklyCardioTimeGoal % 3600) / 60);\r\n          const totalDigits = `${formatTimeDigits(hours)}${formatTimeDigits(mins)}`;\r\n          setDigits(totalDigits.replace(/^0+/, '') || '');\r\n        } else {\r\n          setDigits('');\r\n        }\r\n      } else {\r\n        if (weeklyCardioDistanceGoal && weeklyCardioDistanceGoal > 0) {\r\n          // Convert from miles to user's display unit\r\n          const displayValue = convertDistance(weeklyCardioDistanceGoal);\r\n          // Remove decimal point and trailing zeros for whole numbers\r\n          const valueStr = displayValue % 1 === 0 \r\n            ? displayValue.toFixed(0) \r\n            : displayValue.toFixed(1).replace('.', '');\r\n          setDigits(valueStr.replace(/^0+/, '') || '');\r\n        } else {\r\n          setDigits('');\r\n        }\r\n      }\r\n    }\r\n  }, [visible, goalType, weeklyCardioTimeGoal, weeklyCardioDistanceGoal, convertDistance, distanceUnit]);\r\n\r\n  const parseTimeDigits = useCallback((inputDigits: string) => {\r\n    const padded = inputDigits.padStart(4, '0');\r\n    const hours = parseInt(padded.slice(0, 2), 10) || 0;\r\n    const mins = parseInt(padded.slice(2, 4), 10) || 0;\r\n    return { hours, mins };\r\n  }, []);\r\n\r\n  const parseDistanceDigits = useCallback((inputDigits: string) => {\r\n    if (!inputDigits) return 0;\r\n    // Last digit is decimal, rest is whole number\r\n    if (inputDigits.length === 1) {\r\n      return parseInt(inputDigits, 10) || 0;\r\n    }\r\n    const whole = parseInt(inputDigits.slice(0, -1), 10) || 0;\r\n    const decimal = parseInt(inputDigits.slice(-1), 10) || 0;\r\n    return whole + decimal / 10;\r\n  }, []);\r\n\r\n  const handleDigitPress = useCallback((digit: string) => {\r\n    triggerHaptic('selection');\r\n    setDigits((prev) => {\r\n      const maxLength = goalType === 'time' ? 4 : 4; // HHMM for time, XX.X for distance\r\n      if (prev.length >= maxLength) {\r\n        return prev;\r\n      }\r\n      return prev + digit;\r\n    });\r\n  }, [goalType]);\r\n\r\n  const handleBackspace = useCallback(() => {\r\n    triggerHaptic('selection');\r\n    setDigits((prev) => prev.slice(0, -1));\r\n  }, []);\r\n\r\n  const handlePresetPress = useCallback((value: number) => {\r\n    triggerHaptic('selection');\r\n    if (goalType === 'time') {\r\n      setWeeklyCardioTimeGoal(value);\r\n    } else {\r\n      setWeeklyCardioDistanceGoal(value);\r\n    }\r\n    onClose();\r\n  }, [goalType, setWeeklyCardioTimeGoal, setWeeklyCardioDistanceGoal, onClose]);\r\n\r\n  const handleConfirm = useCallback(() => {\r\n    triggerHaptic('success');\r\n    if (goalType === 'time') {\r\n      const { hours, mins } = parseTimeDigits(digits);\r\n      const totalSeconds = hours * 3600 + Math.min(mins, 59) * 60;\r\n      setWeeklyCardioTimeGoal(totalSeconds > 0 ? totalSeconds : null);\r\n    } else {\r\n      const displayValue = parseDistanceDigits(digits);\r\n      // Convert from display unit back to miles for storage\r\n      const milesValue = convertDistanceToMiles(displayValue);\r\n      setWeeklyCardioDistanceGoal(milesValue > 0 ? milesValue : null);\r\n    }\r\n    onClose();\r\n  }, [digits, goalType, parseTimeDigits, parseDistanceDigits, setWeeklyCardioTimeGoal, setWeeklyCardioDistanceGoal, convertDistanceToMiles, onClose]);\r\n\r\n  const handleClear = useCallback(() => {\r\n    triggerHaptic('selection');\r\n    if (goalType === 'time') {\r\n      setWeeklyCardioTimeGoal(null);\r\n    } else {\r\n      setWeeklyCardioDistanceGoal(null);\r\n    }\r\n    onClose();\r\n  }, [goalType, setWeeklyCardioTimeGoal, setWeeklyCardioDistanceGoal, onClose]);\r\n\r\n  const handleCancel = useCallback(() => {\r\n    triggerHaptic('selection');\r\n    onClose();\r\n  }, [onClose]);\r\n\r\n  // Render display based on goal type\r\n  const renderDisplay = () => {\r\n    if (goalType === 'time') {\r\n      const { hours, mins } = parseTimeDigits(digits);\r\n      return (\r\n        <View style={styles.timeDisplay}>\r\n          {digits.length > 2 && (\r\n            <View style={styles.timeSegment}>\r\n              <Text style={[styles.timeValue, dynamicStyles.timeValue]}>\r\n                {formatTimeDigits(hours)}\r\n              </Text>\r\n              <Text style={[styles.timeLabel, dynamicStyles.timeLabel]}>h</Text>\r\n            </View>\r\n          )}\r\n          <View style={styles.timeSegment}>\r\n            <Text style={[styles.timeValue, dynamicStyles.timeValue]}>\r\n              {formatTimeDigits(mins > 59 ? 59 : mins)}\r\n            </Text>\r\n            <Text style={[styles.timeLabel, dynamicStyles.timeLabel]}>m</Text>\r\n          </View>\r\n        </View>\r\n      );\r\n    } else {\r\n      const displayValue = parseDistanceDigits(digits);\r\n      const unitLabel = distanceUnit === 'km' ? 'km' : 'mi';\r\n      return (\r\n        <View style={styles.timeDisplay}>\r\n          <View style={styles.timeSegment}>\r\n            <Text style={[styles.timeValue, dynamicStyles.timeValue]}>\r\n              {displayValue.toFixed(1)}\r\n            </Text>\r\n            <Text style={[styles.timeLabel, dynamicStyles.timeLabel]}>{unitLabel}</Text>\r\n          </View>\r\n        </View>\r\n      );\r\n    }\r\n  };\r\n\r\n  const numpadButtons = [\r\n    ['1', '2', '3'],\r\n    ['4', '5', '6'],\r\n    ['7', '8', '9'],\r\n    ['clear', '0', 'backspace'],\r\n  ];\r\n\r\n  const presets = goalType === 'time' ? TIME_PRESETS : DISTANCE_PRESETS;\r\n  const displayPresets = goalType === 'distance' && distanceUnit === 'km'\r\n    ? DISTANCE_PRESETS.map(p => ({\r\n        label: `${convertDistance(p.value).toFixed(0)} km`,\r\n        value: p.value,\r\n      }))\r\n    : presets;\r\n\r\n  const dynamicStyles = {\r\n    modalContent: {\r\n      backgroundColor: isDarkMode ? theme.surface.card : colors.surface.card,\r\n    },\r\n    numpadButton: {\r\n      backgroundColor: isDarkMode ? theme.surface.elevated : colors.neutral.gray200,\r\n    },\r\n    timeValue: {\r\n      color: isDarkMode ? theme.text.primary : colors.text.primary,\r\n    },\r\n    timeLabel: {\r\n      color: isDarkMode ? theme.text.secondary : colors.text.secondary,\r\n    },\r\n    presetButton: {\r\n      backgroundColor: isDarkMode ? theme.surface.elevated : colors.neutral.gray200,\r\n      borderColor: theme.accent.orangeMuted,\r\n    },\r\n  };\r\n\r\n  return (\r\n    <Modal\r\n      visible={visible}\r\n      transparent\r\n      animationType=\"fade\"\r\n      onRequestClose={onClose}\r\n    >\r\n      <View style={styles.overlay}>\r\n        <Pressable style={styles.backdrop} onPress={onClose} />\r\n        <View style={[styles.modalContent, dynamicStyles.modalContent]}>\r\n          <Text variant=\"bodySemibold\" color=\"secondary\" style={styles.title}>\r\n            {goalType === 'time' ? 'Set Weekly Time Goal' : 'Set Weekly Distance Goal'}\r\n          </Text>\r\n\r\n          {renderDisplay()}\r\n\r\n          {/* Preset suggestions */}\r\n          <View style={styles.presetsContainer}>\r\n            <Text variant=\"caption\" color=\"secondary\" style={styles.presetsLabel}>\r\n              Quick presets\r\n            </Text>\r\n            <View style={styles.presetsRow}>\r\n              {displayPresets.map((preset) => (\r\n                <Pressable\r\n                  key={preset.label}\r\n                  style={[styles.presetButton, dynamicStyles.presetButton]}\r\n                  onPress={() => handlePresetPress(preset.value)}\r\n                >\r\n                  <Text variant=\"bodySemibold\" color=\"primary\">\r\n                    {preset.label}\r\n                  </Text>\r\n                </Pressable>\r\n              ))}\r\n            </View>\r\n          </View>\r\n\r\n          <View style={styles.numpad}>\r\n            {numpadButtons.map((row, rowIndex) => (\r\n              <View key={rowIndex} style={styles.numpadRow}>\r\n                {row.map((button) => (\r\n                  <Pressable\r\n                    key={button}\r\n                    style={[styles.numpadButton, dynamicStyles.numpadButton]}\r\n                    onPress={() => {\r\n                      if (button === 'backspace') {\r\n                        handleBackspace();\r\n                      } else if (button === 'clear') {\r\n                        handleClear();\r\n                      } else {\r\n                        handleDigitPress(button);\r\n                      }\r\n                    }}\r\n                    accessibilityLabel={button === 'backspace' ? 'Delete' : button === 'clear' ? 'Clear goal' : button}\r\n                  >\r\n                    {button === 'backspace' ? (\r\n                      <MaterialCommunityIcons\r\n                        name=\"backspace-outline\"\r\n                        size={sizing.iconMD}\r\n                        color={isDarkMode ? theme.text.primary : colors.text.primary}\r\n                      />\r\n                    ) : button === 'clear' ? (\r\n                      <Text variant=\"body\" color=\"secondary\">\r\n                        Clear\r\n                      </Text>\r\n                    ) : (\r\n                      <Text variant=\"heading2\" color=\"primary\">\r\n                        {button}\r\n                      </Text>\r\n                    )}\r\n                  </Pressable>\r\n                ))}\r\n              </View>\r\n            ))}\r\n          </View>\r\n\r\n          <View style={styles.actions}>\r\n            <Pressable style={styles.actionButton} onPress={handleCancel}>\r\n              <Text variant=\"bodySemibold\" style={{ color: colors.accent.orange }}>\r\n                Cancel\r\n              </Text>\r\n            </Pressable>\r\n            <Pressable style={styles.actionButton} onPress={handleConfirm}>\r\n              <Text variant=\"bodySemibold\" style={{ color: colors.accent.orange }}>\r\n                OK\r\n              </Text>\r\n            </Pressable>\r\n          </View>\r\n        </View>\r\n      </View>\r\n    </Modal>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  overlay: {\r\n    flex: 1,\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n  },\r\n  backdrop: {\r\n    ...StyleSheet.absoluteFillObject,\r\n    backgroundColor: colors.overlay.scrim,\r\n  },\r\n  modalContent: {\r\n    width: '85%',\r\n    maxWidth: 340,\r\n    borderRadius: radius.xl,\r\n    paddingTop: spacing.lg,\r\n    paddingBottom: spacing.md,\r\n    paddingHorizontal: spacing.lg,\r\n  },\r\n  title: {\r\n    textAlign: 'center',\r\n    marginBottom: spacing.md,\r\n  },\r\n  timeDisplay: {\r\n    flexDirection: 'row',\r\n    justifyContent: 'center',\r\n    alignItems: 'flex-end',\r\n    marginBottom: spacing.md,\r\n    gap: spacing.xs,\r\n  },\r\n  timeSegment: {\r\n    flexDirection: 'row',\r\n    alignItems: 'flex-end',\r\n  },\r\n  timeValue: {\r\n    fontSize: 48,\r\n    fontWeight: '300',\r\n    lineHeight: 56,\r\n  },\r\n  timeLabel: {\r\n    fontSize: 20,\r\n    fontWeight: '400',\r\n    marginBottom: spacing.xs,\r\n    marginLeft: 2,\r\n  },\r\n  presetsContainer: {\r\n    marginBottom: spacing.md,\r\n    gap: spacing.xs,\r\n  },\r\n  presetsLabel: {\r\n    textAlign: 'center',\r\n  },\r\n  presetsRow: {\r\n    flexDirection: 'row',\r\n    justifyContent: 'center',\r\n    gap: spacing.sm,\r\n  },\r\n  presetButton: {\r\n    paddingVertical: spacing.xs,\r\n    paddingHorizontal: spacing.md,\r\n    borderRadius: radius.md,\r\n    borderWidth: 1,\r\n  },\r\n  numpad: {\r\n    gap: spacing.sm,\r\n    marginBottom: spacing.lg,\r\n  },\r\n  numpadRow: {\r\n    flexDirection: 'row',\r\n    justifyContent: 'center',\r\n    gap: spacing.sm,\r\n  },\r\n  numpadButton: {\r\n    width: 72,\r\n    height: 56,\r\n    borderRadius: radius.full,\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n  },\r\n  actions: {\r\n    flexDirection: 'row',\r\n    justifyContent: 'flex-end',\r\n    gap: spacing.lg,\r\n    paddingTop: spacing.sm,\r\n  },\r\n  actionButton: {\r\n    paddingVertical: spacing.sm,\r\n    paddingHorizontal: spacing.md,\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\ChatHistoryModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'withSpring' is defined but never used.","line":20,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":20,"endColumn":13}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * ChatHistorySidePanel\r\n * Side panel that slides from the right for viewing and selecting past chat sessions\r\n */\r\n\r\nimport React, { useEffect, useState, useCallback } from 'react';\r\nimport {\r\n  View,\r\n  StyleSheet,\r\n  Pressable,\r\n  FlatList,\r\n  ActivityIndicator,\r\n  Dimensions,\r\n} from 'react-native';\r\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\r\nimport Animated, {\r\n  useSharedValue,\r\n  useAnimatedStyle,\r\n  withTiming,\r\n  withSpring,\r\n  runOnJS,\r\n  Easing,\r\n} from 'react-native-reanimated';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { Button } from '@/components/atoms/Button';\r\nimport { IconSymbol } from '@/components/ui/icon-symbol';\r\nimport { useTheme } from '@/hooks/useTheme';\r\nimport { spacing, radius, shadows } from '@/constants/theme';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\nimport {\r\n  fetchChatSessions,\r\n  deleteChatSession,\r\n} from '@/services/herculesAIService';\r\nimport type { ChatSessionSummary } from '@/types/herculesAI';\r\n\r\nconst { width: SCREEN_WIDTH } = Dimensions.get('window');\r\nconst PANEL_WIDTH = Math.min(SCREEN_WIDTH * 0.85, 320);\r\n\r\ninterface ChatHistoryModalProps {\r\n  visible: boolean;\r\n  onClose: () => void;\r\n  onSelectSession: (sessionId: string) => void;\r\n  onNewChat: () => void;\r\n}\r\n\r\nexport const ChatHistoryModal: React.FC<ChatHistoryModalProps> = ({\r\n  visible,\r\n  onClose,\r\n  onSelectSession,\r\n  onNewChat,\r\n}) => {\r\n  const { theme } = useTheme();\r\n  const insets = useSafeAreaInsets();\r\n  const [sessions, setSessions] = useState<ChatSessionSummary[]>([]);\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const [error, setError] = useState<string | null>(null);\r\n  const [isVisible, setIsVisible] = useState(false);\r\n\r\n  const translateX = useSharedValue(PANEL_WIDTH);\r\n  const backdropOpacity = useSharedValue(0);\r\n\r\n  const loadSessions = useCallback(async () => {\r\n    setIsLoading(true);\r\n    setError(null);\r\n    const { data, error: fetchError } = await fetchChatSessions();\r\n    if (fetchError) {\r\n      setError(fetchError.message);\r\n    } else if (data) {\r\n      setSessions(data);\r\n    }\r\n    setIsLoading(false);\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    if (visible) {\r\n      setIsVisible(true);\r\n      loadSessions();\r\n      translateX.value = withTiming(0, {\r\n        duration: 300,\r\n        easing: Easing.out(Easing.cubic),\r\n      });\r\n      backdropOpacity.value = withTiming(1, { duration: 250 });\r\n    } else {\r\n      translateX.value = withTiming(PANEL_WIDTH, {\r\n        duration: 250,\r\n        easing: Easing.out(Easing.cubic),\r\n      });\r\n      backdropOpacity.value = withTiming(0, { duration: 200 }, () => {\r\n        runOnJS(setIsVisible)(false);\r\n      });\r\n    }\r\n  }, [visible, loadSessions, translateX, backdropOpacity]);\r\n\r\n  const handleSelectSession = useCallback(\r\n    (sessionId: string) => {\r\n      triggerHaptic('selection');\r\n      onSelectSession(sessionId);\r\n      onClose();\r\n    },\r\n    [onSelectSession, onClose]\r\n  );\r\n\r\n  const handleDeleteSession = useCallback(\r\n    async (sessionId: string) => {\r\n      triggerHaptic('warning');\r\n      const { success } = await deleteChatSession(sessionId);\r\n      if (success) {\r\n        setSessions((prev) => prev.filter((s) => s.id !== sessionId));\r\n      }\r\n    },\r\n    []\r\n  );\r\n\r\n  const handleNewChat = useCallback(() => {\r\n    triggerHaptic('selection');\r\n    onNewChat();\r\n    onClose();\r\n  }, [onNewChat, onClose]);\r\n\r\n  const formatDate = (dateString: string) => {\r\n    const date = new Date(dateString);\r\n    const now = new Date();\r\n    const diffMs = now.getTime() - date.getTime();\r\n    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));\r\n\r\n    if (diffDays === 0) {\r\n      return 'Today';\r\n    } else if (diffDays === 1) {\r\n      return 'Yesterday';\r\n    } else if (diffDays < 7) {\r\n      return `${diffDays} days ago`;\r\n    } else {\r\n      return date.toLocaleDateString();\r\n    }\r\n  };\r\n\r\n  const panelStyle = useAnimatedStyle(() => ({\r\n    transform: [{ translateX: translateX.value }],\r\n  }));\r\n\r\n  const backdropStyle = useAnimatedStyle(() => ({\r\n    opacity: backdropOpacity.value,\r\n  }));\r\n\r\n  const renderSession = ({ item }: { item: ChatSessionSummary }) => (\r\n    <Pressable\r\n      style={[\r\n        styles.sessionItem,\r\n        {\r\n          backgroundColor: theme.surface.elevated,\r\n          borderColor: theme.accent.primary,\r\n          borderWidth: 1,\r\n        },\r\n      ]}\r\n      onPress={() => handleSelectSession(item.id)}\r\n    >\r\n      <View style={styles.sessionIcon}>\r\n        <IconSymbol name=\"chat-bubble-outline\" size={18} color={theme.accent.primary} />\r\n      </View>\r\n      <View style={styles.sessionContent}>\r\n        <Text variant=\"bodySemibold\" color=\"primary\" numberOfLines={1}>\r\n          {item.title || 'Untitled Chat'}\r\n        </Text>\r\n        <Text variant=\"caption\" color=\"tertiary\">\r\n          {formatDate(item.createdAt)}\r\n        </Text>\r\n      </View>\r\n      <Pressable\r\n        onPress={() => handleDeleteSession(item.id)}\r\n        hitSlop={8}\r\n        style={styles.deleteButton}\r\n      >\r\n        <IconSymbol name=\"close\" size={16} color={theme.text.tertiary} />\r\n      </Pressable>\r\n    </Pressable>\r\n  );\r\n\r\n  if (!isVisible) return null;\r\n\r\n  return (\r\n    <View style={StyleSheet.absoluteFill} pointerEvents=\"box-none\">\r\n      <Animated.View\r\n        style={[\r\n          styles.backdrop,\r\n          { backgroundColor: theme.overlay.scrim },\r\n          backdropStyle,\r\n        ]}\r\n      >\r\n        <Pressable style={StyleSheet.absoluteFill} onPress={onClose} />\r\n      </Animated.View>\r\n\r\n      <Animated.View\r\n        style={[\r\n          styles.panel,\r\n          {\r\n            width: PANEL_WIDTH,\r\n            backgroundColor: theme.surface.card,\r\n            paddingTop: insets.top,\r\n            paddingBottom: insets.bottom,\r\n            ...shadows.lg,\r\n          },\r\n          panelStyle,\r\n        ]}\r\n      >\r\n        <View style={styles.header}>\r\n          <Text variant=\"heading3\" color=\"primary\">\r\n            History\r\n          </Text>\r\n          <Pressable\r\n            onPress={onClose}\r\n            hitSlop={12}\r\n            style={[styles.closeButton, { backgroundColor: theme.surface.elevated }]}\r\n          >\r\n            <IconSymbol name=\"close\" size={18} color={theme.text.secondary} />\r\n          </Pressable>\r\n        </View>\r\n\r\n        <View style={styles.content}>\r\n          {isLoading ? (\r\n            <View style={styles.centered}>\r\n              <ActivityIndicator size=\"large\" color={theme.accent.primary} />\r\n            </View>\r\n          ) : error ? (\r\n            <View style={styles.centered}>\r\n              <Text variant=\"body\" color=\"secondary\" style={styles.errorText}>\r\n                {error}\r\n              </Text>\r\n              <Button label=\"Retry\" variant=\"secondary\" size=\"sm\" onPress={loadSessions} />\r\n            </View>\r\n          ) : sessions.length === 0 ? (\r\n            <View style={styles.centered}>\r\n              <View style={[styles.emptyIcon, { backgroundColor: theme.surface.elevated }]}>\r\n                <IconSymbol name=\"chat-bubble-outline\" size={32} color={theme.text.tertiary} />\r\n              </View>\r\n              <Text variant=\"body\" color=\"secondary\" style={styles.emptyText}>\r\n                No previous chats\r\n              </Text>\r\n              <Text variant=\"caption\" color=\"tertiary\" style={styles.emptySubtext}>\r\n                Start a conversation to see it here\r\n              </Text>\r\n            </View>\r\n          ) : (\r\n            <FlatList\r\n              data={sessions}\r\n              renderItem={renderSession}\r\n              keyExtractor={(item) => item.id}\r\n              contentContainerStyle={styles.list}\r\n              showsVerticalScrollIndicator={false}\r\n            />\r\n          )}\r\n        </View>\r\n\r\n        <View style={styles.footer}>\r\n          <Button\r\n            label=\"New Chat\"\r\n            variant=\"primary\"\r\n            size=\"md\"\r\n            onPress={handleNewChat}\r\n            style={styles.newChatButton}\r\n          />\r\n        </View>\r\n      </Animated.View>\r\n    </View>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  backdrop: {\r\n    ...StyleSheet.absoluteFillObject,\r\n  },\r\n  panel: {\r\n    position: 'absolute',\r\n    top: 0,\r\n    right: 0,\r\n    bottom: 0,\r\n    borderTopLeftRadius: radius.xl,\r\n    borderBottomLeftRadius: radius.xl,\r\n  },\r\n  header: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'space-between',\r\n    paddingHorizontal: spacing.lg,\r\n    paddingTop: spacing.md,\r\n    paddingBottom: spacing.md,\r\n  },\r\n  closeButton: {\r\n    width: 32,\r\n    height: 32,\r\n    borderRadius: 16,\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n  },\r\n  content: {\r\n    flex: 1,\r\n  },\r\n  centered: {\r\n    flex: 1,\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n    paddingHorizontal: spacing.lg,\r\n    gap: spacing.sm,\r\n  },\r\n  errorText: {\r\n    textAlign: 'center',\r\n    marginBottom: spacing.sm,\r\n  },\r\n  emptyIcon: {\r\n    width: 64,\r\n    height: 64,\r\n    borderRadius: 32,\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n    marginBottom: spacing.md,\r\n  },\r\n  emptyText: {\r\n    textAlign: 'center',\r\n  },\r\n  emptySubtext: {\r\n    textAlign: 'center',\r\n    marginTop: spacing.xs,\r\n  },\r\n  list: {\r\n    paddingHorizontal: spacing.md,\r\n    paddingTop: spacing.md,\r\n    gap: spacing.sm,\r\n  },\r\n  sessionItem: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    paddingVertical: spacing.md,\r\n    paddingHorizontal: spacing.md,\r\n    borderRadius: radius.md,\r\n    gap: spacing.sm,\r\n  },\r\n  sessionIcon: {\r\n    width: 36,\r\n    height: 36,\r\n    borderRadius: 18,\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n    backgroundColor: 'rgba(255, 107, 74, 0.15)',\r\n  },\r\n  sessionContent: {\r\n    flex: 1,\r\n    gap: spacing.xxs,\r\n  },\r\n  deleteButton: {\r\n    padding: spacing.xs,\r\n  },\r\n  footer: {\r\n    paddingHorizontal: spacing.lg,\r\n    paddingTop: spacing.md,\r\n    paddingBottom: spacing.md,\r\n    borderTopWidth: 1,\r\n    borderTopColor: 'rgba(255, 107, 74, 0.2)',\r\n  },\r\n  newChatButton: {\r\n    width: '100%',\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\ChatMessageBubble.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\ChatUsageBanner.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Text' is defined but never used.","line":9,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isLow' is assigned a value but never used.","line":26,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":26,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * ChatUsageBanner\r\n * Displays remaining AI chat usage for the current period\r\n */\r\n\r\nimport React from 'react';\r\nimport { View, StyleSheet } from 'react-native';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { useTheme } from '@/hooks/useTheme';\r\nimport { spacing, radius } from '@/constants/theme';\r\nimport type { UsageInfo } from '@/types/herculesAI';\r\n\r\ninterface ChatUsageBannerProps {\r\n  usage: UsageInfo | null;\r\n}\r\n\r\nexport const ChatUsageBanner: React.FC<ChatUsageBannerProps> = ({ usage }) => {\r\n  const { theme } = useTheme();\r\n\r\n  if (!usage) {\r\n    return null;\r\n  }\r\n\r\n  const messagesRemaining = Math.max(0, usage.messagesLimit - usage.messagesUsed);\r\n  const isLow = messagesRemaining <= 5;\r\n\r\n  return (\r\n    <View style={[styles.container, { backgroundColor: theme.surface.elevated }]}>\r\n      {/* Usage banner content removed */}\r\n    </View>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    paddingTop: spacing.sm,\r\n    paddingBottom: spacing.xs,\r\n    paddingHorizontal: spacing.md,\r\n    borderRadius: radius.sm,\r\n    alignItems: 'center',\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\CompactExerciseRow.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\CreateExerciseModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SurfaceCard' is defined but never used.","line":12,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'EXERCISE_TYPE_LABELS' is defined but never used.","line":16,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'err' is defined but never used.","line":105,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":105,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * CreateExerciseModal\r\n * Modal for creating custom exercises with name and exercise type selection.\r\n */\r\n\r\nimport React, { useCallback, useState } from 'react';\r\nimport { Modal, Pressable, StyleSheet, View, ScrollView } from 'react-native';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\n\r\nimport { Button } from '@/components/atoms/Button';\r\nimport { InputField } from '@/components/atoms/InputField';\r\nimport { SurfaceCard } from '@/components/atoms/SurfaceCard';\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { colors, radius, spacing } from '@/constants/theme';\r\nimport { useCustomExerciseStore } from '@/store/customExerciseStore';\r\nimport { EXERCISE_TYPE_LABELS, type ExerciseType } from '@/types/exercise';\r\nimport { exercises as baseExerciseCatalog } from '@/constants/exercises';\r\nimport { useTheme } from '@/hooks/useTheme';\r\n\r\ninterface CreateExerciseModalProps {\r\n  visible: boolean;\r\n  onClose: () => void;\r\n  onExerciseCreated?: (exerciseName: string, exerciseType: ExerciseType) => void;\r\n}\r\n\r\nconst EXERCISE_TYPE_OPTIONS: { value: ExerciseType; label: string; description: string }[] = [\r\n  { value: 'weight', label: 'Weight + Reps', description: 'Track weight and reps (e.g., Bench Press)' },\r\n  { value: 'bodyweight', label: 'Bodyweight', description: 'Track reps only (e.g., Push-ups)' },\r\n  { value: 'assisted', label: 'Assisted', description: 'Track assistance weight and reps (e.g., Assisted Pull-ups)' },\r\n  { value: 'duration', label: 'Timed', description: 'Track duration (e.g., Plank)' },\r\n  { value: 'cardio', label: 'Cardio', description: 'Track distance and time (e.g., Running)' },\r\n  { value: 'reps_only', label: 'Resistance Band', description: 'Track reps with band resistance' },\r\n];\r\n\r\nexport const CreateExerciseModal: React.FC<CreateExerciseModalProps> = ({\r\n  visible,\r\n  onClose,\r\n  onExerciseCreated,\r\n}) => {\r\n  const { theme } = useTheme();\r\n  const addCustomExercise = useCustomExerciseStore((state) => state.addCustomExercise);\r\n  const customExercises = useCustomExerciseStore((state) => state.customExercises);\r\n\r\n  const [name, setName] = useState('');\r\n  const [selectedType, setSelectedType] = useState<ExerciseType>('weight');\r\n  const [error, setError] = useState<string | null>(null);\r\n  const [isSubmitting, setIsSubmitting] = useState(false);\r\n\r\n  const handleClose = useCallback(() => {\r\n    setName('');\r\n    setSelectedType('weight');\r\n    setError(null);\r\n    setIsSubmitting(false);\r\n    onClose();\r\n  }, [onClose]);\r\n\r\n  const handleSelectType = useCallback((type: ExerciseType) => {\r\n    triggerHaptic('selection');\r\n    setSelectedType(type);\r\n    setError(null);\r\n  }, []);\r\n\r\n  const handleCreate = useCallback(async () => {\r\n    const trimmedName = name.trim();\r\n\r\n    if (!trimmedName) {\r\n      setError('Please enter an exercise name');\r\n      return;\r\n    }\r\n\r\n    if (trimmedName.length < 2) {\r\n      setError('Name must be at least 2 characters');\r\n      return;\r\n    }\r\n\r\n    const existingCustom = customExercises.find(\r\n      (e) => e.name.toLowerCase() === trimmedName.toLowerCase()\r\n    );\r\n    const existingBuiltIn = baseExerciseCatalog.find(\r\n      (e) => e.name.toLowerCase() === trimmedName.toLowerCase()\r\n    );\r\n\r\n    if (existingCustom || existingBuiltIn) {\r\n      setError('An exercise with this name already exists');\r\n      return;\r\n    }\r\n\r\n    setIsSubmitting(true);\r\n    setError(null);\r\n\r\n    try {\r\n      const result = await addCustomExercise({\r\n        name: trimmedName,\r\n        exerciseType: selectedType,\r\n      });\r\n\r\n      if (result) {\r\n        triggerHaptic('success');\r\n        onExerciseCreated?.(result.name, result.exerciseType);\r\n        handleClose();\r\n      } else {\r\n        setError('Failed to create exercise. Please try again.');\r\n        setIsSubmitting(false);\r\n      }\r\n    } catch (err) {\r\n      setError('An unexpected error occurred');\r\n      setIsSubmitting(false);\r\n    }\r\n  }, [name, selectedType, customExercises, addCustomExercise, onExerciseCreated, handleClose]);\r\n\r\n  const isValid = name.trim().length >= 2;\r\n\r\n  return (\r\n    <Modal\r\n      visible={visible}\r\n      transparent\r\n      animationType=\"fade\"\r\n      onRequestClose={handleClose}\r\n      statusBarTranslucent\r\n    >\r\n      <Pressable style={styles.overlay} onPress={handleClose}>\r\n        <Pressable\r\n          style={[styles.modalContainer, { backgroundColor: theme.surface.card }]}\r\n          onPress={(e) => e.stopPropagation()}\r\n        >\r\n          <ScrollView\r\n            showsVerticalScrollIndicator={false}\r\n            contentContainerStyle={styles.scrollContent}\r\n            keyboardDismissMode=\"on-drag\"\r\n          >\r\n            <View style={styles.header}>\r\n              <Text variant=\"heading3\" color=\"primary\">\r\n                Create Exercise\r\n              </Text>\r\n              <Text variant=\"body\" color=\"secondary\">\r\n                Add a custom exercise to your library\r\n              </Text>\r\n            </View>\r\n\r\n            <View style={styles.form}>\r\n              <InputField\r\n                label=\"Exercise Name\"\r\n                value={name}\r\n                onChangeText={(text) => {\r\n                  if (text.length <= 50) {\r\n                    setName(text);\r\n                    setError(null);\r\n                  }\r\n                }}\r\n                placeholder=\"e.g., Bulgarian Split Squat\"\r\n                autoCapitalize=\"words\"\r\n                testID=\"create-exercise-name-input\"\r\n              />\r\n\r\n              <View style={styles.typeSection}>\r\n                <Text variant=\"labelMedium\" color=\"secondary\" style={styles.typeLabel}>\r\n                  Exercise Type\r\n                </Text>\r\n                <View style={styles.typeGrid}>\r\n                  {EXERCISE_TYPE_OPTIONS.map((option) => {\r\n                    const isSelected = selectedType === option.value;\r\n                    return (\r\n                      <Pressable\r\n                        key={option.value}\r\n                        style={[\r\n                          styles.typeOption,\r\n                          { \r\n                            backgroundColor: isSelected \r\n                              ? colors.accent.primary \r\n                              : theme.surface.elevated,\r\n                            borderColor: isSelected \r\n                              ? colors.accent.primary \r\n                              : theme.border.light,\r\n                          },\r\n                        ]}\r\n                        onPress={() => handleSelectType(option.value)}\r\n                      >\r\n                        <Text\r\n                          variant=\"bodySemibold\"\r\n                          color={isSelected ? 'onAccent' : 'primary'}\r\n                        >\r\n                          {option.label}\r\n                        </Text>\r\n                        <Text\r\n                          variant=\"caption\"\r\n                          color={isSelected ? 'onAccent' : 'secondary'}\r\n                          numberOfLines={2}\r\n                        >\r\n                          {option.description}\r\n                        </Text>\r\n                      </Pressable>\r\n                    );\r\n                  })}\r\n                </View>\r\n              </View>\r\n\r\n              {error ? (\r\n                <Text variant=\"caption\" style={styles.errorText}>\r\n                  {error}\r\n                </Text>\r\n              ) : null}\r\n            </View>\r\n          </ScrollView>\r\n\r\n          <View style={styles.actions}>\r\n            <Button\r\n              label=\"Cancel\"\r\n              variant=\"ghost\"\r\n              size=\"md\"\r\n              onPress={handleClose}\r\n              style={styles.actionButton}\r\n            />\r\n            <Button\r\n              label={isSubmitting ? 'Creating...' : 'Create'}\r\n              variant=\"primary\"\r\n              size=\"md\"\r\n              onPress={handleCreate}\r\n              disabled={!isValid || isSubmitting}\r\n              style={styles.actionButton}\r\n            />\r\n          </View>\r\n        </Pressable>\r\n      </Pressable>\r\n    </Modal>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  overlay: {\r\n    flex: 1,\r\n    backgroundColor: colors.overlay.scrim,\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n    padding: spacing.md,\r\n  },\r\n  modalContainer: {\r\n    width: '100%',\r\n    maxWidth: 400,\r\n    maxHeight: '85%',\r\n    borderRadius: radius.lg,\r\n    padding: spacing.lg,\r\n    gap: spacing.sm,\r\n  },\r\n  scrollContent: {\r\n    paddingBottom: spacing.md,\r\n  },\r\n  header: {\r\n    gap: spacing.xxs,\r\n    marginBottom: spacing.sm,\r\n    alignItems: 'flex-start',\r\n  },\r\n  form: {\r\n    gap: spacing.md,\r\n  },\r\n  typeSection: {\r\n    gap: spacing.xs,\r\n  },\r\n  typeLabel: {\r\n    marginBottom: spacing.xxxs,\r\n  },\r\n  typeGrid: {\r\n    gap: spacing.xs,\r\n  },\r\n  typeOption: {\r\n    padding: spacing.mdCompact,\r\n    borderRadius: radius.md,\r\n    borderWidth: 1,\r\n    gap: spacing.xxxs,\r\n  },\r\n  errorText: {\r\n    color: colors.accent.warning,\r\n    paddingHorizontal: spacing.sm,\r\n  },\r\n  actions: {\r\n    flexDirection: 'row',\r\n    gap: spacing.sm,\r\n    paddingTop: spacing.sm,\r\n    borderTopWidth: StyleSheet.hairlineWidth,\r\n    borderTopColor: colors.border.light,\r\n  },\r\n  actionButton: {\r\n    flex: 1,\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\CustomTabBar.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TAB_MINIMUM_BOTTOM_GAP' is assigned a value but never used.","line":31,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":31,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TAB_FLOAT_LIFT' is assigned a value but never used.","line":32,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":32,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * CustomTabBar\r\n * Floating, glassmorphism tab bar with animated interactions and haptics.\r\n */\r\nimport React from 'react';\r\nimport { Platform, StyleSheet, View, TouchableOpacity } from 'react-native';\r\nimport type { ColorValue } from 'react-native';\r\nimport type { BottomTabBarProps } from '@react-navigation/bottom-tabs';\r\nimport Animated, {\r\n  useAnimatedStyle,\r\n  useSharedValue,\r\n  withSpring,\r\n} from 'react-native-reanimated';\r\nimport { Ionicons } from '@expo/vector-icons';\r\nimport { BlurView, type ExperimentalBlurMethod } from 'expo-blur';\r\nimport { LinearGradient } from 'expo-linear-gradient';\r\nimport MaskedView from '@react-native-masked-view/masked-view';\r\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\r\n\r\nimport { spacing, radius, sizing, zIndex, shadows } from '@/constants/theme';\r\nimport { useTheme } from '@/hooks/useTheme';\r\nimport { springBouncy } from '@/constants/animations';\r\nimport { TAB_META } from '@/constants/navigation';\r\nimport { useSessionStore } from '@/store/sessionStore';\r\nimport { useNavigationStore } from '@/store/navigationStore';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\n\r\nconst ICON_SIZE = sizing.iconLG;\r\nconst BLUR_INTENSITY = 100;\r\nconst TAB_HORIZONTAL_INSET = spacing.sm;\r\nconst TAB_MINIMUM_BOTTOM_GAP = spacing.xs / 2;\r\nconst TAB_FLOAT_LIFT = spacing.lg;\r\nconst BLUR_METHOD: ExperimentalBlurMethod | undefined = Platform.OS === 'android' ? 'dimezisBlurView' : undefined;\r\nconst BLUR_REDUCTION_FACTOR: number | undefined = Platform.OS === 'android' ? 1 : undefined;\r\nconst SCALE_ACTIVE = 1.1;\r\nconst PROFILE_CHILD_ROUTES = ['profile', 'distribution-analytics', 'volume-analytics'] as const;\r\ntype ProfileChildRoute = typeof PROFILE_CHILD_ROUTES[number];\r\nconst isProfileChildRoute = (routeName?: string): routeName is ProfileChildRoute =>\r\n  Boolean(routeName && PROFILE_CHILD_ROUTES.includes(routeName as ProfileChildRoute));\r\n\r\ntype TabBarItemProps = {\r\n  isFocused: boolean;\r\n  isWorkoutRoute: boolean;\r\n  showActiveSessionGlow: boolean;\r\n  iconName: keyof typeof Ionicons.glyphMap;\r\n  onPress: () => void;\r\n  theme: any;\r\n  createGradientIcon: (iconName: keyof typeof Ionicons.glyphMap) => React.ReactElement;\r\n};\r\n\r\nconst TabBarItem: React.FC<TabBarItemProps> = ({\r\n  isFocused,\r\n  isWorkoutRoute,\r\n  showActiveSessionGlow,\r\n  iconName,\r\n  onPress,\r\n  theme,\r\n  createGradientIcon,\r\n}) => {\r\n  const scale = useSharedValue(1);\r\n\r\n  const animatedStyle = useAnimatedStyle(() => ({\r\n    transform: [{ scale: scale.value }],\r\n  }));\r\n\r\n  return (\r\n    <Animated.View style={[styles.tabSlot, animatedStyle]}>\r\n      <TouchableOpacity\r\n        accessibilityRole=\"button\"\r\n        accessibilityState={{ selected: isFocused }}\r\n        onPress={() => {\r\n          onPress();\r\n          scale.value = withSpring(SCALE_ACTIVE, springBouncy);\r\n          setTimeout(() => {\r\n            scale.value = withSpring(1, springBouncy);\r\n          }, 140);\r\n        }}\r\n        activeOpacity={1}\r\n        style={styles.touchable}\r\n      >\r\n        {showActiveSessionGlow ? (\r\n          <Ionicons name=\"play\" size={ICON_SIZE} color={theme.accent.orange} />\r\n        ) : isFocused ? (\r\n          isWorkoutRoute ? (\r\n            <Ionicons\r\n              name=\"play-outline\"\r\n              size={ICON_SIZE}\r\n              color={theme.accent.orange}\r\n            />\r\n          ) : (\r\n            createGradientIcon(iconName)\r\n          )\r\n        ) : (\r\n          <Ionicons name={iconName} size={ICON_SIZE} color={theme.text.primary} />\r\n        )}\r\n      </TouchableOpacity>\r\n    </Animated.View>\r\n  );\r\n};\r\n\r\nexport const CustomTabBar: React.FC<BottomTabBarProps> = ({ state, navigation }) => {\r\n  const insets = useSafeAreaInsets();\r\n  const { theme, isDarkMode } = useTheme();\r\n  const isSessionActive = useSessionStore((store) => store.isSessionActive);\r\n  const workoutDetailSource = useNavigationStore((store) => store.workoutDetailSource);\r\n\r\n  const TAB_SURFACE_COLOR = theme.surface.card;\r\n  const TAB_BORDER_COLOR = theme.primary.light;\r\n  const ACTIVE_GRADIENT: readonly [ColorValue, ColorValue] = [\r\n    theme.accent.gradientStart,\r\n    theme.accent.gradientEnd,\r\n  ];\r\n\r\n  const deviceSafeBottom = Math.max(insets.bottom, 0);\r\n  const bottomOffset = deviceSafeBottom + spacing.sm;\r\n  const containerInsets = {\r\n    left: TAB_HORIZONTAL_INSET,\r\n    right: TAB_HORIZONTAL_INSET,\r\n    bottom: bottomOffset,\r\n  };\r\n\r\n  const currentRouteName = state.routes[state.index]?.name;\r\n  const isWorkoutSessionPage = isSessionActive && currentRouteName === 'workout';\r\n  const fillBackgroundColor = isWorkoutSessionPage ? 'transparent' : theme.primary.bg;\r\n\r\n\r\n  const focusTab = (routeKey: string, routeName: string) => {\r\n    const event = navigation.emit({\r\n      type: 'tabPress',\r\n      target: routeKey,\r\n      canPreventDefault: true,\r\n    });\r\n\r\n    if (!event.defaultPrevented) navigation.navigate(routeName);\r\n\r\n    triggerHaptic('light');\r\n  };\r\n  const createGradientIcon = (iconName: keyof typeof Ionicons.glyphMap) => (\r\n    <MaskedView\r\n      style={styles.gradientMask}\r\n      maskElement={(\r\n        <View style={styles.maskContent}>\r\n          <Ionicons name={iconName} size={ICON_SIZE} color=\"#FFFFFF\" />\r\n        </View>\r\n      )}\r\n    >\r\n      <LinearGradient\r\n        colors={ACTIVE_GRADIENT}\r\n        start={{ x: 0, y: 0 }}\r\n        end={{ x: 1, y: 1 }}\r\n        style={styles.gradientFill}\r\n      />\r\n    </MaskedView>\r\n  );\r\n\r\n  return (\r\n    <>\r\n      <View\r\n        pointerEvents=\"none\"\r\n        style={{\r\n          position: 'absolute',\r\n          bottom: 0,\r\n          left: 0,\r\n          right: 0,\r\n          height: bottomOffset,\r\n          backgroundColor: fillBackgroundColor,\r\n          zIndex: zIndex.modal - 1,\r\n        }}\r\n      />\r\n      <View pointerEvents=\"box-none\" style={[styles.positioner, containerInsets]}>\r\n        {/* Corner patches to block content bleed-through in the rounded corner gaps */}\r\n        <View\r\n          pointerEvents=\"none\"\r\n          style={{\r\n            position: 'absolute',\r\n            bottom: -1,\r\n            left: 0,\r\n            width: radius.xl,\r\n            height: radius.xl + 1,\r\n            backgroundColor: fillBackgroundColor,\r\n          }}\r\n        />\r\n        <View\r\n          pointerEvents=\"none\"\r\n          style={{\r\n            position: 'absolute',\r\n            bottom: -1,\r\n            right: 0,\r\n            width: radius.xl,\r\n            height: radius.xl + 1,\r\n            backgroundColor: fillBackgroundColor,\r\n          }}\r\n        />\r\n        <View style={[styles.shadowWrapper, { backgroundColor: TAB_SURFACE_COLOR }]}>\r\n          <View style={[styles.tabContainer, { backgroundColor: TAB_SURFACE_COLOR, borderColor: TAB_BORDER_COLOR }]}>\r\n            <BlurView\r\n              intensity={BLUR_INTENSITY}\r\n              tint={isDarkMode ? 'dark' : 'light'}\r\n              experimentalBlurMethod={BLUR_METHOD}\r\n              blurReductionFactor={BLUR_REDUCTION_FACTOR}\r\n              style={[styles.blurShell, { backgroundColor: TAB_SURFACE_COLOR }]}\r\n            >\r\n              <View pointerEvents=\"none\" style={[styles.blurOverlay, { backgroundColor: TAB_SURFACE_COLOR }]} />\r\n              <View style={styles.tabRow}>\r\n                {state.routes.map((route, index) => {\r\n                  const tabMeta = TAB_META.find((tab) => tab.route === route.name);\r\n                  if (!tabMeta) {\r\n                    return null;\r\n                  }\r\n\r\n                  const currentRouteName = state.routes[state.index]?.name;\r\n                  const isProfileChildScreen = isProfileChildRoute(currentRouteName);\r\n                  const isCreateWorkoutScreen = currentRouteName === 'create-workout' || currentRouteName === 'create-plan';\r\n                  const isCreateProgramScreen = currentRouteName === 'create-program';\r\n                  const isBrowseProgramsScreen = currentRouteName === 'browse-programs';\r\n                  const isAddWorkoutScreen = currentRouteName === 'add-workout';\r\n                  const isProgramDetailsScreen = currentRouteName === 'program-details';\r\n                  const isEditPlanScreen = currentRouteName === 'edit-plan';\r\n                  const isEditScheduleScreen = currentRouteName === 'schedule-editor' || currentRouteName === 'schedule-setup';\r\n                  const isPlansTab = route.name === 'plans';\r\n                  const isProfileTab = route.name === 'profile';\r\n                  const isWorkoutDetailScreen = currentRouteName === 'workout-detail';\r\n                  const isFocused =\r\n                    state.index === index\r\n                    || (isCreateWorkoutScreen && isPlansTab)\r\n                    || (isCreateProgramScreen && isPlansTab)\r\n                    || (isBrowseProgramsScreen && isPlansTab)\r\n                    || (isAddWorkoutScreen && isPlansTab)\r\n                    || (isProgramDetailsScreen && isPlansTab)\r\n                    || (isEditPlanScreen && isPlansTab)\r\n                    || (isEditScheduleScreen && isPlansTab)\r\n                    || (isProfileChildScreen && isProfileTab)\r\n                    || (isWorkoutDetailScreen && workoutDetailSource === 'dashboard' && route.name === 'index')\r\n                    || (isWorkoutDetailScreen && workoutDetailSource === 'calendar' && route.name === 'calendar');\r\n                  const isWorkoutRoute = route.name === 'workout';\r\n                  const showActiveSessionGlow = isWorkoutRoute && isSessionActive;\r\n\r\n                  return (\r\n                    <TabBarItem\r\n                      key={route.key}\r\n                      isFocused={isFocused}\r\n                      isWorkoutRoute={isWorkoutRoute}\r\n                      showActiveSessionGlow={showActiveSessionGlow}\r\n                      iconName={tabMeta.icon}\r\n                      theme={theme}\r\n                      createGradientIcon={createGradientIcon}\r\n                      onPress={() => focusTab(route.key, route.name)}\r\n                    />\r\n                  );\r\n                })}\r\n              </View>\r\n            </BlurView>\r\n          </View>\r\n        </View>\r\n      </View>\r\n    </>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  positioner: {\r\n    position: 'absolute',\r\n    zIndex: zIndex.modal,\r\n  },\r\n  shadowWrapper: {\r\n    borderRadius: radius.xl,\r\n    ...shadows.lg,\r\n  },\r\n  tabContainer: {\r\n    borderRadius: radius.xl,\r\n    overflow: 'hidden',\r\n    borderWidth: spacing.xxxs,\r\n  },\r\n  blurShell: {\r\n    borderRadius: radius.xl,\r\n    overflow: 'hidden',\r\n    paddingHorizontal: spacing.lg,\r\n    paddingTop: spacing.xs,\r\n  },\r\n  blurOverlay: {\r\n    ...StyleSheet.absoluteFillObject,\r\n    opacity: 0.9,\r\n  },\r\n  tabRow: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'space-between',\r\n  },\r\n  tabSlot: {\r\n    flex: 1,\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n  },\r\n  touchable: {\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    paddingVertical: spacing.xs,\r\n    overflow: 'visible',\r\n  },\r\n  maskContent: {\r\n    width: ICON_SIZE,\r\n    height: ICON_SIZE,\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n  },\r\n  gradientMask: {\r\n    width: ICON_SIZE,\r\n    height: ICON_SIZE,\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n    overflow: 'hidden',\r\n  },\r\n  gradientFill: {\r\n    ...StyleSheet.absoluteFillObject,\r\n  },\r\n});","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\DeleteConfirmationModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\DistanceByActivityCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\DrilldownBarChart.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Animated' is defined but never used.","line":10,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FadeIn' is defined but never used.","line":10,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'weightUnit' is assigned a value but never used.","line":49,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":49,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * DrilldownBarChart\r\n * Bar chart with drill-down capability for volume data\r\n * Similar to FractalBubbleChart but displays as bar chart\r\n */\r\n\r\nimport React, { useState, useMemo, useCallback } from 'react';\r\nimport { View, StyleSheet, Dimensions, Pressable } from 'react-native';\r\nimport { VictoryChart, VictoryBar, VictoryAxis, VictoryTheme } from 'victory-native';\r\nimport Animated, { FadeIn } from 'react-native-reanimated';\r\nimport { Ionicons } from '@expo/vector-icons';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { ChartWrapper } from '@/components/atoms/ChartWrapper';\r\nimport { colors, spacing, radius } from '@/constants/theme';\r\nimport { useSettingsStore } from '@/store/settingsStore';\r\nimport type { HierarchicalSetData, ChartSlice } from '@/types/analytics';\r\nimport hierarchyData from '@/data/hierarchy.json';\r\n\r\nconst SCREEN_WIDTH = Dimensions.get('window').width;\r\nconst CHART_WIDTH = SCREEN_WIDTH - spacing.lg * 2 - spacing.md * 2;\r\nconst CHART_HEIGHT = 220;\r\n\r\ninterface DrilldownBarChartProps {\r\n  data: HierarchicalSetData;\r\n  rootGroup: string;\r\n}\r\n\r\ninterface BreadcrumbItem {\r\n  name: string;\r\n  level: 'L1' | 'L2' | 'L3';\r\n}\r\n\r\n// Strip prefix from detailed muscle names\r\nconst getDisplayName = (fullName: string): string => {\r\n  if (fullName === 'Hamstrings') return 'Hams.';\r\n  if (fullName.includes(' - ')) {\r\n    return fullName.split(' - ')[1];\r\n  }\r\n  return fullName;\r\n};\r\n\r\nexport const DrilldownBarChart: React.FC<DrilldownBarChartProps> = ({\r\n  data,\r\n  rootGroup,\r\n}) => {\r\n  // Use reactive selector for unit\r\n  const weightUnit = useSettingsStore((state) => state.weightUnit);\r\n  const [breadcrumb, setBreadcrumb] = useState<BreadcrumbItem[]>([\r\n    { name: rootGroup, level: 'L1' },\r\n  ]);\r\n  const [selectedBar, setSelectedBar] = useState<{ label: string; value: number } | null>(null);\r\n\r\n  // Generate a unique key for the chart based on breadcrumb path\r\n  // This forces VictoryChart to fully re-render and clear any stale state\r\n  const chartKey = useMemo(() => {\r\n    return breadcrumb.map(b => `${b.level}-${b.name}`).join('/');\r\n  }, [breadcrumb]);\r\n\r\n  // Get expected children from hierarchy for current level\r\n  const expectedChildren = useMemo((): string[] => {\r\n    const current = breadcrumb[breadcrumb.length - 1];\r\n    const hierarchy = hierarchyData.muscle_hierarchy as any;\r\n    \r\n    if (current.level === 'L1') {\r\n      // L1 -> get L2 children (e.g., Upper Body -> Chest, Back, Shoulders, Arms)\r\n      return Object.keys(hierarchy[current.name]?.muscles || {});\r\n    } else if (current.level === 'L2') {\r\n      // L2 -> get L3 children (e.g., Arms -> Biceps, Triceps, Forearms)\r\n      const l1Name = breadcrumb[0].name;\r\n      const l3Children = hierarchy[l1Name]?.muscles?.[current.name]?.muscles || {};\r\n      const l3Names = Object.keys(l3Children);\r\n      \r\n      // Special case: if L3 has same name as L2 (e.g., Calves -> Calves),\r\n      // return L4 children directly to skip redundant level\r\n      if (l3Names.length === 1 && l3Names[0] === current.name) {\r\n        return Object.keys(l3Children[current.name]?.muscles || {});\r\n      }\r\n      return l3Names;\r\n    } else if (current.level === 'L3') {\r\n      // L3 -> get L4 children (e.g., Biceps -> Long Head, Short Head, Brachialis)\r\n      const l1Name = breadcrumb[0].name;\r\n      const l2Name = breadcrumb.length > 1 ? breadcrumb[1].name : '';\r\n      return Object.keys(hierarchy[l1Name]?.muscles?.[l2Name]?.muscles?.[current.name]?.muscles || {});\r\n    }\r\n    return [];\r\n  }, [breadcrumb]);\r\n\r\n  // Get current level's data, ensuring all expected children are included\r\n  const currentData = useMemo((): ChartSlice[] => {\r\n    const current = breadcrumb[breadcrumb.length - 1];\r\n    let key = `${current.level}:${current.name}`;\r\n    \r\n    // Special case: for L3 where L2 and L3 have same name (e.g., Calves),\r\n    // the data is stored under L2 key, not L3\r\n    if (current.level === 'L3' && breadcrumb.length > 1) {\r\n      const l2Name = breadcrumb[1].name;\r\n      if (l2Name === current.name) {\r\n        key = `L2:${current.name}`;\r\n      }\r\n    }\r\n    \r\n    const rawData = data.byParent[key] || [];\r\n    \r\n    // Create a map of existing data\r\n    const dataMap = new Map(rawData.map(d => [d.name, d]));\r\n    \r\n    // Include all expected children, with 0 values for missing ones\r\n    return expectedChildren.map((name, index) => {\r\n      const existing = dataMap.get(name);\r\n      if (existing) {\r\n        return existing;\r\n      }\r\n      // Return placeholder with 0 value\r\n      return {\r\n        name,\r\n        value: 0,\r\n        percentage: 0,\r\n        color: colors.neutral.gray400,\r\n      };\r\n    });\r\n  }, [breadcrumb, data, expectedChildren]);\r\n\r\n  // Check if we can drill down further\r\n  const canDrillDown = useCallback(\r\n    (name: string): boolean => {\r\n      const current = breadcrumb[breadcrumb.length - 1];\r\n      let nextLevel: 'L2' | 'L3' | null = null;\r\n\r\n      if (current.level === 'L1') nextLevel = 'L2';\r\n      else if (current.level === 'L2') nextLevel = 'L3';\r\n\r\n      if (!nextLevel) return false;\r\n\r\n      // Check for data at the next level\r\n      let key = `${nextLevel}:${name}`;\r\n      let children = data.byParent[key];\r\n      \r\n      // Special case: for same-name L2/L3 (e.g., Calves), data is under L2 key\r\n      if (!children?.length && nextLevel === 'L3' && current.name === name) {\r\n        key = `L2:${name}`;\r\n        children = data.byParent[key];\r\n      }\r\n      \r\n      return children && children.length > 0;\r\n    },\r\n    [breadcrumb, data]\r\n  );\r\n\r\n  // Handle bar press - drill down if possible\r\n  const handleBarPress = useCallback(\r\n    (label: string, value: number) => {\r\n      triggerHaptic('light');\r\n\r\n      if (selectedBar?.label === label) {\r\n        // Second tap - try to drill down\r\n        if (canDrillDown(label)) {\r\n          const current = breadcrumb[breadcrumb.length - 1];\r\n          let nextLevel: 'L2' | 'L3' = current.level === 'L1' ? 'L2' : 'L3';\r\n          setBreadcrumb([...breadcrumb, { name: label, level: nextLevel }]);\r\n          setSelectedBar(null);\r\n        } else {\r\n          // No children - just deselect\r\n          setSelectedBar(null);\r\n        }\r\n      } else {\r\n        // First tap - select bar (deselect any previous)\r\n        setSelectedBar({ label, value });\r\n      }\r\n    },\r\n    [selectedBar, canDrillDown, breadcrumb]\r\n  );\r\n\r\n  // Handle breadcrumb navigation\r\n  const handleBreadcrumbPress = useCallback((index: number) => {\r\n    triggerHaptic('light');\r\n    setBreadcrumb((prev) => prev.slice(0, index + 1));\r\n    setSelectedBar(null);\r\n  }, []);\r\n\r\n  // Calculate Y-axis ticks\r\n  const rawMax = Math.max(...currentData.map((d) => d.value), 0);\r\n  const increments = [10, 25, 50, 100, 250, 500, 1000, 2500, 5000, 10000, 25000, 50000];\r\n\r\n  let targetMax = 100;\r\n  let increment = 25;\r\n\r\n  if (rawMax > 0) {\r\n    for (const inc of increments) {\r\n      const segs = Math.ceil(rawMax / inc);\r\n      if (segs >= 2 && segs <= 5) {\r\n        targetMax = segs * inc;\r\n        increment = inc;\r\n        break;\r\n      }\r\n    }\r\n    if (targetMax < rawMax) {\r\n      targetMax = Math.ceil(rawMax / 1000) * 1000;\r\n      increment = targetMax / 4;\r\n    }\r\n  }\r\n\r\n  const yTickValues: number[] = [];\r\n  for (let i = 0; i <= targetMax; i += increment) {\r\n    yTickValues.push(i);\r\n  }\r\n\r\n  // Create chart data with consistent ordering\r\n  const chartData = currentData.map((d, index) => ({\r\n    x: index + 1, // Use numeric index for proper bar positioning\r\n    y: d.value,\r\n    originalName: d.name,\r\n    canDrill: canDrillDown(d.name),\r\n  }));\r\n  \r\n  // Categories for x-axis labels\r\n  const xCategories = currentData.map(d => getDisplayName(d.name));\r\n\r\n\r\n  // Check for data\r\n  const hasData = currentData.length > 0 && rawMax > 0;\r\n\r\n  const headerTitle = useMemo((): string => {\r\n    if (breadcrumb.length === 1) return rootGroup;\r\n    return breadcrumb[breadcrumb.length - 1].name;\r\n  }, [breadcrumb, rootGroup]);\r\n\r\n  return (\r\n    <View style={styles.container}>\r\n      {/* Header */}\r\n      <View style={styles.header}>\r\n        <Text variant=\"heading3\" color=\"primary\">\r\n          {headerTitle}\r\n        </Text>\r\n      </View>\r\n\r\n      {/* Breadcrumb - always visible unless empty state */}\r\n      {hasData && (\r\n        <View style={styles.breadcrumbContainer}>\r\n          {breadcrumb.map((item, index) => (\r\n            <View key={`${item.level}-${item.name}`} style={styles.breadcrumbItem}>\r\n              {index > 0 && (\r\n                <Ionicons name=\"chevron-forward\" size={14} color={colors.text.tertiary} />\r\n              )}\r\n              <Pressable\r\n                onPress={() => handleBreadcrumbPress(index)}\r\n                style={[\r\n                  styles.breadcrumbButton,\r\n                  index === breadcrumb.length - 1 && styles.breadcrumbButtonActive,\r\n                ]}\r\n              >\r\n                <Text\r\n                  variant=\"caption\"\r\n                  color={index === breadcrumb.length - 1 ? 'primary' : 'tertiary'}\r\n                >\r\n                  {item.name}\r\n                </Text>\r\n              </Pressable>\r\n            </View>\r\n          ))}\r\n        </View>\r\n      )}\r\n\r\n      {/* Chart */}\r\n      {!hasData ? (\r\n        <View style={styles.emptyContainer}>\r\n          <Text variant=\"body\" color=\"secondary\">\r\n            No workout data available yet.\r\n          </Text>\r\n          <Text variant=\"caption\" color=\"tertiary\">\r\n            Complete workouts to see your volume.\r\n          </Text>\r\n        </View>\r\n      ) : (\r\n        <ChartWrapper state=\"ready\" minHeight={CHART_HEIGHT + 40}>\r\n          <View style={styles.chartContainer}>\r\n            <VictoryChart\r\n              key={chartKey}\r\n              theme={VictoryTheme.material}\r\n              domainPadding={{ x: 30 }}\r\n              padding={{ top: 30, bottom: 50, left: 20, right: 20 }}\r\n              height={CHART_HEIGHT}\r\n              width={CHART_WIDTH}\r\n            >\r\n              <VictoryAxis\r\n                tickValues={chartData.map((d) => d.x)}\r\n                tickFormat={(t, index) => xCategories[index] || ''}\r\n                style={{\r\n                  axis: { stroke: 'none' },\r\n                  tickLabels: {\r\n                    fill: colors.text.primary,\r\n                    fontSize: 11,\r\n                    padding: 5,\r\n                    angle: chartData.length > 5 ? -45 : 0,\r\n                    textAnchor: chartData.length > 5 ? 'end' : 'middle',\r\n                  },\r\n                  grid: { stroke: 'none' },\r\n                }}\r\n              />\r\n              <VictoryAxis\r\n                dependentAxis\r\n                tickValues={yTickValues}\r\n                tickFormat={() => ''}\r\n                style={{\r\n                  axis: { stroke: 'none' },\r\n                  ticks: { stroke: 'none' },\r\n                  tickLabels: { fill: 'transparent' },\r\n                  grid: { stroke: 'none' },\r\n                }}\r\n              />\r\n              <VictoryBar\r\n                data={chartData}\r\n                labels={({ datum }) => datum.y > 0 ? (datum.y >= 1000 ? `${(datum.y / 1000).toFixed(1)}k` : Math.round(datum.y).toString()) : ''}\r\n                style={{\r\n                  data: {\r\n                    fill: (args: any) =>\r\n                      selectedBar?.label === args.datum?.originalName\r\n                        ? colors.accent.orangeLight\r\n                        : colors.accent.orange,\r\n                    width: Math.min(32, (CHART_WIDTH - 100) / chartData.length - 8),\r\n                  },\r\n                  labels: {\r\n                    fill: colors.text.primary,\r\n                    fontSize: 10,\r\n                    fontWeight: '600',\r\n                  },\r\n                }}\r\n                cornerRadius={{ top: 4 }}\r\n                events={[\r\n                  {\r\n                    target: 'data',\r\n                    eventHandlers: {\r\n                      onPressIn: () => [\r\n                        {\r\n                          mutation: (props: any) => {\r\n                            handleBarPress(props.datum.originalName, props.datum.y);\r\n                            return null;\r\n                          },\r\n                        },\r\n                      ],\r\n                    },\r\n                  },\r\n                ]}\r\n              />\r\n            </VictoryChart>\r\n\r\n          </View>\r\n\r\n          {/* Drill down hint below chart */}\r\n          {selectedBar && canDrillDown(selectedBar.label) && (\r\n            <View style={styles.drillHint}>\r\n              <Ionicons name=\"finger-print-outline\" size={14} color={colors.text.tertiary} />\r\n              <Text variant=\"caption\" color=\"tertiary\">Tap again to explore</Text>\r\n            </View>\r\n          )}\r\n\r\n        </ChartWrapper>\r\n      )}\r\n    </View>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    gap: spacing.sm,\r\n    paddingHorizontal: spacing.lg,\r\n  },\r\n  header: {\r\n    alignItems: 'center',\r\n    paddingBottom: spacing.xs,\r\n  },\r\n  breadcrumbContainer: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    flexWrap: 'wrap',\r\n    gap: spacing.xs,\r\n    paddingHorizontal: spacing.sm,\r\n  },\r\n  breadcrumbItem: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    gap: spacing.xs,\r\n  },\r\n  breadcrumbButton: {\r\n    paddingHorizontal: spacing.xs,\r\n    paddingVertical: 2,\r\n    borderRadius: radius.sm,\r\n  },\r\n  breadcrumbButtonActive: {\r\n    backgroundColor: colors.glass.light,\r\n  },\r\n  emptyContainer: {\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    paddingVertical: spacing.xl,\r\n    gap: spacing.xs,\r\n  },\r\n  chartContainer: {\r\n    alignItems: 'center',\r\n    position: 'relative',\r\n  },\r\n  drillHint: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    gap: spacing.xs,\r\n    paddingVertical: spacing.sm,\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\EditableWorkoutExerciseCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\ExerciseFilterGroup.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\ExerciseHistoryModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'weightUnitPref' is assigned a value but never used.","line":40,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":40,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'distanceUnitPref' is assigned a value but never used.","line":41,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":41,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":78,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":78,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useMemo } from 'react';\r\nimport { View, StyleSheet, ScrollView } from 'react-native';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { colors, radius, spacing } from '@/constants/theme';\r\nimport { useWorkoutSessionsStore } from '@/store/workoutSessionsStore';\r\nimport { useSettingsStore } from '@/store/settingsStore';\r\nimport { SheetModal } from './SheetModal';\r\nimport type { ExerciseType } from '@/types/exercise';\r\nimport { exercises as exerciseCatalog } from '@/constants/exercises';\r\n\r\ninterface ExerciseHistoryModalProps {\r\n  visible: boolean;\r\n  onClose: () => void;\r\n  exerciseName: string | null;\r\n  exerciseType?: ExerciseType;\r\n  distanceUnit?: 'miles' | 'meters' | 'floors';\r\n}\r\n\r\n// Format duration for display (e.g., \"5:30\" or \"1:05:30\")\r\nconst formatDurationDisplay = (totalSeconds: number): string => {\r\n  if (!totalSeconds || totalSeconds === 0) return '0:00';\r\n  const hours = Math.floor(totalSeconds / 3600);\r\n  const minutes = Math.floor((totalSeconds % 3600) / 60);\r\n  const seconds = totalSeconds % 60;\r\n  if (hours > 0) {\r\n    return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;\r\n  }\r\n  return `${minutes}:${seconds.toString().padStart(2, '0')}`;\r\n};\r\n\r\nexport const ExerciseHistoryModal: React.FC<ExerciseHistoryModalProps> = ({\r\n  visible,\r\n  onClose,\r\n  exerciseName,\r\n  exerciseType = 'weight',\r\n  distanceUnit,\r\n}) => {\r\n  // Subscribe to unit values to trigger re-renders when units change\r\n  const weightUnitPref = useSettingsStore((state) => state.weightUnit);\r\n  const distanceUnitPref = useSettingsStore((state) => state.distanceUnit);\r\n  const { formatWeight, formatDistanceForExercise } = useSettingsStore();\r\n  \r\n  // Look up distanceUnit from catalog if not provided\r\n  const effectiveDistanceUnit = distanceUnit ?? exerciseCatalog.find(e => e.name === exerciseName)?.distanceUnit;\r\n  const workouts = useWorkoutSessionsStore((state) => state.workouts);\r\n\r\n  const historyData = useMemo(() => {\r\n    if (!exerciseName) return [];\r\n\r\n    return workouts\r\n      .filter((workout) =>\r\n        workout.exercises.some((e) => e.name === exerciseName)\r\n      )\r\n      .map((workout) => {\r\n        const exercise = workout.exercises.find((e) => e.name === exerciseName);\r\n        // Only include completed sets in history\r\n        const completedSets = (exercise?.sets || []).filter((set) => set.completed);\r\n        return {\r\n          date: workout.date,\r\n          sets: completedSets,\r\n        };\r\n      })\r\n      // Filter out workouts with no completed sets for this exercise\r\n      .filter((item) => item.sets.length > 0)\r\n      .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());\r\n  }, [workouts, exerciseName]);\r\n\r\n  // Format date helper\r\n  const formatDate = (dateString: string) => {\r\n    try {\r\n      const date = new Date(dateString);\r\n      return date.toLocaleDateString(undefined, {\r\n        month: 'short',\r\n        day: 'numeric',\r\n        year: 'numeric',\r\n      });\r\n    } catch (e) {\r\n      return dateString;\r\n    }\r\n  };\r\n\r\n  return (\r\n    <SheetModal\r\n      visible={visible}\r\n      onClose={onClose}\r\n      title={exerciseName || 'History'}\r\n    >\r\n      <ScrollView\r\n        style={styles.list}\r\n        contentContainerStyle={styles.listContent}\r\n        nestedScrollEnabled={true}\r\n        scrollEnabled={true}\r\n        bounces={true}\r\n        alwaysBounceVertical={true}\r\n        showsVerticalScrollIndicator={true}\r\n        keyboardShouldPersistTaps=\"handled\"\r\n        scrollEventThrottle={16}\r\n        contentInsetAdjustmentBehavior=\"automatic\"\r\n      >\r\n        {historyData.length === 0 ? (\r\n          <View style={styles.emptyState}>\r\n            <Text color=\"secondary\">No history found for this exercise.</Text>\r\n          </View>\r\n        ) : (\r\n          <View style={styles.contentWrapper}>\r\n            {historyData.map((item, index) => (\r\n              <View key={`${item.date}-${index}`} style={styles.historyItem}>\r\n                <Text variant=\"bodySemibold\" style={styles.dateText}>\r\n                  {formatDate(item.date)}\r\n                </Text>\r\n                <View style={styles.setsContainer}>\r\n                  {item.sets.map((set, i) => (\r\n                    <View key={i} style={styles.setRow}>\r\n                      <Text variant=\"body\" color=\"secondary\">Set {i + 1}</Text>\r\n                      <Text variant=\"bodySemibold\">\r\n                        {exerciseType === 'duration' && (\r\n                          formatDurationDisplay(set.duration ?? 0)\r\n                        )}\r\n                        {exerciseType === 'cardio' && (\r\n                          `${formatDistanceForExercise(set.distance ?? 0, effectiveDistanceUnit)}  ${formatDurationDisplay(set.duration ?? 0)}`\r\n                        )}\r\n                        {(exerciseType === 'bodyweight' || exerciseType === 'reps_only') && (\r\n                          `${set.reps ?? 0} reps`\r\n                        )}\r\n                        {exerciseType === 'assisted' && (\r\n                          `${formatWeight(set.assistanceWeight ?? 0)} assist  ${set.reps ?? 0} reps`\r\n                        )}\r\n                        {exerciseType === 'weight' && (\r\n                          `${formatWeight(set.weight ?? 0)}  ${set.reps ?? 0} reps`\r\n                        )}\r\n                      </Text>\r\n                    </View>\r\n                  ))}\r\n                </View>\r\n              </View>\r\n            ))}\r\n          </View>\r\n        )}\r\n      </ScrollView>\r\n    </SheetModal>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  list: {\r\n    flex: 1,\r\n    width: '100%',\r\n  },\r\n  listContent: {\r\n    padding: spacing.lg,\r\n    paddingBottom: spacing.xl,\r\n    gap: spacing.md,\r\n    flexGrow: 1,\r\n  },\r\n  contentWrapper: {\r\n    gap: spacing.md,\r\n  },\r\n  historyItem: {\r\n    padding: spacing.md,\r\n    borderRadius: radius.md,\r\n    gap: spacing.sm,\r\n    borderWidth: 1,\r\n    borderColor: colors.border.light,\r\n  },\r\n  dateText: {\r\n    marginBottom: spacing.xs,\r\n  },\r\n  setsContainer: {\r\n    gap: spacing.xs,\r\n  },\r\n  setRow: {\r\n    flexDirection: 'row',\r\n    justifyContent: 'space-between',\r\n  },\r\n  emptyState: {\r\n    alignItems: 'center',\r\n    paddingVertical: spacing.xl,\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\ExerciseSearchModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\ExerciseSelectionRow.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\ExerciseSetEditor.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'closeMenu', 'convertDistanceForExercise', 'distanceUnit', 'emitProgress', and 'exerciseType'. Either include them or remove the dependency array.","line":434,"column":6,"nodeType":"ArrayExpression","endLine":434,"endColumn":49,"suggestions":[{"desc":"Update the dependencies array to be: [initialSignature, initialSets, isExpanded, closeMenu, emitProgress, distanceUnit, convertDistanceForExercise, exerciseType]","fix":{"range":[15553,15596],"text":"[initialSignature, initialSets, isExpanded, closeMenu, emitProgress, distanceUnit, convertDistanceForExercise, exerciseType]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'updateSet'. Either include it or remove the dependency array.","line":544,"column":6,"nodeType":"ArrayExpression","endLine":544,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [updateSet]","fix":{"range":[19093,19095],"text":"[updateSet]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The ref value 'timerIntervalsRef.current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy 'timerIntervalsRef.current' to a variable inside the effect, and use that variable in the cleanup function.","line":1054,"column":25,"nodeType":"Identifier","endLine":1054,"endColumn":32}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * ExerciseSetEditor\r\n * Inline drop-down editor for workout exercise sets.\r\n */\r\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\r\nimport { Pressable, ScrollView, StyleSheet, TextInput, View, findNodeHandle, UIManager } from 'react-native';\r\nimport Animated from 'react-native-reanimated';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\nimport { MaterialCommunityIcons } from '@expo/vector-icons';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { HoldRepeatIconButton } from '@/components/atoms/HoldRepeatIconButton';\r\nimport { TimePickerModal } from '@/components/molecules/TimePickerModal';\r\nimport { GpsActivityTracker } from '@/components/molecules/GpsActivityTracker';\r\nimport { colors, radius, shadows, sizing, spacing, zIndex } from '@/constants/theme';\r\nimport type { SetLog } from '@/types/workout';\r\nimport type { ExerciseType } from '@/types/exercise';\r\nimport { useSettingsStore } from '@/store/settingsStore';\r\n\r\ninterface ExerciseSetEditorProps {\r\n  isExpanded: boolean;\r\n  exerciseName: string;\r\n  initialSets: SetLog[];\r\n  onSetsChange: (sets: SetLog[]) => void;\r\n  onProgressChange?: (progress: { completedSets: number; totalSets: number }) => void;\r\n  embedded?: boolean;\r\n  exerciseType?: ExerciseType;\r\n  distanceUnit?: 'miles' | 'meters' | 'floors';\r\n  historySetCount?: number;\r\n  supportsGpsTracking?: boolean;\r\n  // Controlled menu state props (optional)\r\n  activeSetMenuIndex?: number | null;\r\n  onOpenSetMenu?: (index: number) => void;\r\n  onCloseSetMenu?: () => void;\r\n  onShowHistory?: () => void;\r\n  // Keyboard-aware scroll callback\r\n  onInputFocus?: (inputY: number, inputHeight: number) => void;\r\n}\r\n\r\nconst DEFAULT_NEW_SET: SetLog = {\r\n  reps: 8,\r\n  weight: 0,\r\n  completed: false,\r\n};\r\n\r\ninterface SetDraft extends SetLog {\r\n  weightInput: string;\r\n  repsInput: string;\r\n  durationInput: string;      // For cardio (minutes) and duration (seconds) - format HH:MM:SS\r\n  hoursInput: string;         // Hours portion (2 digits max)\r\n  minutesInput: string;       // Minutes portion (2 digits max)\r\n  secondsInput: string;       // Seconds portion (2 digits max, 0-59)\r\n  distanceInput: string;      // For cardio\r\n  assistanceWeightInput: string; // For assisted\r\n}\r\n\r\ntype ActiveSelectionTarget = {\r\n  type: 'weight' | 'reps' | 'hours' | 'minutes' | 'seconds' | 'distance' | 'duration' | 'assistanceWeight';\r\n  index: number;\r\n};\r\n\r\nconst formatWeightInputValue = (value: number): string => {\r\n  return value.toFixed(1);\r\n};\r\n\r\n// Format duration for session input (always HH:MM:SS with 2 digits each)\r\nconst formatDuration = (seconds: number): string => {\r\n  const hours = Math.floor(seconds / 3600);\r\n  const mins = Math.floor((seconds % 3600) / 60);\r\n  const secs = seconds % 60;\r\n  return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\r\n};\r\n\r\n// Format duration for summary display (drop leading zero on hours/minutes)\r\nconst formatDurationForSummary = (seconds: number): string => {\r\n  const hours = Math.floor(seconds / 3600);\r\n  const mins = Math.floor((seconds % 3600) / 60);\r\n  const secs = seconds % 60;\r\n\r\n  if (hours > 0) {\r\n    return `${hours}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\r\n  }\r\n  return `${mins}:${secs.toString().padStart(2, '0')}`;\r\n};\r\n\r\n// Format distance input for the given exercise distance unit.\r\n// - miles: show hundredths (e.g., 1.25)\r\n// - meters/floors: show whole numbers\r\nconst formatDistanceInputValue = (\r\n  value: number,\r\n  distanceUnit: 'miles' | 'meters' | 'floors'\r\n): string => {\r\n  if (!Number.isFinite(value)) {\r\n    return distanceUnit === 'miles' ? '0.00' : '0';\r\n  }\r\n\r\n  if (distanceUnit === 'meters' || distanceUnit === 'floors') {\r\n    return Math.round(value).toString();\r\n  }\r\n\r\n  return value.toFixed(2);\r\n};\r\n\r\nconst createDraftFromSet = (\r\n  set: SetLog,\r\n  options: {\r\n    distanceUnit: 'miles' | 'meters' | 'floors';\r\n    convertDistanceForExercise: (miles: number, distanceUnit?: 'miles' | 'meters' | 'floors') => number;\r\n  }\r\n): SetDraft => {\r\n  const duration = set.duration ?? 0;\r\n  const hours = Math.floor(duration / 3600);\r\n  const mins = Math.floor((duration % 3600) / 60);\r\n  const secs = duration % 60;\r\n\r\n  const baseDistance = set.distance ?? 0;\r\n  const displayDistance = options.convertDistanceForExercise(baseDistance, options.distanceUnit);\r\n\r\n  return {\r\n    ...set,\r\n    weightInput: formatWeightInputValue(set.weight ?? 0),\r\n    repsInput: String(set.reps ?? 0),\r\n    durationInput: formatDuration(duration),\r\n    hoursInput: hours.toString().padStart(2, '0'),\r\n    minutesInput: mins.toString().padStart(2, '0'),\r\n    secondsInput: secs.toString().padStart(2, '0'),\r\n    distanceInput: formatDistanceInputValue(displayDistance, options.distanceUnit),\r\n    assistanceWeightInput: formatWeightInputValue(set.assistanceWeight ?? 0),\r\n  };\r\n};\r\n\r\nconst sanitizeWeightInput = (value: string): string => {\r\n  if (!value) {\r\n    return '';\r\n  }\r\n\r\n  const cleaned = value.replace(/[^0-9.]/g, '');\r\n  if (!cleaned) {\r\n    return '';\r\n  }\r\n\r\n  const [integerPartRaw, ...decimalParts] = cleaned.split('.');\r\n  const integerPart = integerPartRaw.replace(/^0+(?=\\d)/, '') || (decimalParts.length > 0 ? '0' : '');\r\n  const decimalPart = decimalParts.join('').replace(/\\./g, '');\r\n\r\n  // If there's a decimal point in the input, preserve it even if no digits follow\r\n  if (decimalParts.length > 0) {\r\n    return decimalPart.length > 0 ? `${integerPart}.${decimalPart}` : `${integerPart}.`;\r\n  }\r\n\r\n  return integerPart;\r\n};\r\n\r\nconst sanitizeRepsInput = (value: string): string => {\r\n  if (!value) {\r\n    return '';\r\n  }\r\n\r\n  const digitsOnly = value.replace(/[^0-9]/g, '');\r\n  if (!digitsOnly) {\r\n    return '';\r\n  }\r\n\r\n  return digitsOnly.replace(/^0+(?=\\d)/, '');\r\n};\r\n\r\nconst AUTO_SAVE_DEBOUNCE_MS = 100;\r\n\r\nconst mapDraftsToSetLogs = (drafts: SetDraft[]): SetLog[] =>\r\n  drafts.map((draft) => ({\r\n    completed: Boolean(draft.completed),\r\n    // Weight exercises\r\n    reps: draft.reps !== undefined ? Math.max(draft.reps, 0) : undefined,\r\n    weight: draft.weight !== undefined ? Math.max(draft.weight, 0) : undefined,\r\n    // Cardio exercises\r\n    duration: draft.duration !== undefined ? Math.max(draft.duration, 0) : undefined,\r\n    distance: draft.distance !== undefined ? Math.max(draft.distance, 0) : undefined,\r\n    // Assisted exercises\r\n    assistanceWeight: draft.assistanceWeight !== undefined ? Math.max(draft.assistanceWeight, 0) : undefined,\r\n  }));\r\n\r\nexport const ExerciseSetEditor: React.FC<ExerciseSetEditorProps> = ({\r\n  isExpanded,\r\n  exerciseName,\r\n  initialSets,\r\n  onSetsChange,\r\n  onProgressChange,\r\n  embedded = false,\r\n  exerciseType = 'weight',\r\n  distanceUnit = 'miles',\r\n  historySetCount = 0,\r\n  supportsGpsTracking = false,\r\n  activeSetMenuIndex,\r\n  onOpenSetMenu,\r\n  onCloseSetMenu,\r\n  onShowHistory,\r\n  onInputFocus,\r\n}) => {\r\n  // Subscribe to unit values to trigger re-renders when units change\r\n  const distanceUnitPref = useSettingsStore((state) => state.distanceUnit);\r\n  const {\r\n    getWeightUnit,\r\n    getDistanceUnitForExercise,\r\n    formatDistanceForExercise,\r\n    convertDistanceForExercise,\r\n    convertDistanceToMilesForExercise,\r\n  } = useSettingsStore();\r\n  const weightUnit = getWeightUnit();\r\n  const distanceUnitLabel = getDistanceUnitForExercise(distanceUnit);\r\n  const [sets, setSets] = useState<SetDraft[]>(() =>\r\n    initialSets.map((set) =>\r\n      createDraftFromSet(set, {\r\n        distanceUnit,\r\n        convertDistanceForExercise,\r\n      })\r\n    )\r\n  );\r\n  const [openMenuIndex, setOpenMenuIndex] = useState<number | null>(null);\r\n  const [activeSelection, setActiveSelection] = useState<ActiveSelectionTarget | null>(null);\r\n  const [timePickerVisible, setTimePickerVisible] = useState<boolean>(false);\r\n  const [timePickerIndex, setTimePickerIndex] = useState<number>(0);\r\n  const [runningTimers, setRunningTimers] = useState<Set<number>>(new Set());\r\n  const [pausedTimers, setPausedTimers] = useState<Set<number>>(new Set());\r\n  const timerIntervalsRef = useRef<Map<number, NodeJS.Timeout>>(new Map());\r\n  const timerStartTimesRef = useRef<Map<number, number>>(new Map());\r\n  const timerPausedSecondsRef = useRef<Map<number, number>>(new Map());\r\n\r\n  const containerStyle = embedded ? [styles.container, styles.containerEmbedded] : styles.container;\r\n  const contentStyle = embedded ? [styles.contentEmbedded] : styles.content;\r\n  const skipNextEmitRef = useRef(true);\r\n  const emitTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);\r\n  const lastSyncedSignatureRef = useRef<string | null>(null);\r\n  const prevIsExpandedRef = useRef<boolean>(isExpanded);\r\n  const onSetsChangeRef = useRef<(sets: SetLog[]) => void>(onSetsChange);\r\n  const onProgressChangeRef = useRef<((progress: { completedSets: number; totalSets: number }) => void) | null>(\r\n    onProgressChange ?? null,\r\n  );\r\n  const weightInputRefs = useRef<Record<number, TextInput | null>>({});\r\n  const repsInputRefs = useRef<Record<number, TextInput | null>>({});\r\n  const distanceInputRefs = useRef<Record<number, TextInput | null>>({});\r\n  const durationInputRefs = useRef<Record<number, TextInput | null>>({});\r\n  const hoursInputRefs = useRef<Record<number, TextInput | null>>({});\r\n  const minutesInputRefs = useRef<Record<number, TextInput | null>>({});\r\n  const secondsInputRefs = useRef<Record<number, TextInput | null>>({});\r\n  const setsRef = useRef<SetDraft[]>([]);\r\n  const completedSetsRef = useRef(0);\r\n  const totalSetsRef = useRef(0);\r\n\r\n  // Helper to measure input position and notify parent for keyboard-aware scrolling\r\n  const measureAndScrollToInput = useCallback((inputRef: TextInput | null) => {\r\n    if (!inputRef || !onInputFocus) {\r\n      return;\r\n    }\r\n\r\n    const nodeHandle = findNodeHandle(inputRef);\r\n    if (!nodeHandle) {\r\n      return;\r\n    }\r\n\r\n    UIManager.measureInWindow(nodeHandle, (x, y, width, height) => {\r\n      onInputFocus(y, height);\r\n    });\r\n  }, [onInputFocus]);\r\n\r\n  // Helper for controlled vs uncontrolled menu state\r\n  const isMenuControlled = activeSetMenuIndex !== undefined && onOpenSetMenu && onCloseSetMenu;\r\n\r\n  const closeMenu = useCallback(() => {\r\n    if (isMenuControlled) {\r\n      onCloseSetMenu?.();\r\n    } else {\r\n      setOpenMenuIndex(null);\r\n    }\r\n  }, [isMenuControlled, onCloseSetMenu]);\r\n\r\n  const toggleMenu = useCallback((index: number) => {\r\n    if (isMenuControlled) {\r\n      if (activeSetMenuIndex === index) {\r\n        onCloseSetMenu?.();\r\n      } else {\r\n        onOpenSetMenu?.(index);\r\n      }\r\n    } else {\r\n      setOpenMenuIndex((prev) => (prev === index ? null : index));\r\n    }\r\n  }, [isMenuControlled, activeSetMenuIndex, onCloseSetMenu, onOpenSetMenu]);\r\n\r\n  // Determine effective menu state\r\n  const isMenuOpenAtIndex = useCallback((index: number) => {\r\n    if (isMenuControlled) {\r\n      return activeSetMenuIndex === index;\r\n    }\r\n    return openMenuIndex === index;\r\n  }, [isMenuControlled, activeSetMenuIndex, openMenuIndex]);\r\n\r\n  const initialSignature = useMemo(() => JSON.stringify(initialSets), [initialSets]);\r\n\r\n  useEffect(() => {\r\n    onSetsChangeRef.current = onSetsChange;\r\n  }, [onSetsChange]);\r\n\r\n  useEffect(() => {\r\n    onProgressChangeRef.current = onProgressChange ?? null;\r\n  }, [onProgressChange]);\r\n\r\n  useEffect(() => {\r\n    setsRef.current = sets;\r\n  }, [sets]);\r\n\r\n  // If the user changes distance units, update the *display* text for any existing\r\n  // cardio sets without mutating the stored base values (miles/meters/floors).\r\n  useEffect(() => {\r\n    if (!isExpanded || exerciseType !== 'cardio') {\r\n      return;\r\n    }\r\n\r\n    setSets((prev) => {\r\n      const next = prev.map((draft) => {\r\n        const baseDistance = draft.distance ?? 0;\r\n        const displayDistance = convertDistanceForExercise(baseDistance, distanceUnit);\r\n        const nextInput = formatDistanceInputValue(displayDistance, distanceUnit);\r\n\r\n        if (draft.distanceInput === nextInput) {\r\n          return draft;\r\n        }\r\n\r\n        return {\r\n          ...draft,\r\n          distanceInput: nextInput,\r\n        };\r\n      });\r\n\r\n      setsRef.current = next;\r\n\r\n      // Keep TextInput native values in sync for immediate visual updates.\r\n      setTimeout(() => {\r\n        next.forEach((draft, index) => {\r\n          const distanceRef = distanceInputRefs.current[index];\r\n          if (distanceRef) {\r\n            distanceRef.setNativeProps({ text: draft.distanceInput });\r\n          }\r\n        });\r\n      }, 0);\r\n\r\n      return next;\r\n    });\r\n  }, [distanceUnitPref, distanceUnit, convertDistanceForExercise, isExpanded, exerciseType]);\r\n\r\n\r\n  useEffect(() => {\r\n    const wasExpanded = prevIsExpandedRef.current;\r\n    prevIsExpandedRef.current = isExpanded;\r\n\r\n    if (!isExpanded) {\r\n      return;\r\n    }\r\n\r\n    // Update sets when exercise is first expanded OR when initialSets change\r\n    const shouldUpdateSets = !wasExpanded || lastSyncedSignatureRef.current !== initialSignature;\r\n\r\n    if (!shouldUpdateSets) {\r\n      return;\r\n    }\r\n\r\n    // Check if we need to sync completion state\r\n    const currentCompletedSets = setsRef.current.filter((set) => set.completed).length;\r\n    const initialCompletedSets = initialSets.filter((set) => set.completed).length;\r\n\r\n    // Only update if the completion state differs, to avoid interrupting user editing\r\n    if (wasExpanded && currentCompletedSets === initialCompletedSets) {\r\n      lastSyncedSignatureRef.current = initialSignature;\r\n      return;\r\n    }\r\n\r\n    skipNextEmitRef.current = true;\r\n    const nextDrafts = initialSets.map((set) =>\r\n      createDraftFromSet(set, {\r\n        distanceUnit,\r\n        convertDistanceForExercise,\r\n      })\r\n    );\r\n    setsRef.current = nextDrafts;\r\n    totalSetsRef.current = nextDrafts.length;\r\n    completedSetsRef.current = nextDrafts.filter((set) => set.completed).length;\r\n    setSets(nextDrafts);\r\n    closeMenu();\r\n    lastSyncedSignatureRef.current = initialSignature;\r\n\r\n    // Clear timer states when sets are refreshed (e.g., after completing and reopening a set)\r\n    setRunningTimers(new Set());\r\n    setPausedTimers(new Set());\r\n    timerIntervalsRef.current.forEach(interval => clearInterval(interval));\r\n    timerIntervalsRef.current.clear();\r\n    timerStartTimesRef.current.clear();\r\n    timerPausedSecondsRef.current.clear();\r\n\r\n    emitProgress();\r\n\r\n    setTimeout(() => {\r\n      nextDrafts.forEach((draft, index) => {\r\n        const weightRef = weightInputRefs.current[index];\r\n        const repsRef = repsInputRefs.current[index];\r\n        const distanceRef = distanceInputRefs.current[index];\r\n        const durationRef = durationInputRefs.current[index];\r\n        const minutesRef = minutesInputRefs.current[index];\r\n        const secondsRef = secondsInputRefs.current[index];\r\n\r\n        if (weightRef) {\r\n          const text = exerciseType === 'assisted' ? draft.assistanceWeightInput : draft.weightInput;\r\n          weightRef.setNativeProps({ text });\r\n        }\r\n\r\n        if (repsRef) {\r\n          repsRef.setNativeProps({ text: draft.repsInput });\r\n        }\r\n\r\n        if (distanceRef) {\r\n          distanceRef.setNativeProps({ text: draft.distanceInput });\r\n        }\r\n\r\n        if (durationRef) {\r\n          durationRef.setNativeProps({ text: draft.durationInput });\r\n        }\r\n\r\n        if (minutesRef) {\r\n          minutesRef.setNativeProps({ text: draft.minutesInput });\r\n        }\r\n\r\n        if (secondsRef) {\r\n          secondsRef.setNativeProps({ text: draft.secondsInput });\r\n        }\r\n      });\r\n    }, 0);\r\n  }, [initialSignature, initialSets, isExpanded]);\r\n\r\n  const hasSets = useMemo(() => sets.length > 0, [sets.length]);\r\n\r\n  const emitProgress = useCallback(() => {\r\n    if (!onProgressChangeRef.current) {\r\n      return;\r\n    }\r\n\r\n    onProgressChangeRef.current({ completedSets: completedSetsRef.current, totalSets: totalSetsRef.current });\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    if (skipNextEmitRef.current) {\r\n      skipNextEmitRef.current = false;\r\n      return;\r\n    }\r\n\r\n    if (emitTimerRef.current) {\r\n      clearTimeout(emitTimerRef.current);\r\n    }\r\n\r\n    emitTimerRef.current = setTimeout(() => {\r\n      const nextSets = mapDraftsToSetLogs(sets);\r\n      lastSyncedSignatureRef.current = JSON.stringify(nextSets);\r\n      onSetsChangeRef.current(nextSets);\r\n    }, AUTO_SAVE_DEBOUNCE_MS);\r\n  }, [sets]);\r\n\r\n  useEffect(() => {\r\n    return () => {\r\n      if (emitTimerRef.current) {\r\n        clearTimeout(emitTimerRef.current);\r\n        emitTimerRef.current = null;\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  const updateSet = useCallback((index: number, updater: Partial<SetDraft> | ((current: SetDraft) => Partial<SetDraft>)) => {\r\n    setSets((prev) => {\r\n      const current = prev[index];\r\n      if (!current) return prev;\r\n      const updates = typeof updater === 'function' ? updater(current) : updater;\r\n      const next = [...prev];\r\n      next[index] = { ...current, ...updates };\r\n      setsRef.current = next;\r\n      return next;\r\n    });\r\n  }, []);\r\n\r\n  const adjustSetValue = useCallback((index: number, field: 'weight' | 'reps' | 'assistanceWeight', delta: number) => {\r\n    const current = setsRef.current[index];\r\n    if (!current) {\r\n      return;\r\n    }\r\n\r\n    const repsInputRef = repsInputRefs.current[index];\r\n\r\n    const currentValue = (current[field] ?? 0) as number;\r\n\r\n    if (field === 'reps') {\r\n      const nextValue = Math.max(0, Math.round(currentValue + delta));\r\n      const nextText = String(nextValue);\r\n\r\n      // Update input field FIRST for instant visual feedback\r\n      if (repsInputRef) {\r\n        // Use setNativeProps for instant update without React re-render\r\n        repsInputRef.setNativeProps({\r\n          text: nextText,\r\n          // Prevent cursor movement/selection issues\r\n          selection: { start: nextText.length, end: nextText.length }\r\n        });\r\n      }\r\n\r\n      // Update refs immediately without triggering React re-render\r\n      const next = [...setsRef.current];\r\n      next[index] = { ...current, reps: nextValue, repsInput: nextText };\r\n      setsRef.current = next;\r\n\r\n      // Defer React state update to avoid blocking the UI\r\n      setTimeout(() => {\r\n        setSets(next);\r\n      }, 0);\r\n      return;\r\n    }\r\n\r\n    // For weight/assistanceWeight, use the existing logic\r\n    const weightInputRef = weightInputRefs.current[index];\r\n\r\n    const isMultipleOf2_5 = currentValue % 2.5 === 0;\r\n    let nextValue: number;\r\n    if (!isMultipleOf2_5) {\r\n      nextValue = delta > 0 ? Math.ceil(currentValue / 2.5) * 2.5 : Math.floor(currentValue / 2.5) * 2.5;\r\n    } else {\r\n      nextValue = currentValue + delta;\r\n    }\r\n\r\n    nextValue = Math.max(0, Number.parseFloat(nextValue.toFixed(1)));\r\n    const nextText = formatWeightInputValue(nextValue);\r\n\r\n    if (weightInputRef) {\r\n      weightInputRef.setNativeProps({ text: nextText });\r\n    }\r\n\r\n    if (field === 'assistanceWeight') {\r\n      updateSet(index, { assistanceWeight: nextValue, assistanceWeightInput: nextText });\r\n      return;\r\n    }\r\n\r\n    updateSet(index, { weight: nextValue, weightInput: nextText });\r\n  }, []);\r\n\r\n  const addSet = useCallback(() => {\r\n    triggerHaptic('selection');\r\n    setSets((prev) => {\r\n      // Find the last completed set to use its values\r\n      const lastCompletedSet = [...prev].reverse().find((set) => set.completed);\r\n\r\n      // Priority:\r\n      // 1. Use last completed set's values (if any sets have been completed in this session)\r\n      // 2. Use last history set's values (if there's history data)\r\n      // 3. Fall back to defaults\r\n      let sourceSet: SetDraft | null = null;\r\n\r\n      if (lastCompletedSet) {\r\n        // Use the last completed set from this session\r\n        sourceSet = lastCompletedSet;\r\n      } else if (historySetCount > 0 && prev.length > 0) {\r\n        // Use the last history set (or last available set if fewer sets than history)\r\n        const lastHistoryIndex = Math.min(historySetCount - 1, prev.length - 1);\r\n        sourceSet = prev[lastHistoryIndex];\r\n      }\r\n\r\n      let newSetLog: SetLog;\r\n      if (sourceSet) {\r\n        newSetLog = {\r\n          weight: sourceSet.weight ?? 0,\r\n          reps: sourceSet.reps ?? 8,\r\n          // Timed exercises (cardio and duration) should always start at 0\r\n          duration: (exerciseType === 'cardio' || exerciseType === 'duration') ? 0 : (sourceSet.duration ?? 0),\r\n          distance: sourceSet.distance ?? 0,\r\n          assistanceWeight: sourceSet.assistanceWeight ?? 0,\r\n          completed: false,\r\n        };\r\n      } else {\r\n        newSetLog = DEFAULT_NEW_SET;\r\n      }\r\n\r\n      const newSetValues = createDraftFromSet(newSetLog, {\r\n        distanceUnit,\r\n        convertDistanceForExercise,\r\n      });\r\n\r\n      const next = [...prev, newSetValues];\r\n      setsRef.current = next;\r\n      totalSetsRef.current = next.length;\r\n      completedSetsRef.current = next.filter((set) => set.completed).length;\r\n      setTimeout(emitProgress, 0);\r\n      return next;\r\n    });\r\n  }, [emitProgress, historySetCount, exerciseType, distanceUnit, convertDistanceForExercise]);\r\n\r\n  const removeSet = useCallback((index: number) => {\r\n    triggerHaptic('selection');\r\n    setSets((prev) => prev.filter((_, idx) => idx !== index));\r\n    const next = setsRef.current.filter((_, idx) => idx !== index);\r\n    setsRef.current = next;\r\n    totalSetsRef.current = next.length;\r\n    completedSetsRef.current = next.filter((set) => set.completed).length;\r\n    closeMenu();\r\n    setTimeout(emitProgress, 0);\r\n  }, [emitProgress, closeMenu]);\r\n\r\n  const handleWeightInput = useCallback((index: number, value: string) => {\r\n    const sanitized = sanitizeWeightInput(value);\r\n    const parsed = sanitized.length > 0 ? Number.parseFloat(sanitized) : null;\r\n    setActiveSelection(null);\r\n\r\n    const weightInputRef = weightInputRefs.current[index];\r\n    if (weightInputRef && sanitized !== value) {\r\n      weightInputRef.setNativeProps({ text: sanitized });\r\n    }\r\n\r\n    if (exerciseType === 'assisted') {\r\n      updateSet(index, {\r\n        assistanceWeightInput: sanitized,\r\n        assistanceWeight: parsed === null || Number.isNaN(parsed) ? 0 : parsed,\r\n      });\r\n      return;\r\n    }\r\n\r\n    updateSet(index, {\r\n      weightInput: sanitized,\r\n      weight: parsed === null || Number.isNaN(parsed) ? 0 : parsed,\r\n    });\r\n  }, [exerciseType, updateSet]);\r\n\r\n  const handleRepsInput = useCallback((index: number, value: string) => {\r\n    const sanitized = sanitizeRepsInput(value);\r\n    const parsed = sanitized.length > 0 ? Number.parseInt(sanitized, 10) : null;\r\n    setActiveSelection(null);\r\n\r\n    const repsInputRef = repsInputRefs.current[index];\r\n    if (repsInputRef && sanitized !== value) {\r\n      repsInputRef.setNativeProps({ text: sanitized });\r\n    }\r\n\r\n    updateSet(index, {\r\n      repsInput: sanitized,\r\n      reps: parsed === null || Number.isNaN(parsed) ? 0 : parsed,\r\n    });\r\n  }, [updateSet]);\r\n\r\n  const handleWeightBlur = useCallback((index: number) => {\r\n    setActiveSelection(null);\r\n\r\n    const weightInputRef = weightInputRefs.current[index];\r\n\r\n    setSets((prev) =>\r\n      prev.map((set, idx) => {\r\n        const shouldDefaultToZero = exerciseType === 'assisted' ? set.assistanceWeightInput.length === 0 : set.weightInput.length === 0;\r\n        if (idx !== index || !shouldDefaultToZero) {\r\n          return set;\r\n        }\r\n\r\n        if (weightInputRef) {\r\n          weightInputRef.setNativeProps({ text: formatWeightInputValue(0) });\r\n        }\r\n\r\n        return {\r\n          ...set,\r\n          weight: exerciseType === 'assisted' ? set.weight : 0,\r\n          weightInput: exerciseType === 'assisted' ? set.weightInput : formatWeightInputValue(0),\r\n          assistanceWeight: exerciseType === 'assisted' ? 0 : set.assistanceWeight,\r\n          assistanceWeightInput: exerciseType === 'assisted' ? formatWeightInputValue(0) : set.assistanceWeightInput,\r\n        };\r\n      }),\r\n    );\r\n  }, [exerciseType]);\r\n\r\n  const handleDistanceInput = useCallback((index: number, value: string) => {\r\n    const sanitized = sanitizeWeightInput(value);\r\n    const parsed = sanitized.length > 0 ? Number.parseFloat(sanitized) : null;\r\n    setActiveSelection(null);\r\n\r\n    const distanceInputRef = distanceInputRefs.current[index];\r\n    if (distanceInputRef && sanitized !== value) {\r\n      distanceInputRef.setNativeProps({ text: sanitized });\r\n    }\r\n\r\n    // Convert from display unit to miles for storage\r\n    const displayValue = parsed === null || Number.isNaN(parsed) ? 0 : parsed;\r\n    const distanceInMiles = convertDistanceToMilesForExercise(displayValue, distanceUnit);\r\n\r\n    updateSet(index, {\r\n      distanceInput: sanitized,\r\n      distance: Math.round(distanceInMiles * 100) / 100,\r\n    });\r\n  }, [updateSet, convertDistanceToMilesForExercise, distanceUnit]);\r\n\r\n  const handleDistanceFocus = useCallback((index: number) => {\r\n    setActiveSelection({ type: 'distance', index });\r\n    measureAndScrollToInput(distanceInputRefs.current[index]);\r\n  }, [measureAndScrollToInput]);\r\n\r\n  const handleDistanceBlur = useCallback((index: number) => {\r\n    setActiveSelection(null);\r\n\r\n    const distanceInputRef = distanceInputRefs.current[index];\r\n\r\n    setSets((prev) =>\r\n      prev.map((set, idx) => {\r\n        const shouldDefaultToZero = set.distanceInput.length === 0;\r\n        if (idx !== index || !shouldDefaultToZero) {\r\n          return set;\r\n        }\r\n\r\n        const zeroText = formatDistanceInputValue(0, distanceUnit);\r\n\r\n        if (distanceInputRef) {\r\n          distanceInputRef.setNativeProps({ text: zeroText });\r\n        }\r\n\r\n        return {\r\n          ...set,\r\n          distance: 0,\r\n          distanceInput: zeroText,\r\n        };\r\n      }),\r\n    );\r\n  }, [distanceUnit]);\r\n\r\n  const handleRepsBlur = useCallback((index: number) => {\r\n    setActiveSelection(null);\r\n\r\n    const repsInputRef = repsInputRefs.current[index];\r\n\r\n    setSets((prev) =>\r\n      prev.map((set, idx) => {\r\n        if (idx !== index || set.repsInput.length > 0) {\r\n          return set;\r\n        }\r\n\r\n        if (repsInputRef) {\r\n          repsInputRef.setNativeProps({ text: '0' });\r\n        }\r\n\r\n        return {\r\n          ...set,\r\n          reps: 0,\r\n          repsInput: '0',\r\n        };\r\n      }),\r\n    );\r\n  }, []);\r\n\r\n  const toggleSetCompletion = useCallback((index: number) => {\r\n    triggerHaptic('selection');\r\n\r\n    // Blur any currently focused input and clear selection state immediately\r\n    setActiveSelection((current) => {\r\n      if (current) {\r\n        const currentWeightRef = weightInputRefs.current[current.index];\r\n        const currentRepsRef = repsInputRefs.current[current.index];\r\n        const currentDistanceRef = distanceInputRefs.current[current.index];\r\n        const currentDurationRef = durationInputRefs.current[current.index];\r\n\r\n        if (current.type === 'weight') {\r\n          currentWeightRef?.blur?.();\r\n        }\r\n\r\n        if (current.type === 'reps') {\r\n          currentRepsRef?.blur?.();\r\n        }\r\n\r\n        if (current.type === 'distance') {\r\n          currentDistanceRef?.blur?.();\r\n        }\r\n\r\n        if (current.type === 'duration') {\r\n          currentDurationRef?.blur?.();\r\n        }\r\n\r\n        if (current.type === 'hours') {\r\n          hoursInputRefs.current[current.index]?.blur?.();\r\n        }\r\n\r\n        if (current.type === 'minutes') {\r\n          minutesInputRefs.current[current.index]?.blur?.();\r\n        }\r\n\r\n        if (current.type === 'seconds') {\r\n          secondsInputRefs.current[current.index]?.blur?.();\r\n        }\r\n\r\n        if (current.type === 'assistanceWeight') {\r\n          currentWeightRef?.blur?.();\r\n        }\r\n      }\r\n      return null;\r\n    });\r\n    const prev = setsRef.current;\r\n    if (!prev[index]) {\r\n      return;\r\n    }\r\n\r\n    const updatedSets = prev.map((set, idx) => {\r\n      if (idx === index) {\r\n        return { ...set, completed: !set.completed };\r\n      }\r\n      return set;\r\n    });\r\n\r\n    const justCompleted = !prev[index].completed && updatedSets[index].completed;\r\n\r\n    if (justCompleted) {\r\n      // Stop timer if this is a timed exercise and timer is running\r\n      if (exerciseType === 'duration' && (runningTimers.has(index) || pausedTimers.has(index))) {\r\n        const interval = timerIntervalsRef.current.get(index);\r\n        if (interval) {\r\n          clearInterval(interval);\r\n          timerIntervalsRef.current.delete(index);\r\n        }\r\n        timerStartTimesRef.current.delete(index);\r\n        timerPausedSecondsRef.current.delete(index);\r\n        setRunningTimers(prev => {\r\n          const next = new Set(prev);\r\n          next.delete(index);\r\n          return next;\r\n        });\r\n        setPausedTimers(prev => {\r\n          const next = new Set(prev);\r\n          next.delete(index);\r\n          return next;\r\n        });\r\n      }\r\n\r\n      const completedSet = updatedSets[index];\r\n      const nextUncompletedIndex = updatedSets.findIndex((set, idx) => idx > index && !set.completed);\r\n      if (nextUncompletedIndex !== -1 && nextUncompletedIndex >= historySetCount) {\r\n        const nextSet = updatedSets[nextUncompletedIndex];\r\n        updatedSets[nextUncompletedIndex] = {\r\n          ...nextSet,\r\n          weight: completedSet.weight ?? 0,\r\n          reps: completedSet.reps ?? 8,\r\n          weightInput: formatWeightInputValue(completedSet.weight ?? 0),\r\n          repsInput: String(completedSet.reps ?? 8),\r\n          duration: completedSet.duration,\r\n          distance: completedSet.distance,\r\n          durationInput: completedSet.durationInput,\r\n          distanceInput: completedSet.distanceInput,\r\n          assistanceWeight: completedSet.assistanceWeight,\r\n          assistanceWeightInput: completedSet.assistanceWeightInput,\r\n        };\r\n      }\r\n    }\r\n\r\n    setsRef.current = updatedSets;\r\n    totalSetsRef.current = updatedSets.length;\r\n    completedSetsRef.current = updatedSets.filter((set) => set.completed).length;\r\n    setSets(updatedSets);\r\n    emitProgress();\r\n  }, [emitProgress, exerciseType, historySetCount, runningTimers, pausedTimers]);\r\n\r\n  const handleCompleteSetPress = useCallback((index: number) => {\r\n    toggleSetCompletion(index);\r\n  }, [toggleSetCompletion]);\r\n\r\n  const handleWeightFocus = useCallback((index: number) => {\r\n    setActiveSelection({ type: 'weight', index });\r\n    measureAndScrollToInput(weightInputRefs.current[index]);\r\n  }, [measureAndScrollToInput]);\r\n\r\n  const handleRepsFocus = useCallback((index: number) => {\r\n    setActiveSelection({ type: 'reps', index });\r\n    measureAndScrollToInput(repsInputRefs.current[index]);\r\n  }, [measureAndScrollToInput]);\r\n\r\n  const handleGpsActivityComplete = useCallback((durationSeconds: number, distanceMiles: number) => {\r\n    const displayDistance = convertDistanceForExercise(distanceMiles, distanceUnit);\r\n    const completedSet: SetDraft = {\r\n      completed: true,\r\n      duration: durationSeconds,\r\n      distance: distanceMiles,\r\n      weightInput: '0',\r\n      repsInput: '0',\r\n      durationInput: formatDuration(durationSeconds),\r\n      hoursInput: Math.floor(durationSeconds / 3600).toString().padStart(2, '0'),\r\n      minutesInput: Math.floor((durationSeconds % 3600) / 60).toString().padStart(2, '0'),\r\n      secondsInput: (durationSeconds % 60).toString().padStart(2, '0'),\r\n      distanceInput: formatDistanceInputValue(displayDistance, distanceUnit),\r\n      assistanceWeightInput: '0',\r\n    };\r\n\r\n    const updatedSets = [completedSet];\r\n    setsRef.current = updatedSets;\r\n    totalSetsRef.current = 1;\r\n    completedSetsRef.current = 1;\r\n    setSets(updatedSets);\r\n    emitProgress();\r\n  }, [emitProgress, convertDistanceForExercise, distanceUnit]);\r\n\r\n  const openTimePicker = useCallback((index: number) => {\r\n    triggerHaptic('selection');\r\n    setTimePickerIndex(index);\r\n    setTimePickerVisible(true);\r\n  }, []);\r\n\r\n  const handleTimePickerConfirm = useCallback((totalSeconds: number) => {\r\n    const hours = Math.floor(totalSeconds / 3600);\r\n    const mins = Math.floor((totalSeconds % 3600) / 60);\r\n    const secs = totalSeconds % 60;\r\n\r\n    const next = [...setsRef.current];\r\n    next[timePickerIndex] = {\r\n      ...next[timePickerIndex],\r\n      duration: totalSeconds,\r\n      durationInput: formatDuration(totalSeconds),\r\n      hoursInput: hours.toString().padStart(2, '0'),\r\n      minutesInput: mins.toString().padStart(2, '0'),\r\n      secondsInput: secs.toString().padStart(2, '0'),\r\n    };\r\n    setsRef.current = next;\r\n    setSets(next);\r\n    setTimePickerVisible(false);\r\n  }, [timePickerIndex]);\r\n\r\n  const startTimer = useCallback((index: number) => {\r\n    triggerHaptic('selection');\r\n\r\n    // Clear any existing interval for this index\r\n    const existingInterval = timerIntervalsRef.current.get(index);\r\n    if (existingInterval) {\r\n      clearInterval(existingInterval);\r\n    }\r\n\r\n    // Store start time and initial paused seconds\r\n    const currentSet = setsRef.current[index];\r\n    const initialSeconds = currentSet?.duration ?? 0;\r\n    timerStartTimesRef.current.set(index, Date.now());\r\n    timerPausedSecondsRef.current.set(index, initialSeconds);\r\n\r\n    // Start interval\r\n    const interval = setInterval(() => {\r\n      const startTime = timerStartTimesRef.current.get(index) ?? Date.now();\r\n      const pausedSeconds = timerPausedSecondsRef.current.get(index) ?? 0;\r\n      const elapsed = Math.floor((Date.now() - startTime) / 1000);\r\n      const totalSeconds = pausedSeconds + elapsed;\r\n\r\n      const hours = Math.floor(totalSeconds / 3600);\r\n      const mins = Math.floor((totalSeconds % 3600) / 60);\r\n      const secs = totalSeconds % 60;\r\n\r\n      const next = [...setsRef.current];\r\n      next[index] = {\r\n        ...next[index],\r\n        duration: totalSeconds,\r\n        durationInput: formatDuration(totalSeconds),\r\n        hoursInput: hours.toString().padStart(2, '0'),\r\n        minutesInput: mins.toString().padStart(2, '0'),\r\n        secondsInput: secs.toString().padStart(2, '0'),\r\n      };\r\n      setsRef.current = next;\r\n      setSets(next);\r\n    }, 1000);\r\n\r\n    timerIntervalsRef.current.set(index, interval);\r\n    setRunningTimers(prev => new Set(prev).add(index));\r\n    setPausedTimers(prev => {\r\n      const next = new Set(prev);\r\n      next.delete(index);\r\n      return next;\r\n    });\r\n  }, []);\r\n\r\n  const pauseTimer = useCallback((index: number) => {\r\n    triggerHaptic('selection');\r\n\r\n    const interval = timerIntervalsRef.current.get(index);\r\n    if (interval) {\r\n      clearInterval(interval);\r\n      timerIntervalsRef.current.delete(index);\r\n    }\r\n\r\n    // Store current duration as paused seconds\r\n    const currentSet = setsRef.current[index];\r\n    timerPausedSecondsRef.current.set(index, currentSet?.duration ?? 0);\r\n\r\n    setRunningTimers(prev => {\r\n      const next = new Set(prev);\r\n      next.delete(index);\r\n      return next;\r\n    });\r\n    setPausedTimers(prev => new Set(prev).add(index));\r\n  }, []);\r\n\r\n  const stopTimer = useCallback((index: number) => {\r\n    triggerHaptic('selection');\r\n\r\n    const interval = timerIntervalsRef.current.get(index);\r\n    if (interval) {\r\n      clearInterval(interval);\r\n      timerIntervalsRef.current.delete(index);\r\n    }\r\n\r\n    // Keep the elapsed time but transition to paused state\r\n    const currentSet = setsRef.current[index];\r\n    timerPausedSecondsRef.current.set(index, currentSet?.duration ?? 0);\r\n    timerStartTimesRef.current.delete(index);\r\n\r\n    setRunningTimers(prev => {\r\n      const next = new Set(prev);\r\n      next.delete(index);\r\n      return next;\r\n    });\r\n    setPausedTimers(prev => new Set(prev).add(index));\r\n  }, []);\r\n\r\n  const resetTimer = useCallback((index: number) => {\r\n    triggerHaptic('selection');\r\n\r\n    // Clear all timer state\r\n    const interval = timerIntervalsRef.current.get(index);\r\n    if (interval) {\r\n      clearInterval(interval);\r\n      timerIntervalsRef.current.delete(index);\r\n    }\r\n\r\n    timerStartTimesRef.current.delete(index);\r\n    timerPausedSecondsRef.current.delete(index);\r\n\r\n    // Reset to zero\r\n    const next = [...setsRef.current];\r\n    next[index] = {\r\n      ...next[index],\r\n      duration: 0,\r\n      durationInput: '00:00',\r\n      hoursInput: '00',\r\n      minutesInput: '00',\r\n      secondsInput: '00',\r\n    };\r\n    setsRef.current = next;\r\n    setSets(next);\r\n\r\n    setRunningTimers(prev => {\r\n      const next = new Set(prev);\r\n      next.delete(index);\r\n      return next;\r\n    });\r\n    setPausedTimers(prev => {\r\n      const next = new Set(prev);\r\n      next.delete(index);\r\n      return next;\r\n    });\r\n  }, []);\r\n\r\n  // Cleanup timers on unmount\r\n  useEffect(() => {\r\n    return () => {\r\n      timerIntervalsRef.current.forEach(interval => clearInterval(interval));\r\n      timerIntervalsRef.current.clear();\r\n    };\r\n  }, []);\r\n\r\n  if (!isExpanded) {\r\n    return null;\r\n  }\r\n\r\n  return (\r\n    <Animated.View\r\n      style={containerStyle}\r\n    >\r\n      <ScrollView\r\n        stickyHeaderIndices={embedded ? undefined : [0]}\r\n        contentContainerStyle={contentStyle}\r\n        keyboardShouldPersistTaps=\"handled\"\r\n      >\r\n        {embedded ? null : (\r\n          <View style={styles.headerRow}>\r\n            <Text variant=\"heading2\" color=\"primary\">\r\n              {exerciseName}\r\n            </Text>\r\n          </View>\r\n        )}\r\n        {supportsGpsTracking ? (\r\n          <GpsActivityTracker\r\n            onComplete={handleGpsActivityComplete}\r\n            distanceUnit={distanceUnit}\r\n          />\r\n        ) : hasSets ? (\r\n          sets.map((set, index) => {\r\n            const isCompleted = set.completed;\r\n\r\n            // Generate summary text based on exercise type\r\n            let summaryText = '';\r\n            switch (exerciseType) {\r\n              case 'cardio':\r\n                summaryText = `${formatDistanceForExercise(set.distance ?? 0, distanceUnit)}  ${formatDurationForSummary(set.duration ?? 0)}`;\r\n                break;\r\n              case 'bodyweight':\r\n              case 'reps_only':\r\n                summaryText = `${set.reps ?? 0} reps`;\r\n                break;\r\n              case 'assisted':\r\n                summaryText = `${set.assistanceWeight ?? 0} ${weightUnit} assist  ${set.reps ?? 0} reps`;\r\n                break;\r\n              case 'duration':\r\n                summaryText = formatDurationForSummary(set.duration ?? 0);\r\n                break;\r\n              case 'weight':\r\n              default:\r\n                summaryText = `${set.weight ?? 0} ${weightUnit}  ${set.reps ?? 0} reps`;\r\n            }\r\n\r\n            return (\r\n              <View\r\n                key={`set-${index}`}\r\n                style={[\r\n                  styles.setCard,\r\n                  isCompleted ? styles.setCardCompleted : null,\r\n                  index > 0 ? styles.setCardSpacer : null,\r\n                ]}\r\n              >\r\n                {isCompleted ? (\r\n                  <Pressable\r\n                    style={styles.completedRow}\r\n                    onPress={() => toggleSetCompletion(index)}\r\n                    accessibilityRole=\"button\"\r\n                    accessibilityLabel={`Edit set ${index + 1}`}\r\n                  >\r\n                    <Text variant=\"bodySemibold\" color=\"onAccent\">\r\n                      {summaryText}\r\n                    </Text>\r\n                  </Pressable>\r\n                ) : (\r\n                  <>\r\n                    <View style={styles.setHeader} pointerEvents=\"box-none\">\r\n                      <Text variant=\"bodySemibold\" color=\"primary\">\r\n                        Set {index + 1}\r\n                      </Text>\r\n                      <Pressable\r\n                        onPress={(event) => {\r\n                          event.stopPropagation();\r\n                          toggleMenu(index);\r\n                        }}\r\n                        hitSlop={spacing.xs}\r\n                        style={styles.menuButton}\r\n                        accessibilityRole=\"button\"\r\n                        accessibilityLabel={`Open menu for set ${index + 1}`}\r\n                      >\r\n                        <MaterialCommunityIcons\r\n                          name=\"dots-vertical\"\r\n                          size={sizing.iconSM}\r\n                          color={colors.overlay.navigation}\r\n                        />\r\n                      </Pressable>\r\n                      {isMenuOpenAtIndex(index) ? (\r\n                        <View style={styles.menuPopover} pointerEvents=\"box-none\">\r\n                          {onShowHistory && (\r\n                            <Pressable\r\n                              style={styles.menuItem}\r\n                              onPress={() => {\r\n                                closeMenu();\r\n                                onShowHistory();\r\n                              }}\r\n                            >\r\n                              <Text variant=\"body\">History</Text>\r\n                            </Pressable>\r\n                          )}\r\n                          <Pressable\r\n                            style={styles.menuItem}\r\n                            onPress={() => {\r\n                              removeSet(index); // removeSet now calls closeMenu\r\n                            }}\r\n                          >\r\n                            <Text variant=\"body\">Remove set</Text>\r\n                          </Pressable>\r\n                        </View>\r\n                      ) : null}\r\n                    </View>\r\n\r\n                    {/* Type-specific input fields */}\r\n                    {(exerciseType === 'weight' || exerciseType === 'assisted') && (\r\n                      <View style={styles.metricSection} pointerEvents=\"box-none\">\r\n                        <Text variant=\"label\" color=\"neutral\" style={styles.metricLabel}>\r\n                          {exerciseType === 'assisted' ? `Assistance (${weightUnit})` : `Weight (${weightUnit})`}\r\n                        </Text>\r\n                        <View style={styles.metricControls}>\r\n                          <HoldRepeatIconButton\r\n                            iconName=\"minus\"\r\n                            style={styles.adjustButton}\r\n                            accessibilityLabel={`Decrease weight for set ${index + 1}`}\r\n                            onStep={() => adjustSetValue(index, exerciseType === 'assisted' ? 'assistanceWeight' : 'weight', exerciseType === 'assisted' ? -5 : -2.5)}\r\n                          />\r\n                          <TextInput\r\n                            ref={(ref) => {\r\n                              weightInputRefs.current[index] = ref;\r\n                            }}\r\n                            value={exerciseType === 'assisted' ? set.assistanceWeightInput : set.weightInput}\r\n                            onChangeText={(value) => handleWeightInput(index, value)}\r\n                            keyboardType=\"decimal-pad\"\r\n                            style={styles.metricValue}\r\n                            textAlign=\"center\"\r\n                            placeholder=\"0\"\r\n                            placeholderTextColor={colors.text.tertiary}\r\n                            cursorColor={colors.accent.primary}\r\n                            selectionColor={colors.accent.orangeLight}\r\n                            selection={\r\n                              activeSelection?.type === 'weight' && activeSelection.index === index\r\n                                ? { start: 0, end: (exerciseType === 'assisted' ? set.assistanceWeightInput : set.weightInput).length }\r\n                                : undefined\r\n                            }\r\n                            onFocus={() => handleWeightFocus(index)}\r\n                            onBlur={() => handleWeightBlur(index)}\r\n                          />\r\n                          <HoldRepeatIconButton\r\n                            iconName=\"plus\"\r\n                            style={styles.adjustButton}\r\n                            accessibilityLabel={`Increase weight for set ${index + 1}`}\r\n                            onStep={() => adjustSetValue(index, exerciseType === 'assisted' ? 'assistanceWeight' : 'weight', exerciseType === 'assisted' ? 5 : 2.5)}\r\n                          />\r\n                        </View>\r\n                      </View>\r\n                    )}\r\n\r\n                    {exerciseType === 'cardio' && (\r\n                      <View style={styles.metricSection} pointerEvents=\"box-none\">\r\n                        <Text variant=\"label\" color=\"neutral\" style={styles.metricLabel}>\r\n                          Distance ({distanceUnitLabel})\r\n                        </Text>\r\n                        <View style={styles.metricControls}>\r\n                          <HoldRepeatIconButton\r\n                            iconName=\"minus\"\r\n                            style={styles.adjustButton}\r\n                            accessibilityLabel={`Decrease distance for set ${index + 1}`}\r\n                            onStep={() => {\r\n                              const current = setsRef.current[index];\r\n                              if (!current) {\r\n                                return;\r\n                              }\r\n\r\n                              const currentDisplayValue = convertDistanceForExercise(current.distance ?? 0, distanceUnit);\r\n                              const increment = distanceUnit === 'meters' ? 50 : distanceUnit === 'floors' ? 1 : 0.25;\r\n                              const newDisplayValue = Math.max(0, currentDisplayValue - increment);\r\n                              const newMiles = convertDistanceToMilesForExercise(newDisplayValue, distanceUnit);\r\n                              const nextDistance = Math.round(newMiles * 100) / 100;\r\n                              const nextText = formatDistanceInputValue(newDisplayValue, distanceUnit);\r\n\r\n                              const distanceRef = distanceInputRefs.current[index];\r\n                              if (distanceRef) {\r\n                                distanceRef.setNativeProps({ text: nextText });\r\n                              }\r\n\r\n                              updateSet(index, {\r\n                                distance: nextDistance,\r\n                                distanceInput: nextText,\r\n                              });\r\n                            }}\r\n                          />\r\n                          <TextInput\r\n                            ref={(ref) => {\r\n                              distanceInputRefs.current[index] = ref;\r\n                            }}\r\n                            value={set.distanceInput}\r\n                            onChangeText={(value) => handleDistanceInput(index, value)}\r\n                            keyboardType=\"decimal-pad\"\r\n                            style={styles.metricValue}\r\n                            textAlign=\"center\"\r\n                            placeholder={distanceUnit === 'meters' || distanceUnit === 'floors' ? '0' : '0.00'}\r\n                            placeholderTextColor={colors.text.tertiary}\r\n                            cursorColor={colors.accent.primary}\r\n                            selectionColor={colors.accent.orangeLight}\r\n                            selection={\r\n                              activeSelection?.type === 'distance' && activeSelection.index === index\r\n                                ? { start: 0, end: set.distanceInput.length }\r\n                                : undefined\r\n                            }\r\n                            onFocus={() => handleDistanceFocus(index)}\r\n                            onBlur={() => handleDistanceBlur(index)}\r\n                          />\r\n                          <HoldRepeatIconButton\r\n                            iconName=\"plus\"\r\n                            style={styles.adjustButton}\r\n                            accessibilityLabel={`Increase distance for set ${index + 1}`}\r\n                            onStep={() => {\r\n                              const current = setsRef.current[index];\r\n                              if (!current) {\r\n                                return;\r\n                              }\r\n\r\n                              const currentDisplayValue = convertDistanceForExercise(current.distance ?? 0, distanceUnit);\r\n                              const increment = distanceUnit === 'meters' ? 50 : distanceUnit === 'floors' ? 1 : 0.25;\r\n                              const newDisplayValue = distanceUnit === 'meters' || distanceUnit === 'floors'\r\n                                ? currentDisplayValue + increment\r\n                                : Math.round((currentDisplayValue + increment) * 100) / 100;\r\n                              const newMiles = convertDistanceToMilesForExercise(newDisplayValue, distanceUnit);\r\n                              const nextDistance = Math.round(newMiles * 100) / 100;\r\n                              const nextText = formatDistanceInputValue(newDisplayValue, distanceUnit);\r\n\r\n                              const distanceRef = distanceInputRefs.current[index];\r\n                              if (distanceRef) {\r\n                                distanceRef.setNativeProps({ text: nextText });\r\n                              }\r\n\r\n                              updateSet(index, {\r\n                                distance: nextDistance,\r\n                                distanceInput: nextText,\r\n                              });\r\n                            }}\r\n                          />\r\n                        </View>\r\n                      </View>\r\n                    )}\r\n\r\n                    {(exerciseType === 'cardio' || exerciseType === 'duration') && (\r\n                      <View style={styles.metricSection} pointerEvents=\"box-none\">\r\n                        <Text variant=\"label\" color=\"neutral\" style={styles.metricLabel}>\r\n                          Time {(set.hoursInput !== '00' ? '(hr:min:sec)' : '(min:sec)')}\r\n                        </Text>\r\n                        <Pressable\r\n                          style={styles.timeDisplayButton}\r\n                          onPress={() => {\r\n                            const isRunning = runningTimers.has(index);\r\n                            if (!isRunning) {\r\n                              openTimePicker(index);\r\n                            }\r\n                          }}\r\n                          disabled={runningTimers.has(index)}\r\n                          accessibilityLabel={`Edit time for set ${index + 1}`}\r\n                        >\r\n                          <Text style={styles.timeDisplayText}>\r\n                            {(set.hoursInput !== '00' ? `${set.hoursInput}:` : '')}{set.minutesInput || '00'}:{set.secondsInput || '00'}\r\n                          </Text>\r\n                        </Pressable>\r\n                        <View style={styles.timerRow}>\r\n                          <Pressable\r\n                            style={[\r\n                              styles.timerButtonCircle,\r\n                              (!pausedTimers.has(index) || (set.duration ?? 0) === 0) && styles.timerButtonDisabled\r\n                            ]}\r\n                            onPress={() => resetTimer(index)}\r\n                            disabled={!pausedTimers.has(index) || (set.duration ?? 0) === 0}\r\n                            accessibilityLabel=\"Reset timer\"\r\n                          >\r\n                            <MaterialCommunityIcons\r\n                              name=\"restart\"\r\n                              size={sizing.iconSM}\r\n                              color={(!pausedTimers.has(index) || (set.duration ?? 0) === 0) ? colors.accent.orangeLight : colors.accent.orange}\r\n                            />\r\n                          </Pressable>\r\n                          <Pressable\r\n                            style={styles.timerButtonCircle}\r\n                            onPress={() => {\r\n                              const isRunning = runningTimers.has(index);\r\n                              if (isRunning) {\r\n                                pauseTimer(index);\r\n                              } else {\r\n                                startTimer(index);\r\n                              }\r\n                            }}\r\n                            accessibilityLabel={runningTimers.has(index) ? \"Pause timer\" : \"Start timer\"}\r\n                          >\r\n                            <MaterialCommunityIcons\r\n                              name={runningTimers.has(index) ? \"pause\" : \"play\"}\r\n                              size={sizing.iconSM}\r\n                              color={colors.accent.orange}\r\n                            />\r\n                          </Pressable>\r\n                          <Pressable\r\n                            style={[\r\n                              styles.timerButtonCircle,\r\n                              (!runningTimers.has(index) && !pausedTimers.has(index)) && styles.timerButtonDisabled\r\n                            ]}\r\n                            onPress={() => stopTimer(index)}\r\n                            disabled={!runningTimers.has(index) && !pausedTimers.has(index)}\r\n                            accessibilityLabel=\"Stop timer\"\r\n                          >\r\n                            <MaterialCommunityIcons\r\n                              name=\"stop\"\r\n                              size={sizing.iconSM}\r\n                              color={(!runningTimers.has(index) && !pausedTimers.has(index)) ? colors.accent.orangeLight : colors.accent.orange}\r\n                            />\r\n                          </Pressable>\r\n                        </View>\r\n                      </View>\r\n                    )}\r\n\r\n                    {(exerciseType === 'weight' || exerciseType === 'bodyweight' || exerciseType === 'assisted' || exerciseType === 'reps_only') && (\r\n                      <View style={styles.metricSection} pointerEvents=\"box-none\">\r\n                        <Text variant=\"label\" color=\"neutral\" style={styles.metricLabel}>\r\n                          Reps\r\n                        </Text>\r\n                        <View style={styles.metricControls}>\r\n                          <HoldRepeatIconButton\r\n                            iconName=\"minus\"\r\n                            style={styles.adjustButton}\r\n                            accessibilityLabel={`Decrease reps for set ${index + 1}`}\r\n                            onStep={() => adjustSetValue(index, 'reps', -1)}\r\n                          />\r\n                          <TextInput\r\n                            ref={(ref) => {\r\n                              repsInputRefs.current[index] = ref;\r\n                            }}\r\n                            value={set.repsInput}\r\n                            onChangeText={(value) => handleRepsInput(index, value)}\r\n                            keyboardType=\"numeric\"\r\n                            style={styles.metricValue}\r\n                            textAlign=\"center\"\r\n                            placeholder=\"0\"\r\n                            placeholderTextColor={colors.text.tertiary}\r\n                            cursorColor={colors.accent.primary}\r\n                            selectionColor={colors.accent.orangeLight}\r\n                            selection={\r\n                              activeSelection?.type === 'reps' && activeSelection.index === index\r\n                                ? { start: 0, end: set.repsInput.length }\r\n                                : undefined\r\n                            }\r\n                            onFocus={() => handleRepsFocus(index)}\r\n                            onBlur={() => handleRepsBlur(index)}\r\n                            spellCheck={false}\r\n                            autoCorrect={false}\r\n                            autoCapitalize=\"none\"\r\n                          />\r\n                          <HoldRepeatIconButton\r\n                            iconName=\"plus\"\r\n                            style={styles.adjustButton}\r\n                            accessibilityLabel={`Increase reps for set ${index + 1}`}\r\n                            onStep={() => adjustSetValue(index, 'reps', 1)}\r\n                          />\r\n                        </View>\r\n                      </View>\r\n                    )}\r\n\r\n                    <Pressable\r\n                      style={[styles.setActionButton, styles.setActionButtonPressable]}\r\n                      onPress={() => handleCompleteSetPress(index)}\r\n                      hitSlop={spacing.xs}\r\n                      accessibilityRole=\"button\"\r\n                      accessibilityLabel={`Mark set ${index + 1} as complete`}\r\n                    >\r\n                      <Text variant=\"bodySemibold\" color=\"onAccent\">\r\n                        Complete set\r\n                      </Text>\r\n                    </Pressable>\r\n                  </>\r\n                )}\r\n              </View>\r\n            );\r\n          })\r\n        ) : (\r\n          <View style={styles.emptyStateContainer}>\r\n            <Text color=\"secondary\">No sets yet.</Text>\r\n          </View>\r\n        )}\r\n        <Pressable\r\n          style={styles.addSetButton}\r\n          onPress={addSet}\r\n          accessibilityRole=\"button\"\r\n          accessibilityLabel=\"Add set\"\r\n        >\r\n          <Text variant=\"bodySemibold\" color=\"orange\">\r\n            Add set\r\n          </Text>\r\n        </Pressable>\r\n      </ScrollView>\r\n      <TimePickerModal\r\n        visible={timePickerVisible}\r\n        onClose={() => setTimePickerVisible(false)}\r\n        onConfirm={handleTimePickerConfirm}\r\n        initialSeconds={sets[timePickerIndex]?.duration ?? 0}\r\n      />\r\n    </Animated.View>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    marginTop: spacing.md,\r\n    borderRadius: radius.lg,\r\n    backgroundColor: colors.surface.card,\r\n    borderWidth: 1,\r\n    borderColor: colors.border.light,\r\n    ...shadows.lg,\r\n    overflow: 'hidden',\r\n  },\r\n  content: {\r\n    gap: spacing.sm,\r\n    paddingTop: spacing.mdCompact,\r\n    paddingBottom: spacing.md,\r\n    paddingHorizontal: spacing.md,\r\n  },\r\n  headerRow: {\r\n    paddingBottom: spacing.sm,\r\n    borderBottomWidth: 1,\r\n    borderBottomColor: colors.border.light,\r\n    marginBottom: spacing.md,\r\n  },\r\n  setCard: {\r\n    borderWidth: 1,\r\n    borderColor: colors.accent.orange,\r\n    borderRadius: radius.lg,\r\n    paddingHorizontal: spacing.md,\r\n    paddingVertical: spacing.md,\r\n    backgroundColor: colors.surface.card,\r\n    gap: spacing.md,\r\n  },\r\n  setCardCompleted: {\r\n    backgroundColor: colors.accent.orange,\r\n    borderColor: colors.accent.orange,\r\n    paddingHorizontal: spacing.md,\r\n    paddingVertical: spacing.sm,\r\n  },\r\n  completedRow: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'space-between',\r\n    paddingVertical: spacing.xs,\r\n    paddingHorizontal: 0,\r\n    borderRadius: radius.md,\r\n    backgroundColor: 'transparent',\r\n  },\r\n  setHeader: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'space-between',\r\n  },\r\n  menuButton: {\r\n    padding: spacing.sm,\r\n  },\r\n  menuPopover: {\r\n    position: 'absolute',\r\n    top: sizing.iconSM + spacing.md + spacing.xs,\r\n    right: spacing.sm,\r\n    borderRadius: radius.md,\r\n    backgroundColor: colors.surface.card,\r\n    borderWidth: 1,\r\n    borderColor: colors.accent.orange,\r\n    paddingVertical: spacing.xs,\r\n    paddingHorizontal: spacing.sm,\r\n    gap: spacing.xs,\r\n    zIndex: zIndex.modal,\r\n    elevation: 10,\r\n    minWidth: 150,\r\n  },\r\n  menuItem: {\r\n    paddingVertical: spacing.xs,\r\n    paddingHorizontal: spacing.sm,\r\n  },\r\n  metricSection: {\r\n    gap: spacing.xs,\r\n  },\r\n  metricLabel: {\r\n    textAlign: 'center',\r\n  },\r\n  metricControls: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    gap: spacing.md,\r\n  },\r\n  adjustButton: {\r\n    width: sizing.iconLG,\r\n    height: sizing.iconLG,\r\n    borderRadius: radius.full,\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    backgroundColor: colors.surface.card,\r\n    borderWidth: 1,\r\n    borderColor: colors.accent.orange,\r\n  },\r\n  metricValue: {\r\n    minWidth: spacing['2xl'] + spacing.lg,\r\n    fontSize: sizing.iconLG,\r\n    color: colors.text.primary,\r\n    fontWeight: '600',\r\n    paddingVertical: spacing.xxxs,\r\n    paddingHorizontal: spacing.xs,\r\n    borderRadius: radius.md,\r\n    backgroundColor: colors.surface.card,\r\n  },\r\n  setActionButton: {\r\n    marginTop: spacing.xs,\r\n  },\r\n  setActionButtonPressable: {\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    paddingVertical: spacing.sm,\r\n    minHeight: sizing.buttonSM,\r\n    borderRadius: radius.md,\r\n    backgroundColor: colors.accent.orange,\r\n    borderWidth: 1,\r\n    borderColor: colors.accent.orange,\r\n  },\r\n  addSetButton: {\r\n    marginTop: spacing.md,\r\n    marginBottom: spacing.lg,\r\n    borderRadius: radius.lg,\r\n    borderWidth: 1,\r\n    borderColor: colors.accent.orange,\r\n    backgroundColor: colors.surface.card,\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    paddingVertical: spacing.sm,\r\n    minHeight: sizing.buttonSM,\r\n  },\r\n  containerEmbedded: {\r\n    marginTop: spacing.sm,\r\n    borderWidth: 0,\r\n    borderRadius: 0,\r\n    borderTopWidth: 1,\r\n    borderTopColor: colors.border.light,\r\n    backgroundColor: 'transparent',\r\n    shadowColor: 'transparent',\r\n    shadowOpacity: 0,\r\n    shadowRadius: 0,\r\n    shadowOffset: { width: 0, height: 0 },\r\n    elevation: 0,\r\n  },\r\n  contentEmbedded: {\r\n    paddingHorizontal: spacing.md,\r\n    paddingTop: spacing.lg,\r\n  },\r\n  headerRowEmbedded: {\r\n    marginBottom: spacing.sm,\r\n  },\r\n  actionRowEmbedded: {\r\n    paddingHorizontal: spacing.md,\r\n    paddingBottom: spacing.md,\r\n  },\r\n  setCardSpacer: {\r\n    marginTop: spacing.md,\r\n  },\r\n  timeInputContainer: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    backgroundColor: colors.surface.card,\r\n    borderRadius: radius.md,\r\n    paddingHorizontal: spacing.xs,\r\n    paddingVertical: spacing.xxxs,\r\n    minHeight: sizing.iconLG + spacing.xxxs * 2,\r\n    borderWidth: 1,\r\n    borderColor: 'transparent', // Match other inputs visually if needed, or keep clean\r\n  },\r\n  timeInput: {\r\n    fontSize: sizing.iconLG,\r\n    color: colors.text.primary,\r\n    fontWeight: '600',\r\n    minWidth: 32, // Enough for 2 digits\r\n    padding: 0,\r\n    textAlign: 'center',\r\n  },\r\n  timeSeparator: {\r\n    fontSize: sizing.iconLG,\r\n    color: colors.text.primary,\r\n    fontWeight: '600',\r\n    marginHorizontal: 1,\r\n    textAlignVertical: 'center',\r\n  },\r\n  timeDisplayButton: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    backgroundColor: colors.surface.card,\r\n    borderRadius: radius.md,\r\n    paddingHorizontal: spacing.md,\r\n    paddingVertical: spacing.md,\r\n    minWidth: 120,\r\n  },\r\n  timeDisplayText: {\r\n    fontSize: sizing.iconLG,\r\n    color: colors.text.primary,\r\n    fontWeight: '600',\r\n  },\r\n  timerRow: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'space-between',\r\n    width: '100%',\r\n    paddingHorizontal: spacing.md,\r\n  },\r\n  timerButtonCircle: {\r\n    width: sizing.iconLG,\r\n    height: sizing.iconLG,\r\n    borderRadius: radius.full,\r\n    backgroundColor: colors.surface.card,\r\n    borderWidth: 1,\r\n    borderColor: colors.accent.orange,\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    flex: 1,\r\n    maxWidth: 60,\r\n  },\r\n  timerButtonDisabled: {\r\n    borderColor: colors.accent.orangeLight,\r\n    opacity: 0.6,\r\n  },\r\n  timerButtonSpacer: {\r\n    width: sizing.iconLG,\r\n    height: sizing.iconLG,\r\n  },\r\n  emptyStateContainer: {\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    paddingVertical: spacing.xl,\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\FeedbackModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TouchableOpacity' is defined but never used.","line":11,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ActivityIndicator' is defined but never used.","line":14,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * FeedbackModal\r\n * Modal for sending user feedback with a simple text input\r\n */\r\n\r\nimport React, { useState } from 'react';\r\nimport {\r\n  Modal,\r\n  StyleSheet,\r\n  TouchableWithoutFeedback,\r\n  TouchableOpacity,\r\n  View,\r\n  Alert,\r\n  ActivityIndicator,\r\n  ScrollView,\r\n  TextInput,\r\n} from 'react-native';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { Button } from '@/components/atoms/Button';\r\nimport { FeedbackSuccessModal } from '@/components/molecules/FeedbackSuccessModal';\r\nimport { colors, radius, spacing, shadows } from '@/constants/theme';\r\nimport { useTheme } from '@/hooks/useTheme';\r\nimport { submitFeedback } from '@/services/feedbackService';\r\nimport { useAuth } from '@/providers/AuthProvider';\r\n\r\ninterface FeedbackModalProps {\r\n  visible: boolean;\r\n  onClose: () => void;\r\n}\r\n\r\nexport const FeedbackModal: React.FC<FeedbackModalProps> = ({ visible, onClose }) => {\r\n  const { theme } = useTheme();\r\n  const { user } = useAuth();\r\n  const [feedback, setFeedback] = useState('');\r\n  const [isSubmitting, setIsSubmitting] = useState(false);\r\n  const [showSuccessModal, setShowSuccessModal] = useState(false);\r\n\r\n  const characterCount = feedback.length;\r\n  const maxCharacters = 2000;\r\n\r\n  const handleCancel = () => {\r\n    if (isSubmitting) return;\r\n    triggerHaptic('selection');\r\n    onClose();\r\n  };\r\n\r\n  const handleSubmit = async () => {\r\n    if (isSubmitting) return;\r\n\r\n    const trimmedFeedback = feedback.trim();\r\n    \r\n    // Validate input\r\n    if (!trimmedFeedback) {\r\n      Alert.alert('Invalid Feedback', 'Please enter your feedback before submitting.');\r\n      return;\r\n    }\r\n\r\n    if (trimmedFeedback.length > 2000) {\r\n      Alert.alert('Invalid Feedback', 'Please keep your feedback under 2000 characters.');\r\n      return;\r\n    }\r\n\r\n    triggerHaptic('success');\r\n    setIsSubmitting(true);\r\n\r\n    try {\r\n      // Submit feedback using the service with user ID\r\n      await submitFeedback(trimmedFeedback, user?.id);\r\n      \r\n      // Show custom success modal\r\n      setShowSuccessModal(true);\r\n      \r\n      // Close modal and reset form\r\n      setFeedback('');\r\n      onClose();\r\n      \r\n    } catch (error: any) {\r\n      console.error('[FeedbackModal] Error submitting feedback:', error);\r\n      Alert.alert('Error', error.message || 'Failed to submit feedback. Please try again later.');\r\n    } finally {\r\n      setIsSubmitting(false);\r\n    }\r\n  };\r\n\r\n  // Reset form when modal opens/closes\r\n  React.useEffect(() => {\r\n    if (!visible) {\r\n      setFeedback('');\r\n      setIsSubmitting(false);\r\n    }\r\n  }, [visible]);\r\n\r\n  const handleSuccessModalClose = () => {\r\n    setShowSuccessModal(false);\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <Modal\r\n        animationType=\"fade\"\r\n        transparent\r\n        visible={visible}\r\n        onRequestClose={handleCancel}\r\n        statusBarTranslucent\r\n      >\r\n        <TouchableWithoutFeedback onPress={handleCancel}>\r\n          <View style={styles.overlay}>\r\n            <TouchableWithoutFeedback>\r\n              <View style={[styles.container, { backgroundColor: theme.surface.card }]}>\r\n                <Text variant=\"heading2\" color=\"primary\" style={styles.title}>\r\n                  Send Feedback\r\n                </Text>\r\n\r\n                <Text variant=\"body\" color=\"secondary\" style={styles.subtitle}>\r\n                  Help us improve Hercules by sharing your thoughts, suggestions, or reporting issues.\r\n                </Text>\r\n\r\n                <ScrollView style={styles.scrollContent} showsVerticalScrollIndicator={false} keyboardDismissMode=\"on-drag\">\r\n                  <View style={styles.form}>\r\n                    <View style={[styles.textInputContainer, { \r\n                      backgroundColor: theme.surface.elevated,\r\n                      borderRadius: radius.md,\r\n                      padding: spacing.sm,\r\n                      borderWidth: 2,\r\n                      borderColor: theme.accent?.orange || '#FF6B47',\r\n                      minHeight: 180,\r\n                    }]}>\r\n                      <TextInput\r\n                        style={[\r\n                          styles.textInput, \r\n                          { \r\n                            backgroundColor: 'transparent',\r\n                            borderColor: 'transparent',\r\n                            color: theme.text.primary,\r\n                          }\r\n                        ]}\r\n                        value={feedback}\r\n                        onChangeText={setFeedback}\r\n                        placeholder=\"Your feedback...\"\r\n                        placeholderTextColor={theme.text.tertiary}\r\n                        multiline\r\n                        numberOfLines={6}\r\n                        textAlignVertical=\"top\"\r\n                        editable={!isSubmitting}\r\n                        maxLength={2000}\r\n                      />\r\n                      <View style={styles.characterCounter}>\r\n                        <Text \r\n                          variant=\"caption\" \r\n                          color={characterCount > 1800 ? \"primary\" : \"tertiary\"}\r\n                        >\r\n                          {characterCount}/{maxCharacters}\r\n                        </Text>\r\n                      </View>\r\n                    </View>\r\n                  </View>\r\n                </ScrollView>\r\n\r\n                <View style={styles.actions}>\r\n                  <Button\r\n                    label=\"Cancel\"\r\n                    variant=\"ghost\"\r\n                    onPress={handleCancel}\r\n                    style={styles.button}\r\n                    disabled={isSubmitting}\r\n                  />\r\n\r\n                  <Button\r\n                    label={isSubmitting ? \"Submitting...\" : \"Submit\"}\r\n                    variant=\"primary\"\r\n                    onPress={handleSubmit}\r\n                    disabled={isSubmitting}\r\n                    style={styles.button}\r\n                    loading={isSubmitting}\r\n                  />\r\n                </View>\r\n              </View>\r\n            </TouchableWithoutFeedback>\r\n          </View>\r\n        </TouchableWithoutFeedback>\r\n      </Modal>\r\n\r\n      <FeedbackSuccessModal\r\n        visible={showSuccessModal}\r\n        onClose={handleSuccessModalClose}\r\n      />\r\n    </>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  overlay: {\r\n    flex: 1,\r\n    backgroundColor: colors.overlay.scrim,\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n    paddingHorizontal: spacing.lg,\r\n  },\r\n  container: {\r\n    borderRadius: radius.xl,\r\n    padding: spacing.xl,\r\n    width: '100%',\r\n    maxWidth: 400,\r\n    maxHeight: '90%',\r\n    minHeight: 500,\r\n    ...shadows.lg,\r\n  },\r\n  title: {\r\n    textAlign: 'center',\r\n    marginBottom: spacing.sm,\r\n  },\r\n  subtitle: {\r\n    textAlign: 'center',\r\n    marginBottom: spacing.lg,\r\n    lineHeight: 20,\r\n  },\r\n  scrollContent: {\r\n    flex: 1,\r\n    marginBottom: spacing.lg,\r\n    minHeight: 200,\r\n  },\r\n  form: {\r\n    gap: spacing.md,\r\n  },\r\n  textInput: {\r\n    minHeight: 150,\r\n    borderRadius: radius.md,\r\n    borderWidth: 1,\r\n    padding: spacing.md,\r\n    fontSize: 16,\r\n    fontFamily: 'System',\r\n    backgroundColor: 'transparent', // Will be set dynamically\r\n  },\r\n  textInputContainer: {\r\n    padding: spacing.sm,\r\n    marginTop: spacing.sm,\r\n  },\r\n  characterCounter: {\r\n    alignItems: 'flex-end',\r\n    paddingTop: spacing.xs,\r\n  },\r\n  actions: {\r\n    flexDirection: 'row',\r\n    gap: spacing.md,\r\n    justifyContent: 'center',\r\n  },\r\n  button: {\r\n    flex: 1,\r\n    minWidth: 120,\r\n    minHeight: 44,\r\n  },\r\n  spinner: {\r\n    marginLeft: spacing.xs,\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\FeedbackSuccessModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'colors' is defined but never used.","line":17,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * FeedbackSuccessModal\r\n * Custom success modal for feedback submission with themed styling\r\n */\r\n\r\nimport React from 'react';\r\nimport {\r\n  Modal,\r\n  StyleSheet,\r\n  TouchableWithoutFeedback,\r\n  View,\r\n} from 'react-native';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { Button } from '@/components/atoms/Button';\r\nimport { colors, radius, spacing, shadows } from '@/constants/theme';\r\nimport { useTheme } from '@/hooks/useTheme';\r\n\r\ninterface FeedbackSuccessModalProps {\r\n  visible: boolean;\r\n  onClose: () => void;\r\n}\r\n\r\nexport const FeedbackSuccessModal: React.FC<FeedbackSuccessModalProps> = ({ visible, onClose }) => {\r\n  const { theme } = useTheme();\r\n\r\n  const handleClose = () => {\r\n    triggerHaptic('selection');\r\n    onClose();\r\n  };\r\n\r\n  return (\r\n    <Modal\r\n      animationType=\"fade\"\r\n      transparent\r\n      visible={visible}\r\n      onRequestClose={handleClose}\r\n    >\r\n      <TouchableWithoutFeedback onPress={handleClose}>\r\n        <View style={styles.overlay}>\r\n          <TouchableWithoutFeedback>\r\n            <View style={[styles.container, { backgroundColor: theme.surface.card }]}>\r\n              {/* Success Message */}\r\n              <Text variant=\"heading2\" color=\"primary\" style={styles.title}>\r\n                Thank You!\r\n              </Text>\r\n\r\n              <Text variant=\"body\" color=\"secondary\" style={styles.message}>\r\n                Your feedback has been submitted successfully. We appreciate your input!\r\n              </Text>\r\n\r\n              {/* Action Button */}\r\n              <Button\r\n                label=\"Close\"\r\n                variant=\"primary\"\r\n                onPress={handleClose}\r\n                style={styles.button}\r\n              />\r\n            </View>\r\n          </TouchableWithoutFeedback>\r\n        </View>\r\n      </TouchableWithoutFeedback>\r\n    </Modal>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  overlay: {\r\n    flex: 1,\r\n    backgroundColor: 'rgba(0, 0, 0, 0.5)',\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n    paddingHorizontal: spacing.lg,\r\n  },\r\n  container: {\r\n    borderRadius: radius.xl,\r\n    padding: spacing.xl,\r\n    width: '100%',\r\n    maxWidth: 320,\r\n    alignItems: 'center',\r\n    ...shadows.lg,\r\n  },\r\n  title: {\r\n    textAlign: 'center',\r\n    marginBottom: spacing.sm,\r\n  },\r\n  message: {\r\n    textAlign: 'center',\r\n    lineHeight: 20,\r\n    marginBottom: spacing.xl,\r\n  },\r\n  button: {\r\n    width: '100%',\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\FilterBottomSheet.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\FinishConfirmationModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sizing' is defined but never used.","line":6,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":41}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport { Modal, StyleSheet, View, Pressable } from 'react-native';\r\nimport { BlurView } from 'expo-blur';\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { Button } from '@/components/atoms/Button';\r\nimport { colors, radius, spacing, sizing } from '@/constants/theme';\r\n\r\ninterface FinishConfirmationModalProps {\r\n  visible: boolean;\r\n  onClose: () => void;\r\n  onConfirm: () => void;\r\n  isLoading?: boolean;\r\n}\r\n\r\n/**\r\n * FinishConfirmationModal\r\n * A confirmation dialog shown when a user tries to finish their workout.\r\n */\r\nexport const FinishConfirmationModal: React.FC<FinishConfirmationModalProps> = ({\r\n  visible,\r\n  onClose,\r\n  onConfirm,\r\n  isLoading = false,\r\n}) => {\r\n  return (\r\n    <Modal\r\n      visible={visible}\r\n      transparent\r\n      animationType=\"fade\"\r\n      onRequestClose={onClose}\r\n    >\r\n      <View style={styles.overlay}>\r\n        <BlurView intensity={40} style={StyleSheet.absoluteFill} tint=\"dark\" />\r\n        <View style={[StyleSheet.absoluteFill, { backgroundColor: 'rgba(0, 0, 0, 0.5)' }]} />\r\n        <Pressable style={StyleSheet.absoluteFill} onPress={onClose} />\r\n        \r\n        <View style={styles.container}>\r\n          <View style={styles.card}>\r\n            <Text variant=\"heading3\" style={styles.title}>Finish Workout?</Text>\r\n            <Text variant=\"body\" color=\"secondary\" style={styles.message}>\r\n              Are you sure you want to end your current session?\r\n            </Text>\r\n\r\n            <View style={styles.buttonStack}>\r\n              <Button\r\n                label=\"Continue Workout\"\r\n                onPress={onClose}\r\n                variant=\"ghost\"\r\n                contentStyle={styles.continueButton}\r\n                textColor={colors.accent.orange}\r\n                disabled={isLoading}\r\n              />\r\n              <Button\r\n                label=\"Finish Workout\"\r\n                onPress={onConfirm}\r\n                loading={isLoading}\r\n                disabled={isLoading}\r\n                contentStyle={styles.finishButton}\r\n                textColor={colors.text.onAccent}\r\n              />\r\n            </View>\r\n          </View>\r\n        </View>\r\n      </View>\r\n    </Modal>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  overlay: {\r\n    flex: 1,\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n    padding: spacing.xl,\r\n  },\r\n  container: {\r\n    width: '100%',\r\n    maxWidth: 400,\r\n  },\r\n  card: {\r\n    backgroundColor: colors.surface.card,\r\n    borderRadius: radius.xl,\r\n    padding: spacing.xl,\r\n    borderWidth: 2,\r\n    borderColor: colors.accent.orange,\r\n    alignItems: 'center',\r\n    gap: spacing.md,\r\n  },\r\n  title: {\r\n    textAlign: 'center',\r\n  },\r\n  message: {\r\n    textAlign: 'center',\r\n    marginBottom: spacing.sm,\r\n  },\r\n  buttonStack: {\r\n    width: '100%',\r\n    gap: spacing.md,\r\n  },\r\n  continueButton: {\r\n    backgroundColor: '#FFFFFF',\r\n    borderWidth: 2,\r\n    borderColor: colors.accent.orange,\r\n    borderRadius: radius.lg,\r\n  },\r\n  finishButton: {\r\n    backgroundColor: colors.accent.orange,\r\n    borderWidth: 2,\r\n    borderColor: colors.accent.orange,\r\n    borderRadius: radius.lg,\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\FocusDistributionChart.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Platform' is defined but never used.","line":2,"column":130,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":138},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'UIManager' is defined but never used.","line":2,"column":140,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":149},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'currentPage' and 'heightAnim'. Either include them or remove the dependency array.","line":279,"column":6,"nodeType":"ArrayExpression","endLine":279,"endColumn":43,"suggestions":[{"desc":"Update the dependencies array to be: [currentPage, dataItemCounts, heightAnim, isHeightInitialized]","fix":{"range":[10658,10695],"text":"[currentPage, dataItemCounts, heightAnim, isHeightInitialized]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'heightAnim'. Either include it or remove the dependency array.","line":295,"column":6,"nodeType":"ArrayExpression","endLine":295,"endColumn":69,"suggestions":[{"desc":"Update the dependencies array to be: [currentPage, pageHeights, dataItemCounts, isHeightInitialized, heightAnim]","fix":{"range":[11242,11305],"text":"[currentPage, pageHeights, dataItemCounts, isHeightInitialized, heightAnim]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'heightAnim'. Either include it or remove the dependency array.","line":326,"column":8,"nodeType":"ArrayExpression","endLine":326,"endColumn":37,"suggestions":[{"desc":"Update the dependencies array to be: [pageHeights, dataItemCounts, heightAnim]","fix":{"range":[12353,12382],"text":"[pageHeights, dataItemCounts, heightAnim]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useMemo, useState, useEffect, useRef, useCallback } from 'react';\r\nimport { View, Dimensions, StyleSheet, ScrollView, NativeSyntheticEvent, NativeScrollEvent, TouchableOpacity, LayoutChangeEvent, Platform, UIManager, Animated, Easing } from 'react-native';\r\nimport { VictoryPie } from 'victory-native';\r\nimport { useFocusEffect } from '@react-navigation/native';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { colors, spacing, radius } from '@/constants/theme';\r\nimport { useWorkoutSessionsStore } from '@/store/workoutSessionsStore';\r\n\r\n// Import data\r\nimport exercisesData from '@/data/exercises.json';\r\nimport hierarchyData from '@/data/hierarchy.json';\r\n\r\nconst SCREEN_WIDTH = Dimensions.get('window').width;\r\nconst CHART_WIDTH = SCREEN_WIDTH - spacing.xl * 2;\r\nconst PIE_SIZE = 220; // Reduced size\r\n\r\n// Build Maps - handles up to 4 levels (high -> mid -> low -> detailed)\r\nconst buildMaps = () => {\r\n  const leafToL1: Record<string, string> = {}; // Specific -> Body Part (Upper/Lower/Core)\r\n  const leafToL2: Record<string, string> = {}; // Specific -> Muscle Group (Chest/Back/etc)\r\n  const leafToL3: Record<string, string> = {}; // Specific -> Specific (Identity)\r\n\r\n  const hierarchy = hierarchyData.muscle_hierarchy;\r\n\r\n  Object.entries(hierarchy).forEach(([l1, l1Data]) => {\r\n    if (l1Data?.muscles) {\r\n      Object.entries(l1Data.muscles).forEach(([l2, l2Data]: [string, any]) => {\r\n        // l2 is \"Chest\", \"Arms\", \"Calves\", etc.\r\n        leafToL1[l2] = l1;\r\n        leafToL2[l2] = l2;\r\n        leafToL3[l2] = l2;\r\n\r\n        if (l2Data?.muscles) {\r\n          Object.entries(l2Data.muscles).forEach(([l3, l3Data]: [string, any]) => {\r\n            // l3 could be \"Upper Chest\" (low), \"Biceps\" (low with children), or \"Medial Head\" (detailed under Calves)\r\n            leafToL1[l3] = l1;\r\n            leafToL2[l3] = l2;\r\n            leafToL3[l3] = l3;\r\n            \r\n            // Handle L4 (detailed level, e.g., Long Head under Biceps)\r\n            if (l3Data?.muscles) {\r\n              Object.keys(l3Data.muscles).forEach(l4 => {\r\n                leafToL1[l4] = l1;\r\n                leafToL2[l4] = l2;\r\n                leafToL3[l4] = l4;\r\n              });\r\n            }\r\n          });\r\n        }\r\n      });\r\n    }\r\n  });\r\n\r\n  return { leafToL1, leafToL2, leafToL3 };\r\n};\r\n\r\nconst { leafToL1, leafToL2, leafToL3 } = buildMaps();\r\n\r\nconst EXERCISE_NAME_TO_MUSCLES = exercisesData.reduce((acc, ex) => {\r\n  if (ex.muscles) {\r\n    acc[ex.name] = ex.muscles as unknown as Record<string, number>;\r\n  }\r\n  return acc;\r\n}, {} as Record<string, Record<string, number>>);\r\n\r\ninterface ChartDataItem {\r\n  name: string;\r\n  population: number;\r\n  color: string;\r\n  legendFontColor: string;\r\n  legendFontSize: number;\r\n}\r\n\r\ninterface ChartPageProps {\r\n  title: string;\r\n  data: ChartDataItem[];\r\n  selectedSlice: string | null;\r\n  onSelectSlice: (name: string) => void;\r\n  onLayout?: (event: LayoutChangeEvent) => void;\r\n}\r\n\r\nconst ChartPage: React.FC<ChartPageProps> = ({ title, data, selectedSlice, onSelectSlice, onLayout }) => {\r\n  // Prepare chart data for Victory\r\n  const chartData = useMemo(() => {\r\n    return data.map((item) => ({\r\n      x: item.name,\r\n      y: item.population,\r\n      color: item.color, // Always use the actual color, never grey out initially\r\n      label: `${Math.round(item.population * 100)}%`\r\n    }));\r\n  }, [data]);\r\n\r\n  const colorScale = chartData.map(d => d.color);\r\n\r\n  return (\r\n    <View style={styles.pageContainer} onLayout={onLayout}>\r\n      <Text variant=\"heading3\" color=\"primary\" style={styles.chartTitle}>{title}</Text>\r\n      {data.length > 0 ? (\r\n        <>\r\n          <View style={styles.chartContainer}>\r\n            <VictoryPie\r\n              data={chartData}\r\n              width={PIE_SIZE + 40}\r\n              height={PIE_SIZE + 40}\r\n              colorScale={colorScale}\r\n              innerRadius={50}\r\n              radius={({ datum }) => (selectedSlice === datum.x ? PIE_SIZE / 2 + 10 : PIE_SIZE / 2)}\r\n              padAngle={2}\r\n              style={{\r\n                data: {\r\n                  fill: ({ datum }) => selectedSlice && selectedSlice !== datum.x ? colors.neutral.gray200 : datum.color,\r\n                },\r\n                labels: {\r\n                  fill: 'transparent', // Hide labels on the chart itself for cleaner look, or use them if desired\r\n                }\r\n              }}\r\n              events={[{\r\n                target: \"data\",\r\n                eventHandlers: {\r\n                  onPressIn: () => {\r\n                    return [\r\n                      {\r\n                        target: \"data\",\r\n                        mutation: (props) => {\r\n                          onSelectSlice(props.datum.x);\r\n                          return null;\r\n                        }\r\n                      }\r\n                    ];\r\n                  }\r\n                }\r\n              }]}\r\n            />\r\n            {/* Center Text or Overlay if needed */}\r\n          </View>\r\n          <View style={styles.customLegend}>\r\n            {data.map((item, index) => {\r\n              const isSelected = selectedSlice === item.name;\r\n              const isDimmed = selectedSlice && !isSelected;\r\n\r\n              return (\r\n                <TouchableOpacity\r\n                  key={index}\r\n                  style={[\r\n                    styles.legendItem,\r\n                    { opacity: isDimmed ? 0.3 : 1 }\r\n                  ]}\r\n                  onPress={() => onSelectSlice(item.name)}\r\n                >\r\n                  <View style={[styles.legendColor, { backgroundColor: item.color }]} />\r\n                  <Text variant=\"caption\" color=\"primary\">{item.name}</Text>\r\n                  <Text variant=\"caption\" color=\"secondary\"> {Math.round(item.population * 100)}%</Text>\r\n                </TouchableOpacity>\r\n              );\r\n            })}\r\n          </View>\r\n        </>\r\n      ) : (\r\n        <View style={styles.emptyChart}>\r\n          <Text variant=\"body\" color=\"secondary\">No data available</Text>\r\n        </View>\r\n      )}\r\n    </View>\r\n  );\r\n};\r\n\r\n// Constants for reliable height calculation\r\nconst PIE_CHART_HEIGHT = PIE_SIZE + 40; // 260px for pie chart area\r\nconst TITLE_HEIGHT = 30; // Approximate title height\r\nconst LEGEND_ROW_HEIGHT = 24; // Approximate height per legend row\r\nconst MIN_CHART_HEIGHT = PIE_CHART_HEIGHT + TITLE_HEIGHT + spacing.md + spacing.sm; // Minimum fallback\r\n\r\n// Calculate expected height based on data item count\r\nconst calculateExpectedHeight = (itemCount: number): number => {\r\n  if (itemCount === 0) return 220 + TITLE_HEIGHT + spacing.md; // Empty state height\r\n  // Estimate legend rows: ~3 items per row at current width\r\n  const legendRows = Math.ceil(itemCount / 3);\r\n  return PIE_CHART_HEIGHT + TITLE_HEIGHT + (legendRows * LEGEND_ROW_HEIGHT) + spacing.md + spacing.sm;\r\n};\r\n\r\nexport const FocusDistributionChart: React.FC = () => {\r\n  const workouts = useWorkoutSessionsStore((state) => state.workouts);\r\n  const [currentPage, setCurrentPage] = useState(0);\r\n  const [selections, setSelections] = useState<Record<number, string | null>>({});\r\n  const [pageHeights, setPageHeights] = useState<Record<number, number>>({});\r\n\r\n  const heightAnim = useRef(new Animated.Value(MIN_CHART_HEIGHT)).current;\r\n  const scrollViewRef = useRef<ScrollView>(null);\r\n  const [isHeightInitialized, setIsHeightInitialized] = useState(false);\r\n  const lastWorkoutCount = useRef(workouts.length);\r\n\r\n  const { dataL1, dataL2, dataL3 } = useMemo(() => {\r\n    const distL1: Record<string, number> = {};\r\n    const distL2: Record<string, number> = {};\r\n    const distL3: Record<string, number> = {};\r\n    let totalSets = 0;\r\n\r\n    workouts.forEach(workout => {\r\n      workout.exercises.forEach(exercise => {\r\n        const weights = EXERCISE_NAME_TO_MUSCLES[exercise.name];\r\n        if (!weights) return;\r\n\r\n        // Exclude sets with 0 weight\r\n        const completedSets = exercise.sets.filter(s => s.completed && (s.weight ?? 0) > 0).length;\r\n        if (completedSets === 0) return;\r\n\r\n        totalSets += completedSets;\r\n\r\n        Object.entries(weights).forEach(([muscle, weight]) => {\r\n          const contribution = completedSets * weight;\r\n\r\n          // Level 1\r\n          const cat1 = leafToL1[muscle];\r\n          if (cat1) distL1[cat1] = (distL1[cat1] || 0) + contribution;\r\n\r\n          // Level 2\r\n          const cat2 = leafToL2[muscle];\r\n          if (cat2) distL2[cat2] = (distL2[cat2] || 0) + contribution;\r\n\r\n          // Level 3\r\n          const cat3 = leafToL3[muscle];\r\n          if (cat3) distL3[cat3] = (distL3[cat3] || 0) + contribution;\r\n        });\r\n      });\r\n    });\r\n\r\n    const formatData = (dist: Record<string, number>) => {\r\n      // 1. Sort all entries first to handle the main ones\r\n      const sortedEntries = Object.entries(dist).sort((a, b) => b[1] - a[1]);\r\n      \r\n      // 2. Calculate total contribution for percentage check\r\n      const totalContribution = Object.values(dist).reduce((sum, val) => sum + val, 0);\r\n      const threshold = totalContribution * 0.01; // 1% threshold\r\n\r\n      // 3. Filter out items below threshold (don't show them at all)\r\n      const mainItems = sortedEntries.filter(([, value]) => value >= threshold);\r\n\r\n      const totalItems = mainItems.length;\r\n\r\n      return mainItems\r\n        .map(([name, value], index) => {\r\n          // Interpolate opacity: Largest (index 0) is 1.0, Smallest (last index) is 0.3\r\n          // Formula: 1.0 - (ratio * 0.7) where ratio is index / (total - 1)\r\n          let opacity = 1.0;\r\n          if (totalItems > 1) {\r\n            const ratio = index / (totalItems - 1);\r\n            opacity = 1.0 - (ratio * 0.7);\r\n          }\r\n          \r\n          return {\r\n            name,\r\n            population: totalSets > 0 ? value / totalSets : 0,\r\n            color: `rgba(255, 107, 74, ${opacity})`,\r\n            legendFontColor: colors.text.primary,\r\n            legendFontSize: 12,\r\n          };\r\n        })\r\n        .filter(item => item.population > 0);\r\n    };\r\n\r\n    const dataL1 = formatData(distL1);\r\n    const dataL2 = formatData(distL2);\r\n    const dataL3 = formatData(distL3);\r\n\r\n    return { dataL1, dataL2, dataL3 };\r\n  }, [workouts]);\r\n\r\n  // Get data item counts for height calculation\r\n  const dataItemCounts = useMemo(() => [dataL1.length, dataL2.length, dataL3.length], [dataL1, dataL2, dataL3]);\r\n\r\n  // Initialize height on mount and when data changes\r\n  useEffect(() => {\r\n    const expectedHeight = calculateExpectedHeight(dataItemCounts[currentPage]);\r\n    if (!isHeightInitialized) {\r\n      heightAnim.setValue(expectedHeight);\r\n      setIsHeightInitialized(true);\r\n    }\r\n  }, [dataItemCounts, isHeightInitialized]);\r\n\r\n  // Animate height when page changes or measured heights update\r\n  useEffect(() => {\r\n    const measuredHeight = pageHeights[currentPage];\r\n    const expectedHeight = calculateExpectedHeight(dataItemCounts[currentPage]);\r\n    const targetHeight = measuredHeight || expectedHeight;\r\n    \r\n    if (targetHeight > 0 && isHeightInitialized) {\r\n      Animated.timing(heightAnim, {\r\n        toValue: targetHeight,\r\n        duration: 300,\r\n        useNativeDriver: false,\r\n        easing: Easing.out(Easing.cubic),\r\n      }).start();\r\n    }\r\n  }, [currentPage, pageHeights, dataItemCounts, isHeightInitialized]);\r\n\r\n  // Clear page-specific selections when switching pages\r\n  useEffect(() => {\r\n    setSelections({});\r\n  }, [currentPage]);\r\n\r\n  // Reset pageHeights when workout data changes significantly\r\n  useEffect(() => {\r\n    if (workouts.length !== lastWorkoutCount.current) {\r\n      lastWorkoutCount.current = workouts.length;\r\n      setPageHeights({});\r\n    }\r\n  }, [workouts.length]);\r\n\r\n  // Reset state when user returns to the performance tab\r\n  useFocusEffect(\r\n    useCallback(() => {\r\n      setCurrentPage(0);\r\n      setSelections({});\r\n      // Don't reset height initialization to avoid flicker\r\n      // Just reset scroll position\r\n      scrollViewRef.current?.scrollTo({ x: 0, animated: false });\r\n      \r\n      // Sync height to page 0's expected/measured height\r\n      const measuredHeight = pageHeights[0];\r\n      const expectedHeight = calculateExpectedHeight(dataItemCounts[0]);\r\n      const targetHeight = measuredHeight || expectedHeight;\r\n      if (targetHeight > 0) {\r\n        heightAnim.setValue(targetHeight);\r\n      }\r\n    }, [pageHeights, dataItemCounts])\r\n  );\r\n\r\n  const handleMomentumScrollEnd = (event: NativeSyntheticEvent<NativeScrollEvent>) => {\r\n    const contentOffsetX = event.nativeEvent.contentOffset.x;\r\n    const pageIndex = Math.round(contentOffsetX / CHART_WIDTH);\r\n    if (pageIndex !== currentPage) {\r\n      setCurrentPage(pageIndex);\r\n    }\r\n  };\r\n\r\n  const handleScrollEndDrag = (event: NativeSyntheticEvent<NativeScrollEvent>) => {\r\n    const { contentOffset, velocity, targetContentOffset } = event.nativeEvent;\r\n\r\n    // 1. Trust the OS prediction if available (iOS mostly)\r\n    if (targetContentOffset) {\r\n      const targetPage = Math.round(targetContentOffset.x / CHART_WIDTH);\r\n      if (targetPage !== currentPage) {\r\n        setCurrentPage(targetPage);\r\n      }\r\n      return;\r\n    }\r\n\r\n    // 2. Fallback for Android/others: Predict based on velocity + position\r\n    let targetPage = currentPage;\r\n    const currentPosition = contentOffset.x / CHART_WIDTH;\r\n\r\n    if (velocity && Math.abs(velocity.x) > 0.2) {\r\n      // Significant velocity: snap in direction of swipe\r\n      if (velocity.x > 0) {\r\n        targetPage = Math.ceil(currentPosition);\r\n      } else {\r\n        targetPage = Math.floor(currentPosition);\r\n      }\r\n    } else {\r\n      // Low velocity: snap to nearest\r\n      targetPage = Math.round(currentPosition);\r\n    }\r\n\r\n    // Clamp and update\r\n    targetPage = Math.max(0, Math.min(2, targetPage));\r\n\r\n    if (targetPage !== currentPage) {\r\n      setCurrentPage(targetPage);\r\n    }\r\n  };\r\n\r\n  const handlePageLayout = (index: number) => (event: LayoutChangeEvent) => {\r\n    const { height } = event.nativeEvent.layout;\r\n    if (Math.abs((pageHeights[index] || 0) - height) > 1) {\r\n      setPageHeights(prev => ({ ...prev, [index]: height }));\r\n    }\r\n  };\r\n\r\n  const handleSelectSlice = (pageIndex: number, name: string) => {\r\n    setSelections(prev => {\r\n      const current = prev[pageIndex];\r\n      if (current === name) {\r\n        const next = { ...prev };\r\n        delete next[pageIndex];\r\n        return next;\r\n      }\r\n      return { ...prev, [pageIndex]: name };\r\n    });\r\n  };\r\n\r\n  if (workouts.length === 0) {\r\n    return (\r\n      <View style={styles.emptyContainer}>\r\n        <Text variant=\"body\" color=\"secondary\" style={{ textAlign: 'center' }}>No workout data available yet.</Text>\r\n      </View>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <View style={styles.container}>\r\n      <View style={styles.pagination}>\r\n        {[0, 1, 2].map((index) => (\r\n          <View\r\n            key={index}\r\n            style={[\r\n              styles.dot,\r\n              index === currentPage ? styles.activeDot : styles.inactiveDot\r\n            ]}\r\n          />\r\n        ))}\r\n      </View>\r\n\r\n      <Animated.View style={[styles.chartWrapper, { height: heightAnim }]}>\r\n        <ScrollView\r\n          ref={scrollViewRef}\r\n          horizontal\r\n          pagingEnabled\r\n          showsHorizontalScrollIndicator={false}\r\n          onMomentumScrollEnd={handleMomentumScrollEnd}\r\n          onScrollEndDrag={handleScrollEndDrag}\r\n          style={{ width: CHART_WIDTH }}\r\n          contentContainerStyle={{ alignItems: 'flex-start' }}\r\n        >\r\n          <ChartPage\r\n            title=\"Body Region\"\r\n            data={dataL1}\r\n            selectedSlice={selections[0] || null}\r\n            onSelectSlice={(name) => handleSelectSlice(0, name)}\r\n            onLayout={handlePageLayout(0)}\r\n          />\r\n          <ChartPage\r\n            title=\"Muscle Group\"\r\n            data={dataL2}\r\n            selectedSlice={selections[1] || null}\r\n            onSelectSlice={(name) => handleSelectSlice(1, name)}\r\n            onLayout={handlePageLayout(1)}\r\n          />\r\n          <ChartPage\r\n            title=\"Specific Muscle\"\r\n            data={dataL3}\r\n            selectedSlice={selections[2] || null}\r\n            onSelectSlice={(name) => handleSelectSlice(2, name)}\r\n            onLayout={handlePageLayout(2)}\r\n          />\r\n        </ScrollView>\r\n      </Animated.View>\r\n    </View>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    width: '100%',\r\n  },\r\n  chartWrapper: {\r\n    overflow: 'hidden',\r\n    minHeight: MIN_CHART_HEIGHT,\r\n  },\r\n  pageContainer: {\r\n    width: CHART_WIDTH,\r\n    alignItems: 'center',\r\n  },\r\n  chartContainer: {\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    marginBottom: spacing.md,\r\n  },\r\n  chartTitle: {\r\n    marginBottom: spacing.sm,\r\n    textAlign: 'center',\r\n  },\r\n  emptyContainer: {\r\n    padding: spacing.sm,\r\n    alignItems: 'center',\r\n    minHeight: 60,\r\n  },\r\n  emptyChart: {\r\n    height: 120,\r\n    alignItems: 'center',\r\n  },\r\n  pagination: {\r\n    flexDirection: 'row',\r\n    marginBottom: spacing.md,\r\n    gap: spacing.sm,\r\n  },\r\n  dot: {\r\n    width: 8,\r\n    height: 8,\r\n    borderRadius: radius.full,\r\n  },\r\n  activeDot: {\r\n    backgroundColor: colors.accent.primary,\r\n  },\r\n  inactiveDot: {\r\n    backgroundColor: colors.neutral.gray400,\r\n  },\r\n  customLegend: {\r\n    flexDirection: 'row',\r\n    flexWrap: 'wrap',\r\n    justifyContent: 'center',\r\n    marginTop: spacing.sm,\r\n    gap: spacing.sm,\r\n  },\r\n  legendItem: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n  },\r\n  legendColor: {\r\n    width: 12,\r\n    height: 12,\r\n    borderRadius: 2,\r\n    marginRight: spacing.xs,\r\n  }\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\FractalBubbleChart.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getSubtitle' is assigned a value but never used.","line":130,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":130,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * FractalDonutChart\r\n * Interactive donut chart with drill-down capability\r\n * Uses orange color with opacity based on index\r\n */\r\n\r\nimport React, { useState, useMemo, useCallback } from 'react';\r\nimport { View, StyleSheet, Pressable, TouchableOpacity } from 'react-native';\r\nimport Animated, { FadeIn } from 'react-native-reanimated';\r\nimport { VictoryPie } from 'victory-native';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\nimport { Ionicons } from '@expo/vector-icons';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { colors, spacing, radius } from '@/constants/theme';\r\nimport type { HierarchicalSetData, ChartSlice } from '@/types/analytics';\r\n\r\nconst PIE_SIZE = 240;\r\n\r\ninterface FractalBubbleChartProps {\r\n  data: HierarchicalSetData;\r\n  onMusclePress?: (muscleName: string) => void;\r\n  /** Optional: Start at a specific L1 group (e.g., \"Upper Body\", \"Lower Body\", \"Core\") */\r\n  rootGroup?: string;\r\n}\r\n\r\ninterface BreadcrumbItem {\r\n  name: string;\r\n  level: 'root' | 'L1' | 'L2' | 'L3';\r\n}\r\n\r\n// Orange with opacity based on index (sorted by value)\r\nconst getOrangeShade = (index: number, total: number): string => {\r\n  if (total <= 1) return 'rgba(255, 107, 74, 1.0)';\r\n  const ratio = index / (total - 1);\r\n  const opacity = 1.0 - ratio * 0.7;\r\n  return `rgba(255, 107, 74, ${opacity})`;\r\n};\r\n\r\n// Strip prefix from detailed muscle names for cleaner display\r\n// e.g., \"Biceps - Long Head\" -> \"Long Head\", \"Calves - Medial Head\" -> \"Medial Head\"\r\nconst getDisplayName = (fullName: string): string => {\r\n  if (fullName.includes(' - ')) {\r\n    return fullName.split(' - ')[1];\r\n  }\r\n  return fullName;\r\n};\r\n\r\nexport const FractalBubbleChart: React.FC<FractalBubbleChartProps> = ({ data, onMusclePress, rootGroup }) => {\r\n  // If rootGroup is provided, start at L1 level with that group\r\n  const initialBreadcrumb: BreadcrumbItem[] = rootGroup \r\n    ? [{ name: rootGroup, level: 'L1' }]\r\n    : [{ name: 'Overview', level: 'root' }];\r\n  const [breadcrumb, setBreadcrumb] = useState<BreadcrumbItem[]>(initialBreadcrumb);\r\n  const [selectedSlice, setSelectedSlice] = useState<string | null>(null);\r\n\r\n  // Get current level's data with RELATIVE percentages (sum to 100%)\r\n  const currentData = useMemo((): ChartSlice[] => {\r\n    const current = breadcrumb[breadcrumb.length - 1];\r\n    let rawData: ChartSlice[] = current.level === 'root' \r\n      ? data.root \r\n      : data.byParent[`${current.level}:${current.name}`] || [];\r\n    \r\n    const totalValue = rawData.reduce((sum, item) => sum + item.value, 0);\r\n    return rawData\r\n      .map(item => ({ ...item, percentage: totalValue > 0 ? (item.value / totalValue) * 100 : 0 }))\r\n      .sort((a, b) => b.percentage - a.percentage);\r\n  }, [breadcrumb, data]);\r\n\r\n  const hasChildren = useCallback((name: string): boolean => {\r\n    const current = breadcrumb[breadcrumb.length - 1];\r\n    // Determine the next level based on current level\r\n    // root -> L1, L1 -> L2, L2 -> L3, L3 -> null (L4 is the deepest, no further drill-down)\r\n    const nextLevel = current.level === 'root' ? 'L1' \r\n      : current.level === 'L1' ? 'L2' \r\n      : current.level === 'L2' ? 'L3' \r\n      : null;\r\n    if (!nextLevel) return false;\r\n    const children = data.byParent[`${nextLevel}:${name}`];\r\n    return children && children.length > 0;\r\n  }, [breadcrumb, data]);\r\n\r\n  const handleSlicePress = useCallback((name: string) => {\r\n    triggerHaptic('light');\r\n    \r\n    if (selectedSlice === name) {\r\n      // Second tap - drill down or navigate\r\n      if (hasChildren(name)) {\r\n        const current = breadcrumb[breadcrumb.length - 1];\r\n        // Determine the next level based on current level\r\n        const nextLevel = current.level === 'root' ? 'L1' \r\n          : current.level === 'L1' ? 'L2' \r\n          : current.level === 'L2' ? 'L3' \r\n          : 'L3'; // Fallback, shouldn't reach here if hasChildren is false\r\n        setBreadcrumb([...breadcrumb, { name, level: nextLevel as any }]);\r\n        setSelectedSlice(null);\r\n      } else {\r\n        onMusclePress?.(name);\r\n      }\r\n    } else {\r\n      setSelectedSlice(name);\r\n    }\r\n  }, [selectedSlice, hasChildren, breadcrumb, onMusclePress]);\r\n\r\n  const handleBreadcrumbPress = useCallback((index: number) => {\r\n    triggerHaptic('light');\r\n    setBreadcrumb(breadcrumb.slice(0, index + 1));\r\n    setSelectedSlice(null);\r\n  }, [breadcrumb]);\r\n\r\n  // Prepare chart data with colors\r\n  const chartData = useMemo(() => {\r\n    return currentData.map((item, index) => ({\r\n      x: item.name,\r\n      y: item.percentage,\r\n      color: getOrangeShade(index, currentData.length),\r\n    }));\r\n  }, [currentData]);\r\n\r\n  const colorScale = chartData.map(d => d.color);\r\n\r\n  const getCurrentGroupName = (): string => {\r\n    const current = breadcrumb[breadcrumb.length - 1];\r\n    if (current.level === 'root') return 'All Muscle Groups';\r\n    // For L1 level when it's the root (rootGroup mode), just show the group name\r\n    if (current.level === 'L1' && breadcrumb.length === 1) return current.name;\r\n    return current.name;\r\n  };\r\n\r\n  const getSubtitle = (): string => {\r\n    const current = breadcrumb[breadcrumb.length - 1];\r\n    if (current.level === 'root') return 'Tap slice to select, tap again to drill down';\r\n    // For L1 level when it's the starting point (rootGroup mode)\r\n    if (current.level === 'L1' && breadcrumb.length === 1) return 'Tap slice to select, tap again to drill down';\r\n    if (current.level === 'L1') return 'Muscle group breakdown';\r\n    if (current.level === 'L2') return 'Specific muscles';\r\n    return 'Detailed breakdown';\r\n  };\r\n\r\n  // Check if we have data - for rootGroup mode, check the L1 data\r\n  const hasData = rootGroup \r\n    ? (data.byParent[`L1:${rootGroup}`] && data.byParent[`L1:${rootGroup}`].length > 0)\r\n    : (data.root && data.root.length > 0);\r\n\r\n  return (\r\n    <View style={styles.container}>\r\n      <View style={styles.header}>\r\n        <Text variant=\"heading3\" color=\"primary\" style={styles.headerTitle}>\r\n          {getCurrentGroupName()}\r\n        </Text>\r\n      </View>\r\n\r\n      <View style={styles.breadcrumbContainer}>\r\n        {breadcrumb.map((item, index) => (\r\n          <View key={`${item.level}-${item.name}`} style={styles.breadcrumbItem}>\r\n            {index > 0 && <Ionicons name=\"chevron-forward\" size={14} color={colors.text.tertiary} />}\r\n            <Pressable\r\n              onPress={() => handleBreadcrumbPress(index)}\r\n              style={[styles.breadcrumbButton, index === breadcrumb.length - 1 && styles.breadcrumbButtonActive]}\r\n            >\r\n              <Text variant=\"caption\" color={index === breadcrumb.length - 1 ? 'primary' : 'tertiary'}>\r\n                {item.name}\r\n              </Text>\r\n            </Pressable>\r\n          </View>\r\n        ))}\r\n      </View>\r\n\r\n      {!hasData ? (\r\n        <View style={styles.emptyContainer}>\r\n          <Text variant=\"body\" color=\"secondary\" style={styles.emptyText}>No workout data available</Text>\r\n        </View>\r\n      ) : currentData.length > 0 ? (\r\n        <>\r\n          <Animated.View key={breadcrumb.map(b => b.name).join('-')} entering={FadeIn.duration(200)} style={styles.chartContainer}>\r\n            <VictoryPie\r\n              data={chartData}\r\n              width={PIE_SIZE + 40}\r\n              height={PIE_SIZE + 40}\r\n              colorScale={colorScale}\r\n              innerRadius={58}\r\n              startAngle={0}\r\n              endAngle={-360}\r\n              radius={({ datum }) => selectedSlice === datum.x ? PIE_SIZE / 2 + 8 : PIE_SIZE / 2}\r\n              padAngle={2}\r\n              style={{\r\n                data: {\r\n                  fill: ({ datum }) => selectedSlice && selectedSlice !== datum.x ? colors.neutral.gray200 : datum.color,\r\n                },\r\n                labels: { fill: 'transparent' },\r\n              }}\r\n              events={[{\r\n                target: 'data',\r\n                eventHandlers: {\r\n                  onPressIn: () => [{\r\n                    target: 'data',\r\n                    mutation: (props) => {\r\n                      handleSlicePress(props.datum.x);\r\n                      return null;\r\n                    },\r\n                  }],\r\n                },\r\n              }]}\r\n            />\r\n\r\n            {/* Selected slice info in center */}\r\n            {selectedSlice && (\r\n              <View style={styles.selectedInfo}>\r\n                <Text variant=\"labelMedium\" color=\"primary\" numberOfLines={1}>{getDisplayName(selectedSlice)}</Text>\r\n                <Text variant=\"heading2\" color=\"primary\">\r\n                  {Math.round(currentData.find(d => d.name === selectedSlice)?.percentage || 0)}%\r\n                </Text>\r\n              </View>\r\n            )}\r\n          </Animated.View>\r\n\r\n          {/* Drill down hint below donut */}\r\n          {selectedSlice && hasChildren(selectedSlice) && (\r\n            <View style={styles.drillHint}>\r\n              <Ionicons name=\"finger-print-outline\" size={14} color={colors.text.tertiary} />\r\n              <Text variant=\"caption\" color=\"tertiary\">Tap again to explore</Text>\r\n            </View>\r\n          )}\r\n        </>\r\n      ) : (\r\n        <View style={styles.noDataContainer}>\r\n          <Text variant=\"body\" color=\"secondary\">No data at this level</Text>\r\n          <Pressable onPress={() => handleBreadcrumbPress(breadcrumb.length - 2)} style={styles.goBackButton}>\r\n            <Ionicons name=\"arrow-back\" size={16} color={colors.accent.orange} />\r\n            <Text variant=\"caption\" color=\"secondary\">Go back</Text>\r\n          </Pressable>\r\n        </View>\r\n      )}\r\n\r\n      {/* Legend */}\r\n      <View style={styles.legendContainer}>\r\n        {currentData.map((item, index) => {\r\n          const isSelected = selectedSlice === item.name;\r\n          const isDimmed = selectedSlice !== null && !isSelected;\r\n          const canDrill = hasChildren(item.name);\r\n\r\n          return (\r\n            <TouchableOpacity\r\n              key={item.name}\r\n              style={[styles.legendItem, { opacity: isDimmed ? 0.4 : 1 }]}\r\n              onPress={() => handleSlicePress(item.name)}\r\n            >\r\n              <View style={[styles.legendDot, { backgroundColor: getOrangeShade(index, currentData.length) }]} />\r\n              <Text variant=\"caption\" color=\"primary\" style={styles.legendText} numberOfLines={1}>\r\n                {getDisplayName(item.name)}\r\n              </Text>\r\n              {canDrill && <Ionicons name=\"chevron-forward\" size={12} color={colors.text.tertiary} />}\r\n              <Text variant=\"caption\" color=\"secondary\">{Math.round(item.percentage)}%</Text>\r\n            </TouchableOpacity>\r\n          );\r\n        })}\r\n      </View>\r\n    </View>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  container: { gap: spacing.md },\r\n  header: {\r\n    paddingBottom: spacing.xs,\r\n    alignItems: 'center',\r\n  },\r\n  headerTitle: {\r\n    textAlign: 'center',\r\n  },\r\n  headerSubtitle: {\r\n    textAlign: 'center',\r\n  },\r\n  breadcrumbContainer: { flexDirection: 'row', alignItems: 'center', flexWrap: 'wrap', gap: spacing.xs, paddingVertical: spacing.xs },\r\n  breadcrumbItem: { flexDirection: 'row', alignItems: 'center' },\r\n  breadcrumbButton: { paddingHorizontal: spacing.sm, paddingVertical: spacing.xs, borderRadius: radius.sm },\r\n  breadcrumbButtonActive: { backgroundColor: colors.neutral.gray200 },\r\n  chartContainer: { alignItems: 'center', justifyContent: 'center', position: 'relative' },\r\n  selectedInfo: { position: 'absolute', alignItems: 'center', justifyContent: 'center', width: 120 },\r\n  drillHint: { flexDirection: 'row', alignItems: 'center', justifyContent: 'center', gap: spacing.xs },\r\n  legendContainer: { flexDirection: 'row', flexWrap: 'wrap', justifyContent: 'center', gap: spacing.sm, paddingTop: spacing.sm },\r\n  legendItem: { flexDirection: 'row', alignItems: 'center', paddingVertical: spacing.xs, paddingHorizontal: spacing.sm, backgroundColor: colors.surface.subtle, borderRadius: radius.sm, gap: spacing.xs },\r\n  legendDot: { width: 10, height: 10, borderRadius: 5 },\r\n  legendText: { maxWidth: 80 },\r\n  emptyContainer: { padding: spacing.lg, alignItems: 'center', gap: spacing.xs },\r\n  emptyText: { textAlign: 'center' },\r\n  noDataContainer: { alignItems: 'center', justifyContent: 'center', gap: spacing.md, padding: spacing.lg, minHeight: 200 },\r\n  goBackButton: { flexDirection: 'row', alignItems: 'center', gap: spacing.xs, paddingHorizontal: spacing.md, paddingVertical: spacing.sm, borderRadius: radius.md, backgroundColor: colors.neutral.gray200 },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\GpsActivityTracker.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\InlineExerciseSearch.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'timingMedium' is defined but never used.","line":22,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":34}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * InlineExerciseSearch\r\n * A lightweight inline search component for quick exercise discovery.\r\n * Shows suggestions that expand on focus with one-tap add functionality.\r\n */\r\nimport React, { useCallback, useMemo, useState } from 'react';\r\nimport { Pressable, StyleSheet, TextInput, View } from 'react-native';\r\nimport Animated, {\r\n  FadeIn,\r\n  FadeOut,\r\n  FadeInDown,\r\n  FadeOutUp,\r\n  useAnimatedStyle,\r\n  useSharedValue,\r\n  withTiming,\r\n} from 'react-native-reanimated';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { IconSymbol } from '@/components/ui/icon-symbol';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\nimport { colors, radius, spacing, typography, sizing } from '@/constants/theme';\r\nimport { timingFast, timingMedium } from '@/constants/animations';\r\nimport { useSemanticExerciseSearch } from '@/hooks/useSemanticExerciseSearch';\r\nimport { exercises as exerciseCatalog, type Exercise } from '@/constants/exercises';\r\nimport { getExerciseDisplayTags } from '@/utils/exerciseDisplayTags';\r\n\r\ninterface InlineExerciseSearchProps {\r\n  onAddExercise: (exercise: Exercise) => void;\r\n  excludeIds?: string[];\r\n  placeholder?: string;\r\n  maxSuggestions?: number;\r\n  onBrowseAll?: () => void;\r\n}\r\n\r\nexport const InlineExerciseSearch: React.FC<InlineExerciseSearchProps> = ({\r\n  onAddExercise,\r\n  excludeIds = [],\r\n  placeholder = 'Search exercises...',\r\n  maxSuggestions = 5,\r\n  onBrowseAll,\r\n}) => {\r\n  const [searchTerm, setSearchTerm] = useState('');\r\n  const [isFocused, setIsFocused] = useState(false);\r\n  const focusProgress = useSharedValue(0);\r\n\r\n  // Get suggestions based on search term\r\n  const suggestions = useSemanticExerciseSearch(searchTerm, exerciseCatalog, {\r\n    limit: maxSuggestions,\r\n    excludeIds,\r\n  });\r\n\r\n  // Show popular exercises when search is empty and focused\r\n  const popularExercises = useMemo(() => {\r\n    if (searchTerm.trim()) return [];\r\n    const excluded = new Set(excludeIds);\r\n    const popularIds = [\r\n      'bench-press', 'squat', 'deadlift', 'lat-pulldown', 'shoulder-press',\r\n      'bicep-curl', 'tricep-pushdown', 'leg-press', 'pull-up', 'dumbbell-row'\r\n    ];\r\n    return exerciseCatalog\r\n      .filter(ex => popularIds.includes(ex.id) && !excluded.has(ex.id))\r\n      .slice(0, maxSuggestions);\r\n  }, [excludeIds, searchTerm, maxSuggestions]);\r\n\r\n  const displayExercises = searchTerm.trim() ? suggestions : popularExercises;\r\n  const showSuggestions = isFocused && displayExercises.length > 0;\r\n\r\n  const animatedBorderStyle = useAnimatedStyle(() => ({\r\n    borderColor: focusProgress.value > 0 ? colors.accent.primary : colors.border.light,\r\n  }));\r\n\r\n  const handleFocus = useCallback(() => {\r\n    focusProgress.value = withTiming(1, timingFast);\r\n    setIsFocused(true);\r\n  }, [focusProgress]);\r\n\r\n  const handleBlur = useCallback(() => {\r\n    focusProgress.value = withTiming(0, timingFast);\r\n    // Delay blur to allow tap on suggestions\r\n    setTimeout(() => setIsFocused(false), 150);\r\n  }, [focusProgress]);\r\n\r\n  const handleAddExercise = useCallback((exercise: Exercise) => {\r\n    triggerHaptic('light');\r\n    onAddExercise(exercise);\r\n    setSearchTerm('');\r\n  }, [onAddExercise]);\r\n\r\n  const handleClearSearch = useCallback(() => {\r\n    triggerHaptic('selection');\r\n    setSearchTerm('');\r\n  }, []);\r\n\r\n  return (\r\n    <View style={styles.container}>\r\n      {/* Search Input */}\r\n      <Animated.View style={[styles.inputContainer, animatedBorderStyle]}>\r\n        <IconSymbol\r\n          name=\"search\"\r\n          size={sizing.iconSM}\r\n          color={isFocused ? colors.accent.primary : colors.text.tertiary}\r\n        />\r\n        <TextInput\r\n          value={searchTerm}\r\n          onChangeText={setSearchTerm}\r\n          placeholder={placeholder}\r\n          placeholderTextColor={colors.text.muted}\r\n          selectionColor={colors.accent.primary}\r\n          cursorColor={colors.accent.primary}\r\n          style={styles.textInput}\r\n          onFocus={handleFocus}\r\n          onBlur={handleBlur}\r\n          returnKeyType=\"search\"\r\n          autoCapitalize=\"none\"\r\n          autoCorrect={false}\r\n        />\r\n        {searchTerm.length > 0 && (\r\n          <Pressable onPress={handleClearSearch} hitSlop={8}>\r\n            <IconSymbol\r\n              name=\"close\"\r\n              size={sizing.iconSM}\r\n              color={colors.text.tertiary}\r\n            />\r\n          </Pressable>\r\n        )}\r\n      </Animated.View>\r\n\r\n      {/* Suggestions */}\r\n      {showSuggestions && (\r\n        <Animated.View\r\n          entering={FadeInDown.duration(200).springify()}\r\n          exiting={FadeOutUp.duration(150)}\r\n          style={styles.suggestionsContainer}\r\n        >\r\n          <View style={styles.suggestionsHeader}>\r\n            <Text variant=\"caption\" color=\"secondary\">\r\n              {searchTerm.trim() ? 'Suggested' : 'Popular exercises'}\r\n            </Text>\r\n            {onBrowseAll && (\r\n              <Pressable onPress={onBrowseAll} hitSlop={8}>\r\n                <Text variant=\"caption\" style={styles.browseAllText}>\r\n                  Browse all\r\n                </Text>\r\n              </Pressable>\r\n            )}\r\n          </View>\r\n          <View style={styles.suggestionsList}>\r\n            {displayExercises.map((exercise) => (\r\n              <SuggestionRow\r\n                key={exercise.id}\r\n                exercise={exercise}\r\n                onAdd={handleAddExercise}\r\n              />\r\n            ))}\r\n          </View>\r\n        </Animated.View>\r\n      )}\r\n\r\n      {/* Empty State for Search */}\r\n      {isFocused && searchTerm.trim() && suggestions.length === 0 && (\r\n        <Animated.View\r\n          entering={FadeIn.duration(150)}\r\n          exiting={FadeOut.duration(100)}\r\n          style={styles.emptyState}\r\n        >\r\n          <Text variant=\"body\" color=\"secondary\">\r\n            No exercises found for &quot;{searchTerm}&quot;\r\n          </Text>\r\n          {onBrowseAll && (\r\n            <Pressable onPress={onBrowseAll}>\r\n              <Text variant=\"bodySemibold\" style={styles.browseAllText}>\r\n                Browse all exercises\r\n              </Text>\r\n            </Pressable>\r\n          )}\r\n        </Animated.View>\r\n      )}\r\n    </View>\r\n  );\r\n};\r\n\r\n// Suggestion Row Sub-component\r\ninterface SuggestionRowProps {\r\n  exercise: Exercise;\r\n  onAdd: (exercise: Exercise) => void;\r\n}\r\n\r\nconst SuggestionRow: React.FC<SuggestionRowProps> = ({ exercise, onAdd }) => {\r\n  const tags = getExerciseDisplayTags({\r\n    muscles: exercise.muscles,\r\n    exerciseType: exercise.exerciseType,\r\n  }, { maxTags: 1 });\r\n  const primaryTag = tags[0] || null;\r\n\r\n  const handlePress = useCallback(() => {\r\n    onAdd(exercise);\r\n  }, [exercise, onAdd]);\r\n\r\n  return (\r\n    <Pressable\r\n      onPress={handlePress}\r\n      style={({ pressed }) => [\r\n        styles.suggestionRow,\r\n        pressed && styles.suggestionRowPressed,\r\n      ]}\r\n    >\r\n      <View style={styles.suggestionInfo}>\r\n        <Text variant=\"body\" color=\"primary\" numberOfLines={1}>\r\n          {exercise.name}\r\n        </Text>\r\n        {primaryTag && (\r\n          <Text variant=\"captionSmall\" color=\"tertiary\">\r\n            {primaryTag}\r\n          </Text>\r\n        )}\r\n      </View>\r\n      <View style={styles.addButton}>\r\n        <IconSymbol\r\n          name=\"add\"\r\n          size={18}\r\n          color={colors.accent.orange}\r\n        />\r\n      </View>\r\n    </Pressable>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    width: '100%',\r\n    gap: spacing.sm,\r\n  },\r\n  inputContainer: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    gap: spacing.sm,\r\n    paddingHorizontal: spacing.md,\r\n    paddingVertical: spacing.sm,\r\n    backgroundColor: colors.surface.card,\r\n    borderRadius: radius.md,\r\n    borderWidth: 1,\r\n  },\r\n  textInput: {\r\n    flex: 1,\r\n    ...typography.body,\r\n    fontWeight: typography.body.fontWeight as any,\r\n    color: colors.text.primary,\r\n    paddingVertical: spacing.xs,\r\n  },\r\n  suggestionsContainer: {\r\n    gap: spacing.xs,\r\n  },\r\n  suggestionsHeader: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'space-between',\r\n    paddingHorizontal: spacing.xs,\r\n  },\r\n  suggestionsList: {\r\n    gap: spacing.xs,\r\n  },\r\n  suggestionRow: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'space-between',\r\n    paddingVertical: spacing.sm,\r\n    paddingHorizontal: spacing.md,\r\n    backgroundColor: colors.surface.card,\r\n    borderRadius: radius.md,\r\n    borderWidth: 1,\r\n    borderColor: colors.border.light,\r\n  },\r\n  suggestionRowPressed: {\r\n    backgroundColor: colors.accent.orangeMuted,\r\n    borderColor: colors.accent.orange,\r\n  },\r\n  suggestionInfo: {\r\n    flex: 1,\r\n    gap: 2,\r\n  },\r\n  addButton: {\r\n    width: 28,\r\n    height: 28,\r\n    borderRadius: radius.full,\r\n    backgroundColor: colors.accent.orangeMuted,\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n  },\r\n  emptyState: {\r\n    alignItems: 'center',\r\n    gap: spacing.sm,\r\n    paddingVertical: spacing.lg,\r\n  },\r\n  browseAllText: {\r\n    color: colors.accent.orange,\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\InsightCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\MonthlyCalendar.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useDerivedValue' is defined but never used.","line":8,"column":67,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":82}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * MonthlyCalendar\n * Molecule rendering a monthly calendar grid with animated month controls.\n */\n\nimport React, { useCallback, useMemo } from 'react';\nimport { StyleSheet, TouchableOpacity, View } from 'react-native';\nimport Animated, { SharedValue, useAnimatedStyle, useSharedValue, useDerivedValue, withSpring } from 'react-native-reanimated';\nimport { triggerHaptic } from '@/utils/haptics';\nimport { Ionicons } from '@expo/vector-icons';\n\nimport { CalendarDayCell } from '@/components/atoms/CalendarDayCell';\nimport { SurfaceCard } from '@/components/atoms/SurfaceCard';\nimport { Text } from '@/components/atoms/Text';\nimport { buttonPressAnimation, springSmooth } from '@/constants/animations';\nimport { radius, spacing } from '@/constants/theme';\nimport { useTheme } from '@/hooks/useTheme';\nimport { useMonthlyCalendar, type UseMonthlyCalendarOptions } from '@/hooks/useMonthlyCalendar';\n\ninterface MonthlyCalendarProps extends UseMonthlyCalendarOptions {\n  onDayLongPress?: (isoDate: string) => void;\n}\n\nexport const MonthlyCalendar: React.FC<MonthlyCalendarProps> = ({ onDayLongPress, ...hookOptions }) => {\n  const { theme } = useTheme();\n  const { monthLabel, weekdayLabels, gridItems, goToPreviousMonth, goToNextMonth, selectDate } =\n    useMonthlyCalendar(hookOptions);\n\n  const weekRows = useMemo(() => {\n    const rows: typeof gridItems[] = [];\n    for (let index = 0; index < gridItems.length; index += 7) {\n      rows.push(gridItems.slice(index, index + 7));\n    }\n\n    return rows.filter((week) => week.some((item) => item.isCurrentMonth));\n  }, [gridItems]);\n\n  const prevScale = useSharedValue(1);\n  const nextScale = useSharedValue(1);\n\n  const prevAnimatedStyle = useAnimatedStyle(() => ({ transform: [{ scale: prevScale.value }] }));\n  const nextAnimatedStyle = useAnimatedStyle(() => ({ transform: [{ scale: nextScale.value }] }));\n\n  const animatePressIn = useCallback((scaleRef: SharedValue<number>) => {\n    scaleRef.value = withSpring(0.92, springSmooth);\n  }, []);\n\n  const animatePressOut = useCallback(\n    (scaleRef: SharedValue<number>, direction: 'prev' | 'next') => {\n      scaleRef.value = withSpring(1, springSmooth);\n      setTimeout(() => {\n        triggerHaptic('light');\n        if (direction === 'prev') {\n          goToPreviousMonth();\n        } else {\n          goToNextMonth();\n        }\n      }, buttonPressAnimation.duration);\n    },\n    [goToNextMonth, goToPreviousMonth]\n  );\n\n  return (\n    <SurfaceCard tone=\"neutral\" padding=\"lg\" showAccentStripe={false}>\n      <View style={styles.header}>\n        <TouchableOpacity\n          style={styles.navButton}\n          activeOpacity={0.9}\n          onPressIn={() => animatePressIn(prevScale)}\n          onPressOut={() => animatePressOut(prevScale, 'prev')}\n        >\n          <Animated.View style={prevAnimatedStyle}>\n            <Ionicons name=\"chevron-back\" size={spacing.xl} color={theme.text.primary} />\n          </Animated.View>\n        </TouchableOpacity>\n\n        <Text variant=\"heading3\" color=\"primary\">\n          {monthLabel}\n        </Text>\n\n        <TouchableOpacity\n          style={styles.navButton}\n          activeOpacity={0.9}\n          onPressIn={() => animatePressIn(nextScale)}\n          onPressOut={() => animatePressOut(nextScale, 'next')}\n        >\n          <Animated.View style={nextAnimatedStyle}>\n            <Ionicons name=\"chevron-forward\" size={spacing.xl} color={theme.text.primary} />\n          </Animated.View>\n        </TouchableOpacity>\n      </View>\n\n      <View style={styles.weekdayRow}>\n        {weekdayLabels.map((label, index) => (\n          <View key={`${label}-${index}`} style={styles.weekdayCell}>\n            <Text variant=\"caption\" color=\"secondary\">\n              {label}\n            </Text>\n          </View>\n        ))}\n      </View>\n\n      <View style={styles.grid}>\n        {weekRows.map((week, rowIndex) => (\n          <View\n            key={`week-${rowIndex}`}\n            style={[styles.weekRow, rowIndex !== weekRows.length - 1 && styles.weekRowSpacing]}\n          >\n            {week.map((item) => (\n              <View key={item.isoDate} style={styles.gridCell}>\n                {item.isCurrentMonth ? (\n                  <CalendarDayCell\n                    isoDate={item.isoDate}\n                    dayLabel={item.dayLabel}\n                    isCurrentMonth\n                    isToday={item.isToday}\n                    isSelected={item.isSelected}\n                    hasMarker={item.hasMarker}\n                    onSelect={selectDate}\n                    onLongPress={onDayLongPress}\n                  />\n                ) : (\n                  <View pointerEvents=\"none\" style={styles.hiddenPlaceholder} />\n                )}\n              </View>\n            ))}\n          </View>\n        ))}\n      </View>\n    </SurfaceCard>\n  );\n};\n\nconst styles = StyleSheet.create({\n  header: { flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', marginBottom: spacing.lg },\n  navButton: {\n    width: spacing['2xl'],\n    height: spacing['2xl'],\n    borderRadius: radius.full,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  weekdayRow: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    gap: spacing.sm,\n    marginBottom: spacing.md,\n  },\n  weekdayCell: { flex: 1, maxWidth: 56, alignItems: 'center' },\n  grid: { gap: spacing.sm },\n  weekRow: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    gap: spacing.sm,\n  },\n  weekRowSpacing: {\n    marginBottom: spacing.sm,\n  },\n  gridCell: { flex: 1, maxWidth: 56, alignItems: 'center' },\n  hiddenPlaceholder: { width: '100%', aspectRatio: 1 },\n});\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\MyScheduleCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\NameEditModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TouchableOpacity' is defined but never used.","line":11,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ActivityIndicator' is defined but never used.","line":14,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * NameEditModal\r\n * Modal for editing user's first and last name\r\n */\r\n\r\nimport React, { useState, useEffect } from 'react';\r\nimport {\r\n  Modal,\r\n  StyleSheet,\r\n  TouchableWithoutFeedback,\r\n  TouchableOpacity,\r\n  View,\r\n  Alert,\r\n  ActivityIndicator,\r\n} from 'react-native';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { Button } from '@/components/atoms/Button';\r\nimport { InputField } from '@/components/atoms/InputField';\r\nimport { colors, radius, spacing, shadows } from '@/constants/theme';\r\nimport { supabaseClient } from '@/lib/supabaseClient';\r\nimport { useUserProfileStore } from '@/store/userProfileStore';\r\n\r\ninterface NameEditModalProps {\r\n  visible: boolean;\r\n  firstName: string;\r\n  lastName: string;\r\n  onClose: () => void;\r\n  onSave: (firstName: string, lastName: string) => void;\r\n}\r\n\r\nexport const NameEditModal: React.FC<NameEditModalProps> = ({\r\n  visible,\r\n  firstName,\r\n  lastName,\r\n  onClose,\r\n  onSave,\r\n}) => {\r\n  const { updateProfile } = useUserProfileStore();\r\n  const [tempFirstName, setTempFirstName] = useState(firstName);\r\n  const [tempLastName, setTempLastName] = useState(lastName);\r\n  const [isSaving, setIsSaving] = useState(false);\r\n\r\n  // Reset form when modal opens\r\n  useEffect(() => {\r\n    if (visible) {\r\n      setTempFirstName(firstName);\r\n      setTempLastName(lastName);\r\n      setIsSaving(false); // Reset saving state when modal opens\r\n    }\r\n  }, [visible, firstName, lastName]);\r\n\r\n  const handleCancel = () => {\r\n    if (isSaving) return; // Prevent closing while saving\r\n    triggerHaptic('selection');\r\n    onClose();\r\n  };\r\n\r\n  const handleSave = async () => {\r\n    if (isSaving) return; // Prevent multiple saves\r\n\r\n    triggerHaptic('success');\r\n\r\n    const trimmedFirst = tempFirstName.trim();\r\n    const trimmedLast = tempLastName.trim();\r\n\r\n    // Validate input\r\n    if (!trimmedFirst && !trimmedLast) {\r\n      Alert.alert('Invalid Name', 'Please enter at least a first name or last name.');\r\n      return;\r\n    }\r\n\r\n    setIsSaving(true);\r\n    console.log('[NameEditModal] Starting save...', { trimmedFirst, trimmedLast });\r\n\r\n    try {\r\n      // Get current user\r\n      const { data: { user } } = await supabaseClient.auth.getUser();\r\n\r\n      if (!user) {\r\n        throw new Error('No authenticated user');\r\n      }\r\n\r\n      console.log('[NameEditModal] Updating profiles table...');\r\n\r\n      // Update profiles table directly (skip auth.updateUser which is problematic)\r\n      const { error: profileError } = await supabaseClient\r\n        .from('profiles')\r\n        .upsert({\r\n          id: user.id,\r\n          email: user.email,\r\n          first_name: trimmedFirst,\r\n          last_name: trimmedLast,\r\n          full_name: `${trimmedFirst} ${trimmedLast}`.trim(),\r\n          updated_at: new Date().toISOString(),\r\n        });\r\n\r\n      if (profileError) {\r\n        throw profileError;\r\n      }\r\n\r\n      console.log('[NameEditModal] Profile updated successfully');\r\n\r\n      // Update the centralized store for real-time updates across the app\r\n      updateProfile(trimmedFirst, trimmedLast);\r\n\r\n      // Update parent component state (for backwards compatibility)\r\n      console.log('[NameEditModal] Calling onSave callback');\r\n      onSave(trimmedFirst, trimmedLast);\r\n\r\n      // Close modal\r\n      console.log('[NameEditModal] Closing modal');\r\n      onClose();\r\n\r\n    } catch (error: any) {\r\n      console.error('[NameEditModal] Error saving name:', error);\r\n      Alert.alert('Error', error.message || 'Failed to save name. Please try again.');\r\n    } finally {\r\n      setIsSaving(false);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <Modal\r\n      animationType=\"fade\"\r\n      transparent\r\n      visible={visible}\r\n      onRequestClose={handleCancel}\r\n      statusBarTranslucent\r\n    >\r\n      <TouchableWithoutFeedback onPress={handleCancel}>\r\n        <View style={styles.overlay}>\r\n          <TouchableWithoutFeedback>\r\n            <View style={styles.container}>\r\n              <Text variant=\"heading2\" color=\"primary\" style={styles.title}>\r\n                Edit Name\r\n              </Text>\r\n\r\n              <View style={styles.form}>\r\n                <InputField\r\n                  label=\"First Name\"\r\n                  value={tempFirstName}\r\n                  onChangeText={setTempFirstName}\r\n                  placeholder=\"Enter your first name\"\r\n                  autoCapitalize=\"words\"\r\n                  returnKeyType=\"next\"\r\n                  editable={!isSaving}\r\n                />\r\n\r\n                <InputField\r\n                  label=\"Last Name\"\r\n                  value={tempLastName}\r\n                  onChangeText={setTempLastName}\r\n                  placeholder=\"Enter your last name\"\r\n                  autoCapitalize=\"words\"\r\n                  returnKeyType=\"done\"\r\n                  editable={!isSaving}\r\n                />\r\n              </View>\r\n\r\n              <View style={styles.actions}>\r\n                <Button\r\n                  label=\"Cancel\"\r\n                  variant=\"ghost\"\r\n                  onPress={handleCancel}\r\n                  style={styles.button}\r\n                  disabled={isSaving}\r\n                />\r\n\r\n                <Button\r\n                  label=\"Save\"\r\n                  variant=\"primary\"\r\n                  onPress={handleSave}\r\n                  style={styles.button}\r\n                  loading={isSaving}\r\n                />\r\n              </View>\r\n            </View>\r\n          </TouchableWithoutFeedback>\r\n        </View>\r\n      </TouchableWithoutFeedback>\r\n    </Modal>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  overlay: {\r\n    flex: 1,\r\n    backgroundColor: colors.overlay.scrim,\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n    paddingHorizontal: spacing.lg,\r\n  },\r\n  container: {\r\n    backgroundColor: colors.surface.card,\r\n    borderRadius: radius.xl,\r\n    padding: spacing.xl,\r\n    width: '100%',\r\n    maxWidth: 400,\r\n    ...shadows.lg,\r\n  },\r\n  title: {\r\n    textAlign: 'center',\r\n    marginBottom: spacing.lg,\r\n  },\r\n  form: {\r\n    gap: spacing.md,\r\n    marginBottom: spacing.xl,\r\n  },\r\n  actions: {\r\n    flexDirection: 'row',\r\n    gap: spacing.md,\r\n    justifyContent: 'center',\r\n  },\r\n  button: {\r\n    flex: 1,\r\n    minWidth: 120,\r\n    minHeight: 44,\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\NotificationConfigCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\NotificationEditModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'DateTimePicker' is defined but never used.","line":8,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'handleTimeChange' is assigned a value but never used.","line":134,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":134,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * NotificationEditModal\r\n * Modal for creating or editing a notification configuration.\r\n */\r\n\r\nimport React, { useState, useCallback, useEffect } from 'react';\r\nimport { Modal, Pressable, ScrollView, StyleSheet, View, Platform } from 'react-native';\r\nimport DateTimePicker, { DateTimePickerEvent } from '@react-native-community/datetimepicker';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { Button } from '@/components/atoms/Button';\r\nimport { InputField } from '@/components/atoms/InputField';\r\nimport { colors, radius, shadows, spacing } from '@/constants/theme';\r\nimport { NotificationConfig, DayOfWeek } from '@/store/notificationStore';\r\n\r\ninterface NotificationEditModalProps {\r\n  visible: boolean;\r\n  config?: NotificationConfig | null;\r\n  onClose: () => void;\r\n  onSave: (hour: number, minute: number, days: DayOfWeek[]) => void;\r\n  hasOverlay?: boolean;\r\n}\r\n\r\nconst DAYS_OF_WEEK: { key: DayOfWeek; label: string; short: string }[] = [\r\n  { key: 'sunday', label: 'Sunday', short: 'S' },\r\n  { key: 'monday', label: 'Monday', short: 'M' },\r\n  { key: 'tuesday', label: 'Tuesday', short: 'T' },\r\n  { key: 'wednesday', label: 'Wednesday', short: 'W' },\r\n  { key: 'thursday', label: 'Thursday', short: 'T' },\r\n  { key: 'friday', label: 'Friday', short: 'F' },\r\n  { key: 'saturday', label: 'Saturday', short: 'S' },\r\n];\r\n\r\nexport const NotificationEditModal: React.FC<NotificationEditModalProps> = ({\r\n  visible,\r\n  config,\r\n  onClose,\r\n  onSave,\r\n  hasOverlay = true,\r\n}) => {\r\n  const [selectedTime, setSelectedTime] = useState(new Date());\r\n  const [selectedDays, setSelectedDays] = useState<DayOfWeek[]>([]);\r\n  const [showTimePicker, setShowTimePicker] = useState(Platform.OS === 'ios');\r\n  const [showTimePickerModal, setShowTimePickerModal] = useState(false);\r\n  \r\n  // Simple time input state\r\n  const [hourInput, setHourInput] = useState('');\r\n  const [minuteInput, setMinuteInput] = useState('');\r\n  const [ampm, setAmPm] = useState<'AM' | 'PM'>('AM');\r\n\r\n  // Reset state when modal opens\r\n  useEffect(() => {\r\n    if (visible) {\r\n      if (config) {\r\n        const date = new Date();\r\n        date.setHours(config.hour, config.minute, 0, 0);\r\n        setSelectedTime(date);\r\n        setSelectedDays([...config.days]);\r\n        \r\n        // Set simple input values\r\n        const hour = config.hour % 12 || 12;\r\n        setHourInput(hour.toString());\r\n        setMinuteInput(config.minute.toString().padStart(2, '0'));\r\n        setAmPm(config.hour >= 12 ? 'PM' : 'AM');\r\n      } else {\r\n        const date = new Date();\r\n        date.setHours(9, 0, 0, 0);\r\n        setSelectedTime(date);\r\n        setSelectedDays([]);\r\n        \r\n        // Set default input values\r\n        setHourInput('9');\r\n        setMinuteInput('00');\r\n        setAmPm('AM');\r\n      }\r\n      if (Platform.OS === 'android') {\r\n        setShowTimePicker(false);\r\n      }\r\n    }\r\n  }, [visible, config]);\r\n\r\n\r\n  const handleOpenTimePicker = () => {\r\n    setShowTimePickerModal(true);\r\n    triggerHaptic('selection');\r\n  };\r\n\r\n  const handleCloseTimePicker = () => {\r\n    setShowTimePickerModal(false);\r\n    triggerHaptic('selection');\r\n  };\r\n\r\n  const handleSaveTimePicker = () => {\r\n    // Validate and update time from inputs\r\n    const hour = parseInt(hourInput);\r\n    const minute = parseInt(minuteInput);\r\n    \r\n    if (isNaN(hour) || hour < 1 || hour > 12) {\r\n      triggerHaptic('error');\r\n      return;\r\n    }\r\n    \r\n    if (isNaN(minute) || minute < 0 || minute > 59) {\r\n      triggerHaptic('error');\r\n      return;\r\n    }\r\n    \r\n    // Convert to 24-hour format\r\n    const hour24 = hour === 12 ? (ampm === 'AM' ? 0 : 12) : (ampm === 'PM' ? hour + 12 : hour);\r\n    \r\n    const newDate = new Date(selectedTime);\r\n    newDate.setHours(hour24, minute, 0, 0);\r\n    setSelectedTime(newDate);\r\n    setShowTimePickerModal(false);\r\n    triggerHaptic('success');\r\n  };\r\n\r\n\r\n  const handleClose = useCallback(() => {\r\n    triggerHaptic('selection');\r\n    onClose();\r\n  }, [onClose]);\r\n\r\n  const handleSave = useCallback(() => {\r\n    if (selectedDays.length === 0) {\r\n      triggerHaptic('error');\r\n      return;\r\n    }\r\n    triggerHaptic('success');\r\n    onSave(selectedTime.getHours(), selectedTime.getMinutes(), selectedDays);\r\n  }, [selectedTime, selectedDays, onSave]);\r\n\r\n  const handleTimeChange = (event: DateTimePickerEvent, date?: Date) => {\r\n    if (Platform.OS === 'android') {\r\n      setShowTimePicker(false);\r\n    }\r\n    if (date) {\r\n      setSelectedTime(date);\r\n    }\r\n  };\r\n\r\n  const toggleDay = (day: DayOfWeek) => {\r\n    triggerHaptic('selection');\r\n    setSelectedDays((prev) =>\r\n      prev.includes(day) ? prev.filter((d) => d !== day) : [...prev, day]\r\n    );\r\n  };\r\n\r\n  const selectAllDays = () => {\r\n    triggerHaptic('selection');\r\n    setSelectedDays(DAYS_OF_WEEK.map((d) => d.key));\r\n  };\r\n\r\n  const selectWeekdays = () => {\r\n    triggerHaptic('selection');\r\n    setSelectedDays(['monday', 'tuesday', 'wednesday', 'thursday', 'friday']);\r\n  };\r\n\r\n  const formatDisplayTime = (): string => {\r\n    const hour = selectedTime.getHours();\r\n    const minute = selectedTime.getMinutes();\r\n    const period = hour >= 12 ? 'PM' : 'AM';\r\n    const displayHour = hour % 12 || 12;\r\n    return `${displayHour}:${minute.toString().padStart(2, '0')} ${period}`;\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <Modal visible={visible} animationType=\"fade\" transparent onRequestClose={handleClose} statusBarTranslucent>\r\n        {hasOverlay ? (\r\n          <Pressable style={styles.overlay} onPress={handleClose}>\r\n            <Pressable style={styles.modalContent} onPress={(e) => e.stopPropagation()}>\r\n              <Text variant=\"heading2\" color=\"primary\" style={styles.title}>\r\n                {config ? 'Edit Reminder' : 'Add Reminder'}\r\n              </Text>\r\n\r\n              <ScrollView style={styles.scrollContent} showsVerticalScrollIndicator={false} keyboardDismissMode=\"on-drag\">\r\n                {/* Time Selection */}\r\n                <View style={styles.section}>\r\n                  <Text variant=\"bodySemibold\" color=\"primary\" style={styles.sectionLabel}>\r\n                    Time\r\n                  </Text>\r\n                  {Platform.OS === 'android' && !showTimePicker && (\r\n                  <Pressable\r\n                    style={styles.timeButton}\r\n                    onPress={handleOpenTimePicker}\r\n                  >\r\n                    <Text variant=\"heading2\" color=\"primary\">\r\n                      {formatDisplayTime()}\r\n                    </Text>\r\n                  </Pressable>\r\n                )}\r\n                {Platform.OS === 'ios' && !showTimePicker && (\r\n                  <Pressable\r\n                    style={styles.timeButton}\r\n                    onPress={handleOpenTimePicker}\r\n                  >\r\n                    <Text variant=\"heading2\" color=\"primary\">\r\n                      {formatDisplayTime()}\r\n                    </Text>\r\n                  </Pressable>\r\n                )}\r\n              </View>\r\n\r\n              {/* Day Selection */}\r\n              <View style={styles.section}>\r\n                <Text variant=\"bodySemibold\" color=\"primary\" style={styles.sectionLabel}>\r\n                  Repeat on\r\n                </Text>\r\n\r\n                {/* Quick Select Buttons */}\r\n                <View style={styles.quickSelectRow}>\r\n                  <Pressable style={styles.quickSelectButton} onPress={selectAllDays}>\r\n                    <Text variant=\"caption\" color=\"secondary\">\r\n                      Every day\r\n                    </Text>\r\n                  </Pressable>\r\n                  <Pressable style={styles.quickSelectButton} onPress={selectWeekdays}>\r\n                    <Text variant=\"caption\" color=\"secondary\">\r\n                      Weekdays\r\n                    </Text>\r\n                  </Pressable>\r\n                </View>\r\n\r\n                {/* Day Buttons */}\r\n                <View style={styles.daysRow}>\r\n                  {DAYS_OF_WEEK.map((day) => {\r\n                    const isSelected = selectedDays.includes(day.key);\r\n                    return (\r\n                      <Pressable\r\n                        key={day.key}\r\n                        style={[styles.dayButton, isSelected && styles.dayButtonSelected]}\r\n                        onPress={() => toggleDay(day.key)}\r\n                      >\r\n                        <Text\r\n                          variant=\"bodySemibold\"\r\n                          color={isSelected ? 'onAccent' : 'primary'}\r\n                        >\r\n                          {day.short}\r\n                        </Text>\r\n                      </Pressable>\r\n                    );\r\n                  })}\r\n                </View>\r\n\r\n                {selectedDays.length === 0 && (\r\n                  <Text variant=\"caption\" color=\"secondary\" style={styles.hint}>\r\n                    Select at least one day\r\n                  </Text>\r\n                )}\r\n              </View>\r\n            </ScrollView>\r\n\r\n            <View style={styles.buttonRow}>\r\n              <Button\r\n                label=\"Cancel\"\r\n                variant=\"ghost\"\r\n                onPress={handleClose}\r\n                style={styles.button}\r\n              />\r\n              <Button\r\n                label=\"Save\"\r\n                variant=\"primary\"\r\n                onPress={handleSave}\r\n                style={styles.button}\r\n                disabled={selectedDays.length === 0}\r\n              />\r\n            </View>\r\n          </Pressable>\r\n        </Pressable>\r\n      ) : (\r\n        <View style={styles.container}>\r\n          <Pressable style={styles.modalContentNoOverlay} onPress={(e) => e.stopPropagation()}>\r\n            <Text variant=\"heading2\" color=\"primary\" style={styles.title}>\r\n              {config ? 'Edit Reminder' : 'Add Reminder'}\r\n            </Text>\r\n\r\n            <ScrollView style={styles.scrollContent} showsVerticalScrollIndicator={false} keyboardDismissMode=\"on-drag\">\r\n              {/* Time Selection */}\r\n              <View style={styles.section}>\r\n                <Text variant=\"bodySemibold\" color=\"primary\" style={styles.sectionLabel}>\r\n                  Time\r\n                </Text>\r\n                {Platform.OS === 'android' && !showTimePicker && (\r\n                <Pressable\r\n                  style={styles.timeButton}\r\n                  onPress={handleOpenTimePicker}\r\n                >\r\n                  <Text variant=\"heading2\" color=\"primary\">\r\n                    {formatDisplayTime()}\r\n                  </Text>\r\n                </Pressable>\r\n              )}\r\n              {Platform.OS === 'ios' && !showTimePicker && (\r\n                <Pressable\r\n                  style={styles.timeButton}\r\n                  onPress={handleOpenTimePicker}\r\n                >\r\n                  <Text variant=\"heading2\" color=\"primary\">\r\n                    {formatDisplayTime()}\r\n                  </Text>\r\n                </Pressable>\r\n              )}\r\n              </View>\r\n\r\n              {/* Day Selection */}\r\n              <View style={styles.section}>\r\n                <Text variant=\"bodySemibold\" color=\"primary\" style={styles.sectionLabel}>\r\n                  Repeat on\r\n                </Text>\r\n\r\n                {/* Quick Select Buttons */}\r\n                <View style={styles.quickSelectRow}>\r\n                  <Pressable style={styles.quickSelectButton} onPress={selectAllDays}>\r\n                    <Text variant=\"caption\" color=\"secondary\">\r\n                      Every day\r\n                    </Text>\r\n                  </Pressable>\r\n                  <Pressable style={styles.quickSelectButton} onPress={selectWeekdays}>\r\n                    <Text variant=\"caption\" color=\"secondary\">\r\n                      Weekdays\r\n                    </Text>\r\n                  </Pressable>\r\n                </View>\r\n\r\n                {/* Day Buttons */}\r\n                <View style={styles.daysRow}>\r\n                  {DAYS_OF_WEEK.map((day) => {\r\n                    const isSelected = selectedDays.includes(day.key);\r\n                    return (\r\n                      <Pressable\r\n                        key={day.key}\r\n                        style={[styles.dayButton, isSelected && styles.dayButtonSelected]}\r\n                        onPress={() => toggleDay(day.key)}\r\n                      >\r\n                        <Text\r\n                          variant=\"bodySemibold\"\r\n                          color={isSelected ? 'onAccent' : 'primary'}\r\n                        >\r\n                          {day.short}\r\n                        </Text>\r\n                      </Pressable>\r\n                    );\r\n                  })}\r\n                </View>\r\n\r\n                {selectedDays.length === 0 && (\r\n                  <Text variant=\"caption\" color=\"secondary\" style={styles.hint}>\r\n                    Select at least one day\r\n                  </Text>\r\n                )}\r\n              </View>\r\n            </ScrollView>\r\n\r\n            <View style={styles.buttonRow}>\r\n              <Button\r\n                label=\"Cancel\"\r\n                variant=\"ghost\"\r\n                onPress={handleClose}\r\n                style={styles.button}\r\n              />\r\n              <Button\r\n                label=\"Save\"\r\n                variant=\"primary\"\r\n                onPress={handleSave}\r\n                style={styles.button}\r\n                disabled={selectedDays.length === 0}\r\n              />\r\n            </View>\r\n          </Pressable>\r\n        </View>\r\n      )}\r\n    </Modal>\r\n    \r\n    {/* Simple Time Picker Modal */}\r\n    <Modal visible={showTimePickerModal} animationType=\"fade\" transparent onRequestClose={handleCloseTimePicker} statusBarTranslucent>\r\n      <View style={styles.timePickerModalContainer}>\r\n        <View style={styles.timePickerModalContent}>\r\n          <Text variant=\"heading2\" color=\"primary\" style={styles.timePickerTitle}>\r\n            Set Time\r\n          </Text>\r\n          \r\n          {/* Time Input Fields */}\r\n          <View style={styles.timeInputContainer}>\r\n            <View style={styles.timeInputRow}>\r\n              {/* Hour Input */}\r\n              <View style={styles.timeInputWrapper}>\r\n                <InputField\r\n                  label=\"Hour\"\r\n                  value={hourInput}\r\n                  onChangeText={(text) => {\r\n                    // Only allow numbers 1-12\r\n                    const num = parseInt(text);\r\n                    if (text === '' || (!isNaN(num) && num >= 1 && num <= 12)) {\r\n                      setHourInput(text);\r\n                    }\r\n                  }}\r\n                  placeholder=\"1-12\"\r\n                  keyboardType=\"numeric\"\r\n                  autoFocus={true}\r\n                  onFocus={() => {\r\n                    if (hourInput === '9') {\r\n                      setHourInput('');\r\n                    }\r\n                  }}\r\n                />\r\n              </View>\r\n              \r\n              {/* Separator */}\r\n              <Text variant=\"heading2\" color=\"primary\" style={styles.timeSeparator}>\r\n                :\r\n              </Text>\r\n              \r\n              {/* Minute Input */}\r\n              <View style={styles.timeInputWrapper}>\r\n                <InputField\r\n                  label=\"Minute\"\r\n                  value={minuteInput}\r\n                  onChangeText={(text) => {\r\n                    // Only allow numbers 00-59\r\n                    if (text === '') {\r\n                      setMinuteInput('');\r\n                      return;\r\n                    }\r\n                    \r\n                    const num = parseInt(text);\r\n                    if (!isNaN(num) && num >= 0 && num <= 59) {\r\n                      // Just use the input as-is, no automatic leading zero\r\n                      setMinuteInput(text);\r\n                    }\r\n                  }}\r\n                  placeholder=\"00-59\"\r\n                  keyboardType=\"numeric\"\r\n                  onFocus={() => {\r\n                    if (minuteInput === '00') {\r\n                      setMinuteInput('');\r\n                    }\r\n                  }}\r\n                />\r\n              </View>\r\n            </View>\r\n            \r\n            {/* AM/PM Selector */}\r\n            <View style={styles.ampmSelector}>\r\n              <Pressable\r\n                style={[\r\n                  styles.ampmOption,\r\n                  ampm === 'AM' && styles.ampmOptionSelected\r\n                ]}\r\n                onPress={() => {\r\n                  setAmPm('AM');\r\n                  triggerHaptic('selection');\r\n                }}\r\n              >\r\n                <Text\r\n                  variant=\"bodySemibold\"\r\n                  color={ampm === 'AM' ? 'onAccent' : 'primary'}\r\n                >\r\n                  AM\r\n                </Text>\r\n              </Pressable>\r\n              <Pressable\r\n                style={[\r\n                  styles.ampmOption,\r\n                  ampm === 'PM' && styles.ampmOptionSelected\r\n                ]}\r\n                onPress={() => {\r\n                  setAmPm('PM');\r\n                  triggerHaptic('selection');\r\n                }}\r\n              >\r\n                <Text\r\n                  variant=\"bodySemibold\"\r\n                  color={ampm === 'PM' ? 'onAccent' : 'primary'}\r\n                >\r\n                  PM\r\n                </Text>\r\n              </Pressable>\r\n            </View>\r\n          </View>\r\n          \r\n          {/* Action Buttons */}\r\n          <View style={styles.buttonRow}>\r\n            <Button\r\n              label=\"Cancel\"\r\n              variant=\"ghost\"\r\n              onPress={handleCloseTimePicker}\r\n              style={styles.button}\r\n            />\r\n            <Button\r\n              label=\"OK\"\r\n              variant=\"primary\"\r\n              onPress={handleSaveTimePicker}\r\n              style={styles.button}\r\n            />\r\n          </View>\r\n        </View>\r\n      </View>\r\n    </Modal>\r\n    </>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  overlay: {\r\n    flex: 1,\r\n    backgroundColor: colors.overlay.scrim,\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n    padding: spacing.lg,\r\n  },\r\n  container: {\r\n    flex: 1,\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n    padding: spacing.lg,\r\n  },\r\n  modalContent: {\r\n    backgroundColor: colors.surface.card,\r\n    borderRadius: radius.xl,\r\n    padding: spacing.xl,\r\n    width: 350,\r\n    height: 450,\r\n    ...shadows.lg,\r\n  },\r\n  modalContentNoOverlay: {\r\n    backgroundColor: colors.surface.card,\r\n    borderRadius: radius.xl,\r\n    padding: spacing.xl,\r\n    width: 350,\r\n    height: 450,\r\n    ...shadows.lg,\r\n  },\r\n  title: {\r\n    marginBottom: spacing.md,\r\n    textAlign: 'center',\r\n  },\r\n  scrollContent: {\r\n    flexGrow: 0,\r\n  },\r\n  section: {\r\n    marginBottom: spacing.lg,\r\n  },\r\n  sectionLabel: {\r\n    marginBottom: spacing.sm,\r\n  },\r\n  timeButton: {\r\n    backgroundColor: colors.surface.elevated,\r\n    borderRadius: radius.md,\r\n    padding: spacing.md,\r\n    alignItems: 'center',\r\n    borderWidth: 1,\r\n    borderColor: colors.border.light,\r\n  },\r\n  timePickerContainer: {\r\n    backgroundColor: colors.surface.elevated,\r\n    borderRadius: radius.lg,\r\n    padding: spacing.sm,\r\n    alignItems: 'center',\r\n    borderWidth: 1,\r\n    borderColor: colors.border.light,\r\n  },\r\n  unifiedClock: {\r\n    alignItems: 'center',\r\n    gap: spacing.md,\r\n  },\r\n  clockFace: {\r\n    width: 100,\r\n    height: 100,\r\n    backgroundColor: colors.surface.card,\r\n    borderRadius: radius.full,\r\n    borderWidth: 1,\r\n    borderColor: colors.border.light,\r\n    position: 'relative',\r\n  },\r\n  clockCenter: {\r\n    position: 'absolute',\r\n    width: 6,\r\n    height: 6,\r\n    backgroundColor: colors.accent.orange,\r\n    borderRadius: radius.full,\r\n    left: 47,\r\n    top: 47,\r\n  },\r\n  clockNumber: {\r\n    position: 'absolute',\r\n    width: 30,\r\n    height: 30,\r\n    borderRadius: radius.full,\r\n    backgroundColor: 'transparent',\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n  },\r\n  clockNumberSelected: {\r\n    backgroundColor: colors.accent.orange,\r\n  },\r\n  clockNumberText: {\r\n    fontSize: 14,\r\n    fontWeight: '600',\r\n  },\r\n  minuteMarker: {\r\n    position: 'absolute',\r\n    width: 4,\r\n    height: 4,\r\n    borderRadius: radius.full,\r\n    backgroundColor: colors.border.light,\r\n  },\r\n  minuteMarkerSelected: {\r\n    backgroundColor: colors.accent.orange,\r\n  },\r\n  hourHand: {\r\n    position: 'absolute',\r\n    width: 4,\r\n    height: 30,\r\n    backgroundColor: colors.text.primary,\r\n    borderRadius: 2,\r\n    left: 48,\r\n    top: 20,\r\n    transformOrigin: 'center bottom',\r\n  },\r\n  minuteHand: {\r\n    position: 'absolute',\r\n    width: 3,\r\n    height: 38,\r\n    backgroundColor: colors.text.secondary,\r\n    borderRadius: 2,\r\n    left: 48.5,\r\n    top: 12,\r\n    transformOrigin: 'center bottom',\r\n  },\r\n  ampmSelector: {\r\n    flexDirection: 'row',\r\n    gap: spacing.sm,\r\n    marginTop: spacing.md,\r\n  },\r\n  ampmOption: {\r\n    backgroundColor: colors.surface.elevated,\r\n    borderRadius: radius.md,\r\n    paddingVertical: spacing.sm,\r\n    paddingHorizontal: spacing.lg,\r\n    borderWidth: 1,\r\n    borderColor: colors.border.light,\r\n    minWidth: 60,\r\n    alignItems: 'center',\r\n  },\r\n  ampmOptionSelected: {\r\n    backgroundColor: colors.accent.orange,\r\n    borderColor: colors.accent.orange,\r\n  },\r\n  customTimePicker: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    gap: spacing.md,\r\n  },\r\n  timeColumn: {\r\n    alignItems: 'center',\r\n    gap: spacing.xs,\r\n  },\r\n  timeLabel: {\r\n    textAlign: 'center',\r\n    fontSize: 10,\r\n    marginBottom: 2,\r\n  },\r\n  timeButtonCustom: {\r\n    backgroundColor: colors.surface.card,\r\n    borderRadius: radius.sm,\r\n    padding: spacing.sm,\r\n    minWidth: 45,\r\n    minHeight: 45,\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    borderWidth: 1,\r\n    borderColor: colors.border.light,\r\n  },\r\n  timeButtonUpDown: {\r\n    minWidth: 35,\r\n    minHeight: 25,\r\n  },\r\n  timeControl: {\r\n    alignItems: 'center',\r\n    gap: 2,\r\n  },\r\n  timeDisplay: {\r\n    backgroundColor: colors.surface.elevated,\r\n    borderRadius: radius.sm,\r\n    paddingVertical: spacing.xs,\r\n    paddingHorizontal: spacing.sm,\r\n    minWidth: 45,\r\n    alignItems: 'center',\r\n    borderWidth: 1,\r\n    borderColor: colors.border.light,\r\n  },\r\n  timeButtonSmall: {\r\n    padding: spacing.xs,\r\n    minWidth: 30,\r\n    minHeight: 25,\r\n  },\r\n  timeSeparator: {\r\n    fontSize: 24,\r\n    fontWeight: '600',\r\n    marginBottom: spacing.xs,\r\n  },\r\n  timePicker: {\r\n    height: 150,\r\n  },\r\n  quickSelectRow: {\r\n    flexDirection: 'row',\r\n    gap: spacing.sm,\r\n    marginBottom: spacing.md,\r\n  },\r\n  quickSelectButton: {\r\n    paddingVertical: spacing.xs,\r\n    paddingHorizontal: spacing.md,\r\n    borderRadius: radius.full,\r\n    backgroundColor: colors.surface.elevated,\r\n    borderWidth: 1,\r\n    borderColor: colors.border.light,\r\n  },\r\n  daysRow: {\r\n    flexDirection: 'row',\r\n    justifyContent: 'space-between',\r\n    gap: spacing.xxs,\r\n  },\r\n  dayButton: {\r\n    width: 36,\r\n    height: 36,\r\n    borderRadius: radius.full,\r\n    backgroundColor: colors.surface.elevated,\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    borderWidth: 1,\r\n    borderColor: colors.border.light,\r\n  },\r\n  dayButtonSelected: {\r\n    backgroundColor: colors.accent.orange,\r\n    borderColor: colors.accent.orange,\r\n  },\r\n  hint: {\r\n    marginTop: spacing.sm,\r\n    textAlign: 'center',\r\n  },\r\n  buttonRow: {\r\n    flexDirection: 'row',\r\n    gap: spacing.md,\r\n    marginTop: spacing.md,\r\n  },\r\n  button: {\r\n    flex: 1,\r\n    minWidth: 120,\r\n    minHeight: 44,\r\n  },\r\n  // Time Picker Modal Styles\r\n  timePickerModalContainer: {\r\n    flex: 1,\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n  },\r\n  timePickerModalContent: {\r\n    backgroundColor: colors.surface.card,\r\n    borderRadius: radius.xl,\r\n    paddingTop: spacing['2xl'],\r\n    paddingHorizontal: spacing.xl,\r\n    paddingBottom: spacing['2xl'],\r\n    width: 350,\r\n    height: 450,\r\n    alignItems: 'center',\r\n    ...shadows.lg,\r\n  },\r\n  timePickerTitle: {\r\n    marginBottom: spacing.lg,\r\n    textAlign: 'center',\r\n  },\r\n  timeInputContainer: {\r\n    width: '100%',\r\n    alignItems: 'center',\r\n    marginBottom: spacing.lg,\r\n  },\r\n  timeInputRow: {\r\n    flexDirection: 'row',\r\n    alignItems: 'flex-end',\r\n    gap: spacing.sm,\r\n    marginBottom: spacing.lg,\r\n  },\r\n  timeInputWrapper: {\r\n    flex: 1,\r\n  },\r\n  timePickerButtons: {\r\n    flexDirection: 'row',\r\n    gap: spacing.md,\r\n    width: '100%',\r\n    marginTop: spacing.xl,\r\n  },\r\n  timePickerButton: {\r\n    flex: 1,\r\n    minWidth: 80,\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\NotificationsModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\PRCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\PlanActionCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\PlanBuilderCard.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ScrollView' is defined but never used.","line":12,"column":50,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":60}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * PlanBuilderCard\r\n * A unified, single-card plan builder that combines:\r\n * - Plan name input\r\n * - Inline workout selector\r\n * - Selected workout list with reorder/delete\r\n * - Progress indicator and save button\r\n *\r\n * Designed for an effortless, one-screen plan creation experience.\r\n */\r\nimport React, { useCallback, useMemo, useState } from 'react';\r\nimport { Pressable, StyleSheet, TextInput, View, ScrollView } from 'react-native';\r\nimport Animated, {\r\n  FadeIn,\r\n  FadeOut,\r\n  Layout,\r\n  useAnimatedStyle,\r\n  useSharedValue,\r\n  withTiming,\r\n} from 'react-native-reanimated';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { Button } from '@/components/atoms/Button';\r\nimport { SurfaceCard } from '@/components/atoms/SurfaceCard';\r\nimport { IconSymbol } from '@/components/ui/icon-symbol';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\nimport { colors, radius, spacing, typography, sizing } from '@/constants/theme';\r\nimport { timingFast } from '@/constants/animations';\r\nimport type { Plan } from '@/store/plansStore';\r\n\r\ninterface PlanBuilderCardProps {\r\n  // Name input\r\n  planName: string;\r\n  onPlanNameChange: (name: string) => void;\r\n  namePlaceholder?: string;\r\n  isNameDuplicate?: boolean;\r\n\r\n  // Workouts\r\n  availableWorkouts: Plan[];\r\n  selectedWorkouts: Plan[];\r\n  onAddWorkout: (workout: Plan) => void;\r\n  onRemoveWorkout: (workoutId: string) => void;\r\n  onReorderWorkouts?: (fromIndex: number, toIndex: number) => void;\r\n\r\n  // Save action\r\n  onSave: () => void;\r\n  saveLabel?: string;\r\n  isSaving?: boolean;\r\n  isSaveDisabled?: boolean;\r\n\r\n  // Optional callbacks\r\n  onCreateWorkout?: () => void;\r\n  enableRowAnimations?: boolean;\r\n}\r\n\r\nexport const PlanBuilderCard: React.FC<PlanBuilderCardProps> = ({\r\n  planName,\r\n  onPlanNameChange,\r\n  namePlaceholder = 'e.g. Push Pull Legs, Full Body Split',\r\n  isNameDuplicate = false,\r\n\r\n  availableWorkouts,\r\n  selectedWorkouts,\r\n  onAddWorkout,\r\n  onRemoveWorkout,\r\n  onReorderWorkouts,\r\n\r\n  onSave,\r\n  saveLabel = 'Save Plan',\r\n  isSaving = false,\r\n  isSaveDisabled = false,\r\n\r\n  onCreateWorkout,\r\n  enableRowAnimations = true,\r\n}) => {\r\n  const nameFocusProgress = useSharedValue(0);\r\n  const [showWorkoutPicker, setShowWorkoutPicker] = useState(false);\r\n  const hasWorkouts = selectedWorkouts.length > 0;\r\n  const hasName = planName.trim().length > 0;\r\n  const hasAvailableWorkouts = availableWorkouts.length > 0;\r\n\r\n  // Filter out already selected workouts from available list\r\n  const unselectedWorkouts = useMemo(() => {\r\n    const selectedIds = new Set(selectedWorkouts.map(w => w.id));\r\n    return availableWorkouts.filter(w => !selectedIds.has(w.id));\r\n  }, [availableWorkouts, selectedWorkouts]);\r\n  const hasUnselectedWorkouts = unselectedWorkouts.length > 0;\r\n\r\n  // Progress state\r\n  const progressState = useMemo(() => {\r\n    if (!hasName && !hasWorkouts) return 'empty';\r\n    if (!hasName && hasWorkouts) return 'needs-name';\r\n    if (hasName && !hasWorkouts) return 'needs-workouts';\r\n    return 'ready';\r\n  }, [hasName, hasWorkouts]);\r\n\r\n  const progressMessage = useMemo(() => {\r\n    switch (progressState) {\r\n      case 'empty':\r\n        return 'Start by giving your plan a name';\r\n      case 'needs-name':\r\n        return 'Add a name to save your plan';\r\n      case 'needs-workouts':\r\n        return 'Add workouts to complete your plan';\r\n      case 'ready':\r\n        return `${selectedWorkouts.length} workout${selectedWorkouts.length !== 1 ? 's' : ''} ready`;\r\n    }\r\n  }, [progressState, selectedWorkouts.length]);\r\n\r\n  // Animated styles for name input\r\n  const animatedNameBorderStyle = useAnimatedStyle(() => ({\r\n    borderColor:\r\n      nameFocusProgress.value > 0 ? colors.accent.primary : colors.border.light,\r\n  }));\r\n\r\n  const handleNameFocus = useCallback(() => {\r\n    nameFocusProgress.value = withTiming(1, timingFast);\r\n  }, [nameFocusProgress]);\r\n\r\n  const handleNameBlur = useCallback(() => {\r\n    nameFocusProgress.value = withTiming(0, timingFast);\r\n  }, [nameFocusProgress]);\r\n\r\n  const handleAddWorkout = useCallback((workout: Plan) => {\r\n    triggerHaptic('light');\r\n    onAddWorkout(workout);\r\n  }, [onAddWorkout]);\r\n\r\n  const handleRemoveWorkout = useCallback((workoutId: string) => {\r\n    triggerHaptic('warning');\r\n    onRemoveWorkout(workoutId);\r\n  }, [onRemoveWorkout]);\r\n\r\n  const handleMoveUp = useCallback(\r\n    (index: number) => {\r\n      if (onReorderWorkouts && index > 0) {\r\n        triggerHaptic('selection');\r\n        onReorderWorkouts(index, index - 1);\r\n      }\r\n    },\r\n    [onReorderWorkouts]\r\n  );\r\n\r\n  const handleMoveDown = useCallback(\r\n    (index: number) => {\r\n      if (onReorderWorkouts && index < selectedWorkouts.length - 1) {\r\n        triggerHaptic('selection');\r\n        onReorderWorkouts(index, index + 1);\r\n      }\r\n    },\r\n    [onReorderWorkouts, selectedWorkouts.length]\r\n  );\r\n\r\n  return (\r\n    <SurfaceCard tone=\"card\" padding=\"xl\" showAccentStripe>\r\n      <View style={styles.container}>\r\n        {/* Section 1: Plan Name */}\r\n        <View style={styles.section}>\r\n          <View style={styles.sectionHeader}>\r\n            <Text variant=\"bodySemibold\" color=\"primary\">\r\n              Name\r\n            </Text>\r\n          </View>\r\n          <Animated.View style={[styles.nameInputContainer, animatedNameBorderStyle]}>\r\n            <TextInput\r\n              value={planName}\r\n              onChangeText={onPlanNameChange}\r\n              placeholder={namePlaceholder}\r\n              placeholderTextColor={colors.text.muted}\r\n              selectionColor={colors.accent.primary}\r\n              cursorColor={colors.accent.primary}\r\n              style={styles.nameInput}\r\n              onFocus={handleNameFocus}\r\n              onBlur={handleNameBlur}\r\n              returnKeyType=\"next\"\r\n              autoCapitalize=\"words\"\r\n            />\r\n          </Animated.View>\r\n          {isNameDuplicate && planName.trim().length > 0 && (\r\n            <Text variant=\"caption\" color=\"red\" style={styles.errorText}>\r\n              A plan with this name already exists\r\n            </Text>\r\n          )}\r\n        </View>\r\n\r\n        {/* Divider */}\r\n        <View style={styles.divider} />\r\n\r\n        {/* Section 2: Add Workouts */}\r\n        <View style={styles.section}>\r\n          <View style={styles.sectionHeader}>\r\n            <Text variant=\"bodySemibold\" color=\"primary\">\r\n              Workouts\r\n            </Text>\r\n            {hasWorkouts && (\r\n              <View style={styles.countBadge}>\r\n                <Text variant=\"caption\" color=\"primary\" style={styles.countText}>\r\n                  {selectedWorkouts.length}\r\n                </Text>\r\n              </View>\r\n            )}\r\n          </View>\r\n          {hasWorkouts && (\r\n            <View style={styles.workoutList}>\r\n              {selectedWorkouts.map((workout, index) => (\r\n                <SelectedWorkoutRow\r\n                  key={workout.id}\r\n                  workout={workout}\r\n                  index={index}\r\n                  totalCount={selectedWorkouts.length}\r\n                  onRemove={handleRemoveWorkout}\r\n                  onMoveUp={onReorderWorkouts ? handleMoveUp : undefined}\r\n                  onMoveDown={onReorderWorkouts ? handleMoveDown : undefined}\r\n                  enableRowAnimations={enableRowAnimations}\r\n                />\r\n              ))}\r\n            </View>\r\n          )}\r\n          {onReorderWorkouts && selectedWorkouts.length > 1 && (\r\n            <Text variant=\"caption\" color=\"secondary\" style={styles.reorderHint}>\r\n              Tap arrows to reorder\r\n            </Text>\r\n          )}\r\n\r\n          {hasAvailableWorkouts ? (\r\n            hasUnselectedWorkouts ? (\r\n              <>\r\n                <Pressable\r\n                  onPress={() => setShowWorkoutPicker(!showWorkoutPicker)}\r\n                  style={({ pressed }) => [\r\n                    styles.workoutPickerButton,\r\n                    pressed && styles.workoutPickerButtonPressed,\r\n                  ]}\r\n                >\r\n                  <IconSymbol\r\n                    name={showWorkoutPicker ? 'remove' : 'add'}\r\n                    size={sizing.iconMD}\r\n                    color={colors.accent.orange}\r\n                  />\r\n                  <Text variant=\"body\" style={styles.pickerButtonText}>\r\n                    {showWorkoutPicker ? 'Hide workouts' : 'Add Workouts'}\r\n                  </Text>\r\n                </Pressable>\r\n\r\n                {showWorkoutPicker && (\r\n                  <Animated.View\r\n                    entering={FadeIn.duration(150)}\r\n                    exiting={FadeOut.duration(100)}\r\n                    style={styles.workoutPickerList}\r\n                  >\r\n                    {unselectedWorkouts.map((workout) => (\r\n                      <Pressable\r\n                        key={workout.id}\r\n                        style={({ pressed }) => [\r\n                          styles.workoutOption,\r\n                          pressed && styles.workoutOptionPressed,\r\n                        ]}\r\n                        onPress={() => handleAddWorkout(workout)}\r\n                      >\r\n                        <View style={styles.workoutOptionInfo}>\r\n                          <Text variant=\"body\" color=\"primary\" numberOfLines={1}>\r\n                            {workout.name}\r\n                          </Text>\r\n                          <Text variant=\"captionSmall\" color=\"tertiary\">\r\n                            {workout.exercises.length} exercise{workout.exercises.length !== 1 ? 's' : ''}\r\n                          </Text>\r\n                        </View>\r\n                        <View style={styles.addButton}>\r\n                          <IconSymbol\r\n                            name=\"add\"\r\n                            size={18}\r\n                            color={colors.accent.orange}\r\n                          />\r\n                        </View>\r\n                      </Pressable>\r\n                    ))}\r\n                  </Animated.View>\r\n                )}\r\n              </>\r\n            ) : (\r\n              <Text variant=\"body\" color=\"secondary\" style={styles.allAddedText}>\r\n                All workouts have been added\r\n              </Text>\r\n            )\r\n          ) : (\r\n            <View style={styles.noWorkoutsContainer}>\r\n              <IconSymbol\r\n                name=\"fitness-center\"\r\n                size={32}\r\n                color={colors.text.muted}\r\n              />\r\n              <Text variant=\"body\" color=\"tertiary\" style={styles.noWorkoutsText}>\r\n                Create workouts first to build a plan\r\n              </Text>\r\n              {onCreateWorkout && (\r\n                <Button\r\n                  label=\"Create a Workout\"\r\n                  variant=\"ghost\"\r\n                  size=\"md\"\r\n                  onPress={onCreateWorkout}\r\n                />\r\n              )}\r\n            </View>\r\n          )}\r\n        </View>\r\n\r\n        {/* Divider */}\r\n        <View style={styles.divider} />\r\n\r\n        {/* Section 4: Progress & Save */}\r\n        <View style={styles.section}>\r\n          {/* Progress Indicator */}\r\n          <View style={styles.progressContainer}>\r\n            <View\r\n              style={[\r\n                styles.progressDot,\r\n                progressState === 'ready' && styles.progressDotReady,\r\n              ]}\r\n            />\r\n            <Text variant=\"caption\" color={progressState === 'ready' ? 'primary' : 'secondary'}>\r\n              {progressMessage}\r\n            </Text>\r\n          </View>\r\n\r\n          {/* Save Button */}\r\n          <Button\r\n            label={saveLabel}\r\n            variant=\"primary\"\r\n            size=\"lg\"\r\n            onPress={onSave}\r\n            disabled={isSaveDisabled || isNameDuplicate}\r\n            loading={isSaving}\r\n          />\r\n        </View>\r\n      </View>\r\n    </SurfaceCard>\r\n  );\r\n};\r\n\r\n// Selected Workout Row Sub-component\r\ninterface SelectedWorkoutRowProps {\r\n  workout: Plan;\r\n  index: number;\r\n  totalCount: number;\r\n  onRemove: (workoutId: string) => void;\r\n  onMoveUp?: (index: number) => void;\r\n  onMoveDown?: (index: number) => void;\r\n  enableRowAnimations?: boolean;\r\n}\r\n\r\nconst SelectedWorkoutRow: React.FC<SelectedWorkoutRowProps> = ({\r\n  workout,\r\n  index,\r\n  totalCount,\r\n  onRemove,\r\n  onMoveUp,\r\n  onMoveDown,\r\n  enableRowAnimations = true,\r\n}) => {\r\n  const isFirst = index === 0;\r\n  const isLast = index === totalCount - 1;\r\n  const hasReorderHandlers = Boolean(onMoveUp && onMoveDown);\r\n  const canReorder = hasReorderHandlers && totalCount > 1;\r\n\r\n  const RowWrapper = enableRowAnimations ? Animated.View : View;\r\n\r\n  return (\r\n    <RowWrapper\r\n      {...(enableRowAnimations ? {\r\n        layout: Layout.springify().damping(20).stiffness(200),\r\n        entering: FadeIn.duration(200),\r\n        exiting: FadeOut.duration(150),\r\n      } : {})}\r\n      style={styles.selectedWorkoutRow}\r\n    >\r\n      {/* Reorder controls on the left when enabled; otherwise no spacer */}\r\n      {canReorder && (\r\n        <View style={styles.reorderArea}>\r\n          <Pressable\r\n            onPress={() => onMoveUp?.(index)}\r\n            disabled={isFirst}\r\n            style={styles.reorderButton}\r\n            hitSlop={4}\r\n          >\r\n            <IconSymbol\r\n              name=\"keyboard-arrow-up\"\r\n              size={20}\r\n              color={isFirst ? colors.text.muted : colors.text.secondary}\r\n            />\r\n          </Pressable>\r\n          <Pressable\r\n            onPress={() => onMoveDown?.(index)}\r\n            disabled={isLast}\r\n            style={styles.reorderButton}\r\n            hitSlop={4}\r\n          >\r\n            <IconSymbol\r\n              name=\"keyboard-arrow-down\"\r\n              size={20}\r\n              color={isLast ? colors.text.muted : colors.text.secondary}\r\n            />\r\n          </Pressable>\r\n        </View>\r\n      )}\r\n\r\n      {/* Workout name + metadata in the middle */}\r\n      <View style={styles.textContainer}>\r\n        <Text variant=\"body\" color=\"primary\" numberOfLines={1}>\r\n          {workout.name}\r\n        </Text>\r\n        <Text variant=\"caption\" color=\"secondary\">\r\n          {workout.exercises.length} exercise{workout.exercises.length !== 1 ? 's' : ''}\r\n        </Text>\r\n      </View>\r\n\r\n      {/* X/remove button on the right, matching CompactExerciseRow */}\r\n      <Pressable\r\n        onPress={() => onRemove(workout.id)}\r\n        style={styles.removeButton}\r\n        hitSlop={12}\r\n      >\r\n        <IconSymbol\r\n          name=\"close\"\r\n          size={18}\r\n          color={colors.text.tertiary}\r\n        />\r\n      </Pressable>\r\n    </RowWrapper>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    gap: spacing.lg,\r\n  },\r\n  section: {\r\n    gap: spacing.sm,\r\n  },\r\n  sectionHeader: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'space-between',\r\n  },\r\n  nameInputContainer: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    gap: spacing.sm,\r\n    paddingHorizontal: spacing.md,\r\n    paddingVertical: spacing.sm,\r\n    backgroundColor: colors.surface.card,\r\n    borderRadius: radius.md,\r\n    borderWidth: 1,\r\n  },\r\n  nameInput: {\r\n    flex: 1,\r\n    ...typography.body,\r\n    fontWeight: typography.body.fontWeight as any,\r\n    color: colors.text.primary,\r\n    paddingVertical: spacing.xs,\r\n  },\r\n  errorText: {\r\n    marginTop: spacing.xs,\r\n  },\r\n  divider: {\r\n    height: 1,\r\n    backgroundColor: colors.border.light,\r\n    marginVertical: spacing.xs,\r\n  },\r\n  workoutPickerButton: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    gap: spacing.sm,\r\n    paddingVertical: spacing.md,\r\n    paddingHorizontal: spacing.lg,\r\n    backgroundColor: colors.accent.orangeMuted,\r\n    borderRadius: radius.md,\r\n    borderWidth: 1,\r\n    borderColor: colors.accent.orange,\r\n    borderStyle: 'dashed',\r\n  },\r\n  workoutPickerButtonPressed: {\r\n    opacity: 0.8,\r\n  },\r\n  pickerButtonText: {\r\n    flex: 1,\r\n    textAlign: 'center',\r\n  },\r\n  reorderHint: {\r\n    marginTop: spacing.xs,\r\n    textAlign: 'left',\r\n  },\r\n  workoutPickerList: {\r\n    gap: spacing.xs,\r\n    marginTop: spacing.xs,\r\n  },\r\n  workoutOption: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'space-between',\r\n    paddingVertical: spacing.md,\r\n    paddingHorizontal: spacing.md,\r\n    backgroundColor: colors.surface.card,\r\n    borderRadius: radius.md,\r\n    borderWidth: 1,\r\n    borderColor: colors.border.light,\r\n    minHeight: 56,\r\n  },\r\n  workoutOptionPressed: {\r\n    backgroundColor: colors.accent.orangeMuted,\r\n    borderColor: colors.accent.orange,\r\n  },\r\n  workoutOptionInfo: {\r\n    flex: 1,\r\n    gap: 2,\r\n  },\r\n  addButton: {\r\n    width: 28,\r\n    height: 28,\r\n    borderRadius: radius.full,\r\n    backgroundColor: colors.accent.orangeMuted,\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n  },\r\n  allAddedText: {\r\n    textAlign: 'center',\r\n    paddingVertical: spacing.md,\r\n  },\r\n  noWorkoutsContainer: {\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    paddingVertical: spacing.xl,\r\n    gap: spacing.sm,\r\n  },\r\n  noWorkoutsText: {\r\n    textAlign: 'center',\r\n  },\r\n  workoutCountBadge: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    gap: spacing.sm,\r\n  },\r\n  countBadge: {\r\n    backgroundColor: colors.accent.orange,\r\n    borderRadius: radius.full,\r\n    paddingHorizontal: spacing.sm,\r\n    paddingVertical: 2,\r\n    minWidth: 24,\r\n    alignItems: 'center',\r\n  },\r\n  countText: {\r\n    color: colors.text.onAccent,\r\n    fontWeight: '600',\r\n  },\r\n  workoutList: {\r\n    gap: spacing.xs,\r\n  },\r\n  emptyState: {\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    paddingVertical: spacing.xl,\r\n    gap: spacing.sm,\r\n  },\r\n  emptyStateText: {\r\n    textAlign: 'center',\r\n  },\r\n  progressContainer: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    gap: spacing.sm,\r\n    marginBottom: spacing.sm,\r\n  },\r\n  progressDot: {\r\n    width: 8,\r\n    height: 8,\r\n    borderRadius: radius.full,\r\n    backgroundColor: colors.text.muted,\r\n  },\r\n  progressDotReady: {\r\n    backgroundColor: colors.accent.success,\r\n  },\r\n  // Selected Workout Row styles (match CompactExerciseRow layout)\r\n  selectedWorkoutRow: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    paddingVertical: spacing.md,\r\n    paddingHorizontal: spacing.md,\r\n    backgroundColor: colors.surface.card,\r\n    borderRadius: radius.md,\r\n    borderWidth: 1,\r\n    borderColor: colors.border.light,\r\n    minHeight: 56,\r\n    gap: spacing.sm,\r\n  },\r\n  reorderArea: {\r\n    flexDirection: 'column',\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    width: 32,\r\n  },\r\n  reorderButton: {\r\n    padding: 2,\r\n  },\r\n  indexBadge: {\r\n    width: 32,\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n  },\r\n  textContainer: {\r\n    flex: 1,\r\n    gap: spacing.xs,\r\n    flexShrink: 1,\r\n  },\r\n  removeButton: {\r\n    width: 32,\r\n    height: 32,\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\PlanEmptyStateCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\PlanExerciseCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\PlanFormHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\PlanNameCard.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Text' is defined but never used.","line":10,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * PlanNameCard\r\n * Displays editable plan name within a surfaced card.\r\n */\r\nimport React from 'react';\r\nimport { StyleSheet, View } from 'react-native';\r\n\r\nimport { InputField } from '@/components/atoms/InputField';\r\nimport { SurfaceCard } from '@/components/atoms/SurfaceCard';\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { spacing } from '@/constants/theme';\r\n\r\ninterface PlanNameCardProps {\r\n  value: string;\r\n  onChange: (value: string) => void;\r\n  label?: string;\r\n  placeholder?: string;\r\n}\r\n\r\nexport const PlanNameCard: React.FC<PlanNameCardProps> = ({\r\n  value,\r\n  onChange,\r\n  label,\r\n  placeholder,\r\n}) => {\r\n  return (\r\n    <SurfaceCard tone=\"card\" padding=\"xl\" showAccentStripe>\r\n      <View style={styles.content}>\r\n        <InputField\r\n          label={label ?? 'Name'}\r\n          value={value}\r\n          onChangeText={onChange}\r\n          placeholder={placeholder ?? 'e.g. Push Day'}\r\n          returnKeyType=\"done\"\r\n          testID=\"plan-name-input\"\r\n        />\r\n      </View>\r\n    </SurfaceCard>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  content: {\r\n    gap: spacing.sm,\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\PlanQuickBuilderCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\PlanQuickBuilderSuggestionRow.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\PlanSelectedExerciseList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\PlanSetModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\PremiumLimitModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\ProgramCard.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'IconSymbol' is defined but never used.","line":7,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport { StyleSheet, View, Pressable, ViewStyle, TouchableOpacity } from 'react-native';\r\nimport { Ionicons } from '@expo/vector-icons';\r\nimport { SurfaceCard } from '@/components/atoms/SurfaceCard';\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { Badge } from '@/components/atoms';\r\nimport { IconSymbol } from '@/components/ui/icon-symbol';\r\nimport { colors, radius, spacing, shadows } from '@/constants/theme';\r\nimport type { PremadeProgram, UserProgram, PremadeWorkout } from '@/types/premadePlan';\r\n\r\ninterface ProgramCardProps {\r\n  program: PremadeProgram | UserProgram | PremadeWorkout;\r\n  onPress: (program: PremadeProgram | UserProgram | PremadeWorkout) => void;\r\n  style?: ViewStyle;\r\n  isLocked?: boolean;\r\n  onUnlock?: () => void;\r\n}\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    borderRadius: radius.lg,\r\n    overflow: 'hidden',\r\n  },\r\n  pressable: {\r\n    gap: spacing.md,\r\n  },\r\n  header: {\r\n    gap: spacing.xs,\r\n  },\r\n  tags: {\r\n    flexDirection: 'row',\r\n    flexWrap: 'wrap',\r\n    gap: spacing.xs,\r\n  },\r\n  footer: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'space-between',\r\n    paddingTop: spacing.sm,\r\n    borderTopWidth: StyleSheet.hairlineWidth,\r\n    borderTopColor: colors.border.light,\r\n  },\r\n  stat: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    gap: spacing.xs,\r\n  },\r\n  lockedCard: {\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    paddingVertical: spacing.xl,\r\n    paddingHorizontal: spacing.lg,\r\n    minHeight: 180,\r\n    gap: spacing.md,\r\n  },\r\n  lockBadge: {\r\n    width: 48,\r\n    height: 48,\r\n    borderRadius: radius.full,\r\n    backgroundColor: colors.surface.tint,\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n  },\r\n  lockedName: {\r\n    textAlign: 'center',\r\n  },\r\n  lockedDescription: {\r\n    textAlign: 'center',\r\n  },\r\n  ctaButton: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    backgroundColor: colors.accent.orange,\r\n    paddingVertical: spacing.sm,\r\n    paddingHorizontal: spacing.lg,\r\n    borderRadius: radius.full,\r\n    gap: spacing.xs,\r\n    ...shadows.sm,\r\n  },\r\n  ctaText: {\r\n    color: colors.text.onAccent,\r\n  },\r\n});\r\n\r\nexport const ProgramCard: React.FC<ProgramCardProps> = ({ program, onPress, style, isLocked = false, onUnlock }) => {\r\n  // Defensive checks for corrupted data\r\n  if (!program || typeof program !== 'object') {\r\n    return null;\r\n  }\r\n  \r\n  const name = program.name || 'Untitled';\r\n  const metadata = program.metadata || {};\r\n  const isWorkout = metadata && 'durationMinutes' in metadata;\r\n  // Workouts don't have a 'workouts' array of their own, they contain exercises directly\r\n  const workoutsArray = 'workouts' in program && Array.isArray(program.workouts) ? program.workouts : [];\r\n  const exercisesArray = 'exercises' in program && Array.isArray(program.exercises) ? program.exercises : [];\r\n  const itemCount = workoutsArray.length > 0 ? workoutsArray.length : exercisesArray.length;\r\n  const itemLabel = workoutsArray.length > 0 ? 'workouts' : 'exercises';\r\n\r\n  // Show locked card for premium content\r\n  if (isLocked) {\r\n    return (\r\n      <SurfaceCard tone=\"neutral\" padding=\"lg\" style={[styles.container, style]} showAccentStripe={true}>\r\n        <View style={styles.lockedCard}>\r\n          <View style={styles.lockBadge}>\r\n            <Ionicons name=\"lock-closed\" size={20} color={colors.accent.orange} />\r\n          </View>\r\n\r\n          <Text variant=\"bodySemibold\" color=\"primary\" style={styles.lockedName}>\r\n            {name}\r\n          </Text>\r\n\r\n          <Text variant=\"caption\" color=\"secondary\" style={styles.lockedDescription}>\r\n            Unlock this {isWorkout ? 'workout' : 'program'} with Hercules Pro\r\n          </Text>\r\n\r\n          <TouchableOpacity\r\n            style={styles.ctaButton}\r\n            onPress={onUnlock}\r\n            activeOpacity={0.8}\r\n          >\r\n            <Ionicons name=\"star\" size={16} color={colors.text.onAccent} />\r\n            <Text variant=\"labelMedium\" style={styles.ctaText}>\r\n              Unlock Premium\r\n            </Text>\r\n          </TouchableOpacity>\r\n        </View>\r\n      </SurfaceCard>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <SurfaceCard tone=\"neutral\" padding=\"lg\" style={[styles.container, style]} showAccentStripe={true}>\r\n      <Pressable\r\n        onPress={() => onPress(program)}\r\n        style={({ pressed }) => [styles.pressable, { opacity: pressed ? 0.7 : 1 }]}\r\n      >\r\n        <View style={styles.header}>\r\n          <Text variant=\"bodySemibold\" color=\"primary\">{name}</Text>\r\n          <Text variant=\"caption\" color=\"secondary\" numberOfLines={2}>{metadata.description}</Text>\r\n        </View>\r\n\r\n        <View style={styles.tags}>\r\n          {metadata.goal && <Badge label={String(metadata.goal).replace('-', ' ')} variant=\"workout\" size=\"sm\" />}\r\n          {metadata.experienceLevel && <Badge label={String(metadata.experienceLevel)} variant=\"workout\" size=\"sm\" />}\r\n          {metadata.equipment && <Badge label={String(metadata.equipment).replace('-', ' ')} variant=\"workout\" size=\"sm\" />}\r\n        </View>\r\n\r\n        <View style={styles.footer}>\r\n          <Text variant=\"caption\" color=\"secondary\">\r\n            {itemCount} {itemLabel}  {isWorkout\r\n              ? `${(metadata as any).durationMinutes || 0} min`\r\n              : `${(metadata as any).daysPerWeek || 0} days/week`\r\n            }\r\n          </Text>\r\n        </View>\r\n      </Pressable>\r\n    </SurfaceCard>\r\n  );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\ProgramCarousel.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Layout' is defined but never used.","line":3,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":43},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'router' is assigned a value but never used.","line":41,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":41,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useRef, useCallback } from 'react';\r\nimport { View, StyleSheet, ScrollView, Pressable, Dimensions } from 'react-native';\r\nimport Animated, { FadeIn, FadeOut, Layout } from 'react-native-reanimated';\r\nimport { useRouter } from 'expo-router';\r\nimport { useFocusEffect } from '@react-navigation/native';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { IconSymbol } from '@/components/ui/icon-symbol';\r\nimport { colors, radius, spacing, shadows, sizing } from '@/constants/theme';\r\n\r\ninterface Program {\r\n  id: string;\r\n  name: string;\r\n  workouts: any[];\r\n}\r\n\r\ninterface ProgramCarouselProps {\r\n  programs: Program[];\r\n  onProgramPress: (program: Program) => void;\r\n  onAddProgramPress: () => void;\r\n  selectedProgramId?: string | null;\r\n  onEditProgram?: (program: Program) => void;\r\n  onDeleteProgram?: (program: Program) => void;\r\n  onCloseExpanded?: () => void;\r\n}\r\n\r\nconst SCREEN_WIDTH = Dimensions.get('window').width;\r\nconst CARD_WIDTH = SCREEN_WIDTH * 0.65;\r\nconst CARD_SPACING = spacing.md;\r\nconst LEFT_MARGIN = spacing.lg + spacing.xs;\r\n\r\nexport const ProgramCarousel: React.FC<ProgramCarouselProps> = ({\r\n  programs,\r\n  onProgramPress,\r\n  onAddProgramPress,\r\n  selectedProgramId,\r\n  onEditProgram,\r\n  onDeleteProgram,\r\n  onCloseExpanded,\r\n}) => {\r\n  const router = useRouter();\r\n  const scrollViewRef = useRef<ScrollView>(null);\r\n\r\n  // Reset scroll position when parent screen gains focus\r\n  useFocusEffect(\r\n    useCallback(() => {\r\n      scrollViewRef.current?.scrollTo({ x: 0, animated: false });\r\n    }, [])\r\n  );\r\n\r\n  const getProgramSummary = (program: Program) => {\r\n    const workoutCount = program.workouts.filter(w => w.exercises && w.exercises.length > 0).length;\r\n    return `${workoutCount} ${workoutCount === 1 ? 'workout' : 'workouts'}`;\r\n  };\r\n\r\n  return (\r\n    <View style={styles.container}>\r\n      <ScrollView\r\n        ref={scrollViewRef}\r\n        horizontal\r\n        pagingEnabled={false}\r\n        showsHorizontalScrollIndicator={false}\r\n        decelerationRate=\"normal\"\r\n        contentContainerStyle={styles.scrollContent}\r\n      >\r\n        {programs.map((program) => {\r\n          const isSelected = selectedProgramId === program.id;\r\n          return (\r\n            <Animated.View\r\n              key={program.id}\r\n              style={styles.card}\r\n            >\r\n              <Pressable\r\n                style={{ flex: 1 }}\r\n                onPress={() => {\r\n                  triggerHaptic('selection');\r\n                  onProgramPress(program);\r\n                }}\r\n              >\r\n                <View style={styles.cardBackground}>\r\n                  {!isSelected ? (\r\n                    <Animated.View\r\n                      key=\"normal\"\r\n                      entering={FadeIn.duration(250)}\r\n                      exiting={FadeOut.duration(150)}\r\n                      style={styles.cardInner}\r\n                    >\r\n                      <View style={styles.cardContent}>\r\n                        <Text variant=\"heading3\" color=\"primary\" numberOfLines={2}>\r\n                          {program.name}\r\n                        </Text>\r\n                        <Text variant=\"body\" color=\"secondary\" style={styles.exerciseCount}>\r\n                          {getProgramSummary(program)}\r\n                        </Text>\r\n                      </View>\r\n                      <IconSymbol name=\"chevron-right\" size={sizing.iconMD} color={colors.text.primary} />\r\n                    </Animated.View>\r\n                  ) : (\r\n                    <Animated.View\r\n                      key=\"expanded\"\r\n                      entering={FadeIn.duration(250)}\r\n                      exiting={FadeOut.duration(150)}\r\n                      style={styles.expandedContent}\r\n                    >\r\n                      <Text variant=\"heading4\" color=\"primary\" numberOfLines={1} style={{ marginBottom: spacing.sm }}>\r\n                        {program.name}\r\n                      </Text>\r\n                      <View style={styles.actionButtons}>\r\n                        {onEditProgram && (\r\n                          <Pressable\r\n                            style={styles.actionButton}\r\n                            onPress={(e) => {\r\n                              e.stopPropagation();\r\n                              triggerHaptic('selection');\r\n                              onEditProgram(program);\r\n                            }}\r\n                          >\r\n                            <IconSymbol name=\"edit\" size={sizing.iconMD} color={colors.text.primary} />\r\n                            <Text variant=\"caption\" color=\"primary\">Edit</Text>\r\n                          </Pressable>\r\n                        )}\r\n                        {onDeleteProgram && (\r\n                          <Pressable\r\n                            style={styles.actionButton}\r\n                            onPress={(e) => {\r\n                              e.stopPropagation();\r\n                              triggerHaptic('selection');\r\n                              onDeleteProgram(program);\r\n                            }}\r\n                          >\r\n                            <IconSymbol name=\"delete\" size={sizing.iconMD} color={colors.text.primary} />\r\n                            <Text variant=\"caption\" color=\"primary\">Delete</Text>\r\n                          </Pressable>\r\n                        )}\r\n                        {onCloseExpanded && (\r\n                          <Pressable\r\n                            style={styles.actionButton}\r\n                            onPress={(e) => {\r\n                              e.stopPropagation();\r\n                              triggerHaptic('selection');\r\n                              onCloseExpanded();\r\n                            }}\r\n                          >\r\n                            <IconSymbol name=\"close\" size={sizing.iconMD} color={colors.text.primary} />\r\n                            <Text variant=\"caption\" color=\"primary\">Close</Text>\r\n                          </Pressable>\r\n                        )}\r\n                      </View>\r\n                    </Animated.View>\r\n                  )}\r\n                </View>\r\n              </Pressable>\r\n            </Animated.View>\r\n          );\r\n        })}\r\n\r\n        {/* Add Program Card */}\r\n        <Pressable\r\n          style={[styles.card, styles.addCard]}\r\n          onPress={() => {\r\n            triggerHaptic('selection');\r\n            onAddProgramPress();\r\n          }}\r\n        >\r\n          <View style={styles.addCardInner}>\r\n            <View style={styles.addIconWrapper}>\r\n              <IconSymbol name=\"add\" size={sizing.iconLG} color={colors.accent.orange} />\r\n            </View>\r\n            <Text variant=\"body\" color=\"primary\" style={styles.addText}>\r\n              Add Plan\r\n            </Text>\r\n          </View>\r\n        </Pressable>\r\n      </ScrollView>\r\n    </View>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    width: '100%',\r\n    gap: spacing.md,\r\n  },\r\n  scrollContent: {\r\n    paddingLeft: LEFT_MARGIN,\r\n    paddingRight: LEFT_MARGIN + spacing.xs,\r\n    gap: CARD_SPACING,\r\n  },\r\n  card: {\r\n    width: CARD_WIDTH,\r\n    height: 140,\r\n    borderRadius: radius.lg,\r\n    overflow: 'hidden',\r\n  },\r\n  cardBackground: {\r\n    flex: 1,\r\n    backgroundColor: colors.surface.elevated,\r\n    borderRadius: radius.lg,\r\n    borderWidth: 1,\r\n    borderColor: colors.border.light,\r\n    ...shadows.sm,\r\n  },\r\n  cardInner: {\r\n    flex: 1,\r\n    padding: spacing.lg,\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'space-between',\r\n  },\r\n  cardContent: {\r\n    flex: 1,\r\n    gap: spacing.sm,\r\n    justifyContent: 'center',\r\n  },\r\n  exerciseCount: {\r\n  },\r\n  addCard: {\r\n    backgroundColor: colors.surface.card,\r\n    borderWidth: 2,\r\n    borderColor: colors.accent.orange,\r\n    borderStyle: 'dashed',\r\n  },\r\n  addCardInner: {\r\n    flex: 1,\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    gap: spacing.sm,\r\n  },\r\n  addIconWrapper: {\r\n    width: 44,\r\n    height: 44,\r\n    borderRadius: radius.full,\r\n    backgroundColor: colors.primary.bg,\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    borderWidth: 2,\r\n    borderColor: colors.accent.orange,\r\n  },\r\n  addText: {\r\n    textAlign: 'center',\r\n  },\r\n  expandedContent: {\r\n    flex: 1,\r\n    padding: spacing.lg,\r\n    justifyContent: 'space-between',\r\n  },\r\n  actionButtons: {\r\n    flexDirection: 'row',\r\n    justifyContent: 'space-around',\r\n    gap: spacing.sm,\r\n  },\r\n  actionButton: {\r\n    alignItems: 'center',\r\n    gap: spacing.xs,\r\n    padding: spacing.sm,\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\ProgramSubcardList.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useCallback' is defined but never used.","line":1,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":28}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useCallback } from 'react';\r\nimport { View, StyleSheet, Pressable } from 'react-native';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { Button } from '@/components/atoms/Button';\r\nimport { SurfaceCard } from '@/components/atoms/SurfaceCard';\r\nimport { IconSymbol } from '@/components/ui/icon-symbol';\r\nimport { colors, radius, spacing, shadows, sizing } from '@/constants/theme';\r\n\r\ninterface Program {\r\n  id: string;\r\n  name: string;\r\n  workouts: any[];\r\n}\r\n\r\ninterface ProgramSubcardListProps {\r\n  programs: Program[];\r\n  onProgramPress: (program: Program) => void;\r\n  onAddProgramPress: () => void;\r\n  onCreatePlanPress: () => void;\r\n  selectedProgramId?: string | null;\r\n  onEditProgram?: (program: Program) => void;\r\n  onDeleteProgram?: (program: Program) => void;\r\n  onCloseExpanded?: () => void;\r\n  showAll?: boolean;\r\n  onToggleShowAll?: () => void;\r\n  maxVisible?: number;\r\n}\r\n\r\nexport const ProgramSubcardList: React.FC<ProgramSubcardListProps> = ({\r\n  programs,\r\n  onProgramPress,\r\n  onAddProgramPress,\r\n  onCreatePlanPress,\r\n  selectedProgramId,\r\n  onEditProgram,\r\n  onDeleteProgram,\r\n  onCloseExpanded,\r\n  showAll = false,\r\n  onToggleShowAll,\r\n  maxVisible = 3,\r\n}) => {\r\n  const getProgramSummary = (program: Program) => {\r\n    const workoutCount = program.workouts.filter(w => w.exercises && w.exercises.length > 0).length;\r\n    return `${workoutCount} ${workoutCount === 1 ? 'workout' : 'workouts'}`;\r\n  };\r\n\r\n  const visiblePrograms = showAll ? programs : programs.slice(0, maxVisible);\r\n  const hasMoreItems = programs.length > maxVisible;\r\n\r\n  return (\r\n    <View style={styles.container}>\r\n      {/* Card Header with Expand/Collapse Button */}\r\n      <View style={styles.cardHeader}>\r\n        <View style={styles.headerLeft}>\r\n          <Text variant=\"heading3\" color=\"primary\">\r\n            My Plans\r\n          </Text>\r\n        </View>\r\n        {hasMoreItems && onToggleShowAll && (\r\n          <Pressable\r\n            style={styles.expandCollapseButton}\r\n            onPress={() => {\r\n              triggerHaptic('selection');\r\n              onToggleShowAll();\r\n            }}\r\n          >\r\n            <Text variant=\"caption\" color=\"primary\" style={styles.expandCollapseText}>\r\n              {showAll ? 'Collapse' : 'Expand'}\r\n            </Text>\r\n          </Pressable>\r\n        )}\r\n      </View>\r\n\r\n      <View style={styles.recentWorkoutsList}>\r\n        {programs.length === 0 ? (\r\n          <SurfaceCard\r\n            tone=\"neutral\"\r\n            padding=\"md\"\r\n            showAccentStripe={false}\r\n            style={styles.emptyCard}\r\n          >\r\n            <View style={styles.emptyContent}>\r\n              <Text variant=\"bodySemibold\" color=\"primary\" style={styles.emptyTitle}>\r\n                No plans yet\r\n              </Text>\r\n              <Text variant=\"body\" color=\"secondary\" style={styles.emptySubtext}>\r\n                Add a plan to see it here.\r\n              </Text>\r\n            </View>\r\n          </SurfaceCard>\r\n        ) : (\r\n          visiblePrograms.map((program) => {\r\n            const isSelected = selectedProgramId === program.id;\r\n            return (\r\n              <Pressable\r\n                key={program.id}\r\n                style={styles.pressableStretch}\r\n                onPress={() => {\r\n                  triggerHaptic('selection');\r\n                  onProgramPress(program);\r\n                }}\r\n              >\r\n                <SurfaceCard\r\n                  tone=\"neutral\"\r\n                  padding=\"md\"\r\n                  showAccentStripe={false}\r\n                  style={[styles.inlineCard, isSelected && styles.expandedCard]}\r\n                >\r\n                  {!isSelected ? (\r\n                    <>\r\n                      <View style={styles.recentCardHeader}>\r\n                        <Text variant=\"bodySemibold\" color=\"primary\">\r\n                          {program.name}\r\n                        </Text>\r\n                      </View>\r\n                      <Text variant=\"body\" color=\"secondary\">\r\n                        {getProgramSummary(program)}\r\n                      </Text>\r\n                    </>\r\n                  ) : (\r\n                    <View style={styles.expandedActionsContainer}>\r\n                      {onEditProgram && (\r\n                        <Pressable\r\n                          style={styles.largeActionButton}\r\n                          onPress={(e) => {\r\n                            e.stopPropagation();\r\n                            triggerHaptic('selection');\r\n                            onEditProgram(program);\r\n                          }}\r\n                        >\r\n                          <View style={styles.iconCircle}>\r\n                            <IconSymbol name=\"edit\" size={sizing.iconMD} color={colors.accent.orange} />\r\n                          </View>\r\n                          <Text variant=\"caption\" color=\"primary\">Edit</Text>\r\n                        </Pressable>\r\n                      )}\r\n                      {onDeleteProgram && (\r\n                        <Pressable\r\n                          style={styles.largeActionButton}\r\n                          onPress={(e) => {\r\n                            e.stopPropagation();\r\n                            triggerHaptic('selection');\r\n                            onDeleteProgram(program);\r\n                          }}\r\n                        >\r\n                          <View style={styles.iconCircle}>\r\n                            <IconSymbol name=\"delete\" size={sizing.iconMD} color={colors.accent.orange} />\r\n                          </View>\r\n                          <Text variant=\"caption\" color=\"primary\">Delete</Text>\r\n                        </Pressable>\r\n                      )}\r\n                      {onCloseExpanded && (\r\n                        <Pressable\r\n                          style={styles.largeActionButton}\r\n                          onPress={(e) => {\r\n                            e.stopPropagation();\r\n                            triggerHaptic('selection');\r\n                            onCloseExpanded();\r\n                          }}\r\n                        >\r\n                          <View style={styles.iconCircle}>\r\n                            <IconSymbol name=\"close\" size={sizing.iconMD} color={colors.accent.orange} />\r\n                          </View>\r\n                          <Text variant=\"caption\" color=\"primary\">Close</Text>\r\n                        </Pressable>\r\n                      )}\r\n                    </View>\r\n                  )}\r\n                </SurfaceCard>\r\n              </Pressable>\r\n            );\r\n          })\r\n        )}\r\n\r\n        {/* Show More/Less Button - REMOVED */}\r\n      </View>\r\n\r\n      {/* Buttons Row */}\r\n      <View style={styles.buttonsContainer}>\r\n        {/* Add Plan Button */}\r\n        <Button\r\n          label=\"Add Plan\"\r\n          variant=\"primary\"\r\n          size=\"md\"\r\n          style={styles.wideButton}\r\n          onPress={() => {\r\n            triggerHaptic('selection');\r\n            onAddProgramPress();\r\n          }}\r\n        />\r\n\r\n        {/* Create Plan Button */}\r\n        <Button\r\n          label=\"Create Plan\"\r\n          variant=\"secondary\"\r\n          size=\"md\"\r\n          textColor={colors.accent.orange}\r\n          style={[styles.wideButton, { ...shadows.sm }]}\r\n          onPress={() => {\r\n            triggerHaptic('selection');\r\n            onCreatePlanPress();\r\n          }}\r\n        />\r\n      </View>\r\n    </View>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    width: '100%',\r\n    gap: spacing.md,\r\n  },\r\n  recentWorkoutsList: {\r\n    gap: spacing.md,\r\n  },\r\n  recentCardHeader: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'space-between',\r\n    marginBottom: spacing.sm,\r\n  },\r\n  inlineCard: {\r\n    borderWidth: StyleSheet.hairlineWidth,\r\n    borderColor: colors.border.light,\r\n    borderRadius: radius.lg,\r\n    backgroundColor: colors.surface.card,\r\n    shadowColor: 'transparent',\r\n    shadowOpacity: 0,\r\n    shadowRadius: 0,\r\n    shadowOffset: { width: 0, height: 0 },\r\n    elevation: 0,\r\n    paddingLeft: spacing.lg,\r\n  },\r\n  expandedCard: {\r\n    paddingLeft: 0,\r\n    paddingHorizontal: spacing.lg,\r\n  },\r\n  pressableStretch: {\r\n    width: '100%',\r\n  },\r\n  expandedActions: {\r\n    flexDirection: 'row',\r\n    gap: spacing.sm,\r\n    marginTop: spacing.sm,\r\n  },\r\n  expandedActionsContainer: {\r\n    flexDirection: 'row',\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n    paddingVertical: spacing.xs,\r\n    gap: spacing.md,\r\n    paddingLeft: spacing.lg,\r\n  },\r\n  largeActionButton: {\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    gap: spacing.xs,\r\n    paddingVertical: spacing.sm,\r\n    paddingHorizontal: spacing.sm,\r\n    borderRadius: radius.sm,\r\n    minWidth: 60,\r\n    flex: 1,\r\n  },\r\n  iconCircle: {\r\n    width: 48,\r\n    height: 48,\r\n    borderRadius: radius.full,\r\n    backgroundColor: colors.surface.card,\r\n    borderWidth: 1,\r\n    borderColor: colors.accent.orange,\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n  },\r\n  actionButton: {\r\n    alignItems: 'center',\r\n    gap: spacing.xs,\r\n    padding: spacing.xs,\r\n    borderRadius: radius.sm,\r\n  },\r\n  emptyCard: {\r\n    borderWidth: StyleSheet.hairlineWidth,\r\n    borderColor: colors.border.light,\r\n    borderRadius: radius.lg,\r\n    backgroundColor: colors.surface.card,\r\n    shadowColor: 'transparent',\r\n    shadowOpacity: 0,\r\n    shadowRadius: 0,\r\n    shadowOffset: { width: 0, height: 0 },\r\n    elevation: 0,\r\n    paddingLeft: spacing.lg,\r\n  },\r\n  emptyContent: {\r\n    alignItems: 'flex-start',\r\n    justifyContent: 'center',\r\n    paddingVertical: spacing.sm,\r\n  },\r\n  emptyTitle: {\r\n    marginBottom: spacing.xs,\r\n  },\r\n  emptySubtext: {\r\n    textAlign: 'left',\r\n  },\r\n  buttonsContainer: {\r\n    gap: spacing.sm,\r\n  },\r\n  wideButton: {\r\n    alignSelf: 'center',\r\n    width: '100%',\r\n  },\r\n  cardHeader: {\r\n    flexDirection: 'row',\r\n    justifyContent: 'space-between',\r\n    alignItems: 'center',\r\n    marginBottom: spacing.md,\r\n  },\r\n  headerLeft: {\r\n    flex: 1,\r\n  },\r\n  expandCollapseButton: {\r\n    paddingHorizontal: spacing.sm,\r\n    paddingVertical: spacing.xs,\r\n  },\r\n  expandCollapseText: {\r\n    fontWeight: '400',\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\RotationScheduleEditor.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\ScheduleTypeSelector.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\ScreenHeader.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'shadows' is defined but never used.","line":13,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":34}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * ScreenHeader\n * Molecule providing a consistent layout for screen titles and subtitles.\n */\n\nimport React from 'react';\nimport { StyleSheet, View, Pressable } from 'react-native';\nimport Animated, { useSharedValue, withSpring, useAnimatedStyle } from 'react-native-reanimated';\nimport { triggerHaptic } from '@/utils/haptics';\n\nimport { Text } from '@/components/atoms/Text';\nimport { IconSymbol } from '@/components/ui/icon-symbol';\nimport { spacing, radius, shadows } from '@/constants/theme';\nimport { useTheme } from '@/hooks/useTheme';\n\ninterface ScreenHeaderProps {\n  /** Primary screen heading */\n  title: string;\n  /** Optional supporting copy rendered beneath the title */\n  subtitle?: string;\n  /** Optional profile icon press handler */\n  onProfilePress?: () => void;\n  /** Optional user initial to display in profile button (shows orange circle with letter) */\n  userInitial?: string | null;\n}\n\nexport const ScreenHeader: React.FC<ScreenHeaderProps> = ({ title, subtitle, onProfilePress, userInitial }) => {\n  const { theme } = useTheme();\n  const scale = useSharedValue(1);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  const handleProfilePress = () => {\n    scale.value = withSpring(0.9, { damping: 15, stiffness: 300 });\n    triggerHaptic('selection');\n    setTimeout(() => {\n      scale.value = withSpring(1, { damping: 15, stiffness: 300 });\n      onProfilePress?.();\n    }, 100);\n  };\n\n  return (\n    <View style={styles.container}>\n      <View style={styles.headerContent}>\n        <View style={styles.textContainer}>\n          <Text variant=\"heading1\" color=\"primary\">\n            {title}\n          </Text>\n          {subtitle ? (\n            <Text variant=\"body\" color=\"secondary\">\n              {subtitle}\n            </Text>\n          ) : null}\n        </View>\n        {onProfilePress && (\n          <Animated.View style={animatedStyle}>\n            <Pressable\n              style={[\n                userInitial ? styles.profileButtonWithInitial : styles.profileButton,\n                {\n                  backgroundColor: userInitial ? theme.accent.orange : theme.surface.card,\n                  borderColor: theme.accent.orange,\n                  borderWidth: userInitial ? 0 : 1\n                }\n              ]}\n              onPress={handleProfilePress}\n              accessibilityRole=\"button\"\n              accessibilityLabel=\"Profile\"\n            >\n              {userInitial ? (\n                <Text variant=\"bodySemibold\" style={[styles.initialText, { color: theme.text.onAccent }]}>\n                  {userInitial}\n                </Text>\n              ) : (\n                <IconSymbol\n                  name=\"person\"\n                  color={theme.accent.orange}\n                  size={24}\n                />\n              )}\n            </Pressable>\n          </Animated.View>\n        )}\n      </View>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    gap: spacing.xs,\n  },\n  headerContent: {\n    flexDirection: 'row',\n    alignItems: 'flex-start',\n    justifyContent: 'space-between',\n    paddingBottom: spacing.sm,\n  },\n  textContainer: {\n    flex: 1,\n    gap: spacing.xs,\n  },\n  titleWrapper: {\n    gap: spacing.xxs,\n    paddingBottom: spacing.xs,\n  },\n  profileButton: {\n    width: 40,\n    height: 40,\n    borderRadius: radius.full,\n    justifyContent: 'center',\n    alignItems: 'center',\n    borderWidth: 1,\n  },\n  profileButtonWithInitial: {\n    width: 40,\n    height: 40,\n    borderRadius: radius.full,\n    justifyContent: 'center',\n    alignItems: 'center',\n    borderWidth: 1,\n  },\n  initialText: {\n    fontSize: 18,\n    fontWeight: '600',\n  },\n});\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\SheetModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'zIndex' is defined but never used.","line":15,"column":44,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":50},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'insets' is assigned a value but never used.","line":39,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":39,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\r\nimport { View, StyleSheet, Pressable, Dimensions, Modal } from 'react-native';\r\nimport Animated, {\r\n    runOnJS,\r\n    useAnimatedStyle,\r\n    useSharedValue,\r\n    withSpring,\r\n    withTiming,\r\n    interpolate,\r\n    Extrapolation,\r\n} from 'react-native-reanimated';\r\nimport { Gesture, GestureDetector, GestureHandlerRootView } from 'react-native-gesture-handler';\r\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { colors, radius, shadows, spacing, zIndex } from '@/constants/theme';\r\nimport { springGentle } from '@/constants/animations';\r\n\r\nconst SCREEN_HEIGHT = Dimensions.get('window').height;\r\nconst SHEET_DISMISS_THRESHOLD = spacing['2xl'] * 2;\r\nconst AnimatedPressable = Animated.createAnimatedComponent(Pressable);\r\n\r\nexport interface SheetModalProps {\r\n    visible: boolean;\r\n    onClose: () => void;\r\n    title?: string;\r\n    headerContent?: React.ReactNode;\r\n    children: React.ReactNode;\r\n    height?: string | number;\r\n}\r\n\r\nexport const SheetModal: React.FC<SheetModalProps> = ({\r\n    visible,\r\n    onClose,\r\n    title,\r\n    headerContent,\r\n    children,\r\n    height = '80%',\r\n}) => {\r\n    const insets = useSafeAreaInsets();\r\n    const sheetTranslateY = useSharedValue(SCREEN_HEIGHT);\r\n    const [isModalVisible, setIsModalVisible] = useState(visible);\r\n\r\n    React.useEffect(() => {\r\n        if (visible) {\r\n            setIsModalVisible(true);\r\n            // Small delay to ensure modal is rendered before animating\r\n            requestAnimationFrame(() => {\r\n                sheetTranslateY.value = withSpring(0, springGentle);\r\n            });\r\n        } else {\r\n            // Animate out when visibility changes to false\r\n            sheetTranslateY.value = withTiming(SCREEN_HEIGHT, { duration: 300 }, (finished) => {\r\n                if (finished) {\r\n                    runOnJS(setIsModalVisible)(false);\r\n                }\r\n            });\r\n        }\r\n    }, [visible, sheetTranslateY]);\r\n\r\n    const sheetAnimatedStyle = useAnimatedStyle(() => ({\r\n        transform: [{ translateY: sheetTranslateY.value }],\r\n    }));\r\n\r\n    const sheetGesture = Gesture.Pan()\r\n        .activeOffsetY(10)\r\n        .failOffsetY(-10)\r\n        .shouldCancelWhenOutside(false)\r\n        .onUpdate((event) => {\r\n            if (event.translationY < 0) {\r\n                return;\r\n            }\r\n            sheetTranslateY.value = event.translationY;\r\n        })\r\n        .onEnd((event) => {\r\n            if (sheetTranslateY.value > SHEET_DISMISS_THRESHOLD) {\r\n                sheetTranslateY.value = withTiming(SCREEN_HEIGHT, { duration: 300 }, () => {\r\n                    runOnJS(onClose)();\r\n                });\r\n            } else {\r\n                sheetTranslateY.value = withSpring(0, springGentle);\r\n            }\r\n        });\r\n\r\n    // Handle backdrop press with animation\r\n    const handleBackdropPress = () => {\r\n        // Just trigger close, the parent will update 'visible' -> false, which triggers the useEffect animation\r\n        onClose();\r\n    };\r\n\r\n    const backdropStyle = useAnimatedStyle(() => {\r\n        const opacity = interpolate(\r\n            sheetTranslateY.value,\r\n            [0, SCREEN_HEIGHT],\r\n            [1, 0],\r\n            Extrapolation.CLAMP\r\n        );\r\n\r\n        return {\r\n            opacity,\r\n        };\r\n    });\r\n\r\n    return (\r\n        <Modal\r\n            transparent\r\n            visible={isModalVisible}\r\n            animationType=\"none\"\r\n            onRequestClose={onClose}\r\n            statusBarTranslucent\r\n        >\r\n            <GestureHandlerRootView style={{ flex: 1 }}>\r\n                <View style={styles.overlay}>\r\n                    <AnimatedPressable\r\n                        style={[styles.backdrop, backdropStyle]}\r\n                        onPress={handleBackdropPress}\r\n                    />\r\n\r\n                    <Animated.View\r\n                        style={[\r\n                            styles.sheet,\r\n                            { height: height as any },\r\n                            sheetAnimatedStyle,\r\n                        ]}\r\n                    >\r\n                        <GestureDetector gesture={sheetGesture}>\r\n                            <View>\r\n                                <View style={styles.handleContainer}>\r\n                                    <View style={styles.handle} />\r\n                                </View>\r\n\r\n                                {(title || headerContent) && (\r\n                                    <View style={styles.header}>\r\n                                        {title && <Text variant=\"heading2\">{title}</Text>}\r\n                                        {headerContent}\r\n                                    </View>\r\n                                )}\r\n                            </View>\r\n                        </GestureDetector>\r\n\r\n                        <View style={styles.content}>\r\n                            {children}\r\n                        </View>\r\n                    </Animated.View>\r\n                </View >\r\n            </GestureHandlerRootView >\r\n        </Modal >\r\n    );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n    overlay: {\r\n        flex: 1,\r\n        justifyContent: 'flex-end',\r\n        backgroundColor: colors.overlay.scrim,\r\n    },\r\n    backdrop: {\r\n        ...StyleSheet.absoluteFillObject,\r\n        backgroundColor: colors.overlay.scrim,\r\n    },\r\n    sheet: {\r\n        backgroundColor: colors.surface.card,\r\n        borderTopLeftRadius: radius.lg,\r\n        borderTopRightRadius: radius.lg,\r\n        width: '100%',\r\n        overflow: 'hidden',\r\n        borderWidth: 1,\r\n        borderColor: colors.neutral.gray200,\r\n        ...shadows.lg,\r\n    },\r\n    handleContainer: {\r\n        alignItems: 'center',\r\n        paddingVertical: spacing.sm,\r\n    },\r\n    handle: {\r\n        width: 40,\r\n        height: 4,\r\n        borderRadius: 2,\r\n        backgroundColor: colors.border.light,\r\n    },\r\n    header: {\r\n        paddingHorizontal: spacing.lg,\r\n        paddingBottom: spacing.md,\r\n        borderBottomWidth: 1,\r\n        borderBottomColor: colors.border.light,\r\n        gap: spacing.md,\r\n    },\r\n    content: {\r\n        flex: 1,\r\n        overflow: 'visible',\r\n    },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\SignOutConfirmationModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Pressable' is defined but never used.","line":7,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":44},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'BlurView' is defined but never used.","line":8,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * SignOutConfirmationModal\r\n * A themed confirmation dialog for sign out with rounded corners and orange accent\r\n */\r\n\r\nimport React from 'react';\r\nimport { Modal, StyleSheet, View, Pressable } from 'react-native';\r\nimport { BlurView } from 'expo-blur';\r\nimport Animated, { useSharedValue, withSpring } from 'react-native-reanimated';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { Button } from '@/components/atoms/Button';\r\nimport { IconSymbol } from '@/components/ui/icon-symbol';\r\nimport { useTheme } from '@/hooks/useTheme';\r\nimport { spacing, radius } from '@/constants/theme';\r\n\r\ninterface SignOutConfirmationModalProps {\r\n  visible: boolean;\r\n  onClose: () => void;\r\n  onConfirm: () => void;\r\n  isLoading?: boolean;\r\n}\r\n\r\nexport const SignOutConfirmationModal: React.FC<SignOutConfirmationModalProps> = ({\r\n  visible,\r\n  onClose,\r\n  onConfirm,\r\n  isLoading = false,\r\n}) => {\r\n  const { theme } = useTheme();\r\n  const scale = useSharedValue(1);\r\n\r\n  const handleCancelPress = () => {\r\n    triggerHaptic('selection');\r\n    scale.value = withSpring(0.95, { damping: 15, stiffness: 300 });\r\n    setTimeout(() => {\r\n      scale.value = withSpring(1);\r\n      onClose();\r\n    }, 100);\r\n  };\r\n\r\n  const handleSignOutPress = () => {\r\n    triggerHaptic('warning');\r\n    onConfirm();\r\n  };\r\n\r\n  return (\r\n    <Modal\r\n      visible={visible}\r\n      transparent\r\n      animationType=\"fade\"\r\n      onRequestClose={onClose}\r\n    >\r\n      <View style={[styles.container, { backgroundColor: theme.overlay.scrim }]}>\r\n        <Animated.View style={[\r\n          styles.card,\r\n          {\r\n            backgroundColor: theme.surface.card,\r\n            borderColor: theme.accent.orange,\r\n          },\r\n          { transform: [{ scale: scale.value }] }\r\n        ]}>\r\n          <View style={[\r\n            styles.iconContainer,\r\n            { \r\n              backgroundColor: theme.surface.tint,\r\n              borderColor: theme.accent.orange,\r\n            }\r\n          ]}>\r\n            <IconSymbol\r\n              name=\"logout\"\r\n              color={theme.accent.orange}\r\n              size={32}\r\n            />\r\n          </View>\r\n          \r\n          <Text variant=\"heading3\" color=\"primary\" style={styles.title}>\r\n            Sign Out\r\n          </Text>\r\n          \r\n          <Text variant=\"body\" color=\"secondary\" style={styles.message}>\r\n            Are you sure you want to sign out? You&apos;ll need to sign in again to access your account.\r\n          </Text>\r\n\r\n          <View style={styles.buttonStack}>\r\n            <Button\r\n              label=\"Cancel\"\r\n              onPress={handleCancelPress}\r\n              variant=\"ghost\"\r\n              contentStyle={[\r\n                styles.cancelButton,\r\n                {\r\n                  backgroundColor: theme.surface.card,\r\n                  borderColor: theme.accent.orange,\r\n                }\r\n              ]}\r\n              textColor={theme.accent.orange}\r\n              disabled={isLoading}\r\n            />\r\n            <Button\r\n              label=\"Sign Out\"\r\n              onPress={handleSignOutPress}\r\n              loading={isLoading}\r\n              disabled={isLoading}\r\n              contentStyle={[\r\n                styles.signOutButton,\r\n                {\r\n                  backgroundColor: theme.accent.orange,\r\n                  borderColor: theme.accent.orange,\r\n                }\r\n              ]}\r\n              textColor={theme.text.onAccent}\r\n            />\r\n          </View>\r\n        </Animated.View>\r\n      </View>\r\n    </Modal>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    flex: 1,\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n    padding: spacing.xl,\r\n  },\r\n  card: {\r\n    width: '100%',\r\n    maxWidth: 320,\r\n    borderRadius: radius.xl,\r\n    padding: spacing.xl,\r\n    alignItems: 'center',\r\n    gap: spacing.md,\r\n    borderWidth: 2,\r\n    shadowColor: '#000',\r\n    shadowOffset: { width: 0, height: 4 },\r\n    shadowOpacity: 0.15,\r\n    shadowRadius: 12,\r\n    elevation: 8,\r\n  },\r\n  iconContainer: {\r\n    width: 64,\r\n    height: 64,\r\n    borderRadius: radius.full,\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n    borderWidth: 2,\r\n  },\r\n  title: {\r\n    textAlign: 'center',\r\n  },\r\n  message: {\r\n    textAlign: 'center',\r\n    marginBottom: spacing.sm,\r\n    lineHeight: 22,\r\n  },\r\n  buttonStack: {\r\n    width: '100%',\r\n    gap: spacing.md,\r\n  },\r\n  cancelButton: {\r\n    borderWidth: 2,\r\n    borderRadius: radius.lg,\r\n  },\r\n  signOutButton: {\r\n    borderWidth: 2,\r\n    borderRadius: radius.lg,\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\SimpleDistributionChart.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useEffect' is defined but never used.","line":8,"column":40,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":49},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'radius' is defined but never used.","line":17,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * SimpleVolumeDistributionChart\r\n * High-tier only donut chart for dashboard (Upper/Lower/Core)\r\n * Shows volume distribution (weight  reps  muscle_weighting)\r\n * Simplified version without carousel for the main Performance screen\r\n */\r\n\r\nimport React, { useState, useCallback, useEffect } from 'react';\r\nimport { View, StyleSheet, TouchableOpacity } from 'react-native';\r\nimport { useFocusEffect } from 'expo-router';\r\nimport { VictoryPie } from 'victory-native';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { ChartWrapper } from '@/components/atoms/ChartWrapper';\r\nimport { TimeRangeSelector } from '@/components/atoms/TimeRangeSelector';\r\nimport { colors, spacing, radius } from '@/constants/theme';\r\nimport { useAnalyticsData } from '@/hooks/useAnalyticsData';\r\nimport { TIME_RANGE_SUBTITLES } from '@/types/analytics';\r\nimport type { ChartSlice, TimeRange } from '@/types/analytics';\r\n\r\nconst PIE_SIZE = 240;\r\nconst EMPTY_MIN_HEIGHT = 240;\r\n\r\n// Orange with opacity based on index (sorted by value)\r\nconst getOrangeShade = (index: number, total: number): string => {\r\n  if (total <= 1) return 'rgba(255, 107, 74, 1.0)';\r\n  const ratio = index / (total - 1);\r\n  const opacity = 1.0 - ratio * 0.7;\r\n  return `rgba(255, 107, 74, ${opacity})`;\r\n};\r\n\r\ninterface LegendItemProps {\r\n  item: ChartSlice;\r\n  isSelected: boolean;\r\n  isDimmed: boolean;\r\n  onPress: () => void;\r\n}\r\n\r\nconst LegendItem: React.FC<LegendItemProps> = ({ item, isSelected, isDimmed, onPress }) => (\r\n  <TouchableOpacity\r\n    style={[styles.legendItem, { opacity: isDimmed ? 0.3 : 1 }]}\r\n    onPress={onPress}\r\n  >\r\n    <View style={[styles.legendColor, { backgroundColor: item.color }]} />\r\n    <Text variant=\"caption\" color=\"primary\">{item.name}</Text>\r\n    <Text variant=\"caption\" color=\"secondary\"> {Math.round(item.percentage)}%</Text>\r\n  </TouchableOpacity>\r\n);\r\n\r\nexport const SimpleDistributionChart: React.FC = () => {\r\n  const [timeRange, setTimeRange] = useState<TimeRange>('week');\r\n  const { tieredVolumeDistribution, hasFilteredData } = useAnalyticsData({ timeRange });\r\n  const [selectedSlice, setSelectedSlice] = useState<string | null>(null);\r\n  \r\n  // Reset time range to 'week' when page gains focus\r\n  useFocusEffect(\r\n    useCallback(() => {\r\n      setTimeRange('week');\r\n      setSelectedSlice(null);\r\n    }, [])\r\n  );\r\n\r\n  const data = tieredVolumeDistribution.high;\r\n\r\n  const handleSelectSlice = useCallback((name: string) => {\r\n    triggerHaptic('light');\r\n    setSelectedSlice((prev) => (prev === name ? null : name));\r\n  }, []);\r\n\r\n  // Prepare Victory data with orange color scheme\r\n  const chartData = data.map((item, index) => ({\r\n    x: item.name,\r\n    y: item.percentage,\r\n    color: getOrangeShade(index, data.length),\r\n  }));\r\n\r\n  const colorScale = chartData.map((d) => d.color);\r\n  const chartState = !hasFilteredData ? 'empty' : 'ready';\r\n  const emptyMessage = `No workout data for ${TIME_RANGE_SUBTITLES[timeRange].toLowerCase()}.`;\r\n\r\n  return (\r\n    <View style={styles.container}>\r\n      <View style={styles.selectorContainer}>\r\n        <TimeRangeSelector value={timeRange} onChange={setTimeRange} />\r\n      </View>\r\n\r\n      <ChartWrapper\r\n        state={chartState}\r\n        emptyMessage={emptyMessage}\r\n        minHeight={chartState === 'empty' ? EMPTY_MIN_HEIGHT : PIE_SIZE + 140}\r\n      >\r\n        <View style={styles.chartContainer}>\r\n          <VictoryPie\r\n            data={chartData}\r\n            width={PIE_SIZE + 40}\r\n            height={PIE_SIZE + 40}\r\n            colorScale={colorScale}\r\n            innerRadius={58}\r\n            startAngle={0}\r\n            endAngle={-360}\r\n            radius={({ datum }) =>\r\n              selectedSlice === datum.x ? PIE_SIZE / 2 + 8 : PIE_SIZE / 2\r\n            }\r\n            padAngle={2}\r\n            style={{\r\n              data: {\r\n                fill: ({ datum }) =>\r\n                  selectedSlice && selectedSlice !== datum.x\r\n                    ? colors.neutral.gray200\r\n                    : datum.color,\r\n              },\r\n              labels: { fill: 'transparent' },\r\n            }}\r\n            events={[\r\n              {\r\n                target: 'data',\r\n                eventHandlers: {\r\n                  onPressIn: () => [\r\n                    {\r\n                      target: 'data',\r\n                      mutation: (props) => {\r\n                        handleSelectSlice(props.datum.x);\r\n                        return null;\r\n                      },\r\n                    },\r\n                  ],\r\n                },\r\n              },\r\n            ]}\r\n          />\r\n\r\n          {/* Selected slice info in center */}\r\n          {selectedSlice && (\r\n            <View style={styles.selectedInfo}>\r\n              <Text variant=\"labelMedium\" color=\"primary\" numberOfLines={1}>{selectedSlice}</Text>\r\n              <Text variant=\"heading2\" color=\"primary\">\r\n                {Math.round(data.find(d => d.name === selectedSlice)?.percentage || 0)}%\r\n              </Text>\r\n            </View>\r\n          )}\r\n        </View>\r\n\r\n        <View style={styles.legend}>\r\n          {data.map((item, index) => (\r\n            <LegendItem\r\n              key={index}\r\n              item={item}\r\n              isSelected={selectedSlice === item.name}\r\n              isDimmed={selectedSlice !== null && selectedSlice !== item.name}\r\n              onPress={() => handleSelectSlice(item.name)}\r\n            />\r\n          ))}\r\n        </View>\r\n      </ChartWrapper>\r\n    </View>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    alignItems: 'center',\r\n    paddingVertical: spacing.sm,\r\n  },\r\n  selectorContainer: {\r\n    marginBottom: spacing.md,\r\n  },\r\n  chartContainer: {\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    position: 'relative',\r\n  },\r\n  selectedInfo: {\r\n    position: 'absolute',\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    width: 120,\r\n  },\r\n  legend: {\r\n    flexDirection: 'row',\r\n    justifyContent: 'center',\r\n    flexWrap: 'wrap',\r\n    gap: spacing.md,\r\n    marginTop: spacing.sm,\r\n  },\r\n  legendItem: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n  },\r\n  legendColor: {\r\n    width: 12,\r\n    height: 12,\r\n    borderRadius: 2,\r\n    marginRight: spacing.xs,\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\SimpleVolumeChart.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Text' is defined but never used.","line":11,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'radius' is defined but never used.","line":13,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'weightUnit' is assigned a value but never used.","line":28,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":28,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * SimpleVolumeChart\r\n * High-tier only bar chart for dashboard (Upper/Lower/Core)\r\n * Simplified version without carousel for the main Performance screen\r\n */\r\n\r\nimport React from 'react';\r\nimport { View, StyleSheet, Dimensions } from 'react-native';\r\nimport { VictoryChart, VictoryBar, VictoryAxis, VictoryTheme } from 'victory-native';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { ChartWrapper } from '@/components/atoms/ChartWrapper';\r\nimport { colors, spacing, radius } from '@/constants/theme';\r\nimport { useAnalyticsData } from '@/hooks/useAnalyticsData';\r\nimport { TIME_RANGE_SUBTITLES } from '@/types/analytics';\r\nimport { useSettingsStore } from '@/store/settingsStore';\r\n\r\nconst SCREEN_WIDTH = Dimensions.get('window').width;\r\nconst CHART_WIDTH = SCREEN_WIDTH - spacing.xl * 2 - spacing.md * 2;\r\nconst CHART_HEIGHT = 200;\r\n\r\ninterface SimpleVolumeChartProps {\r\n  timeRange?: 'week' | 'month' | 'year' | 'all';\r\n}\r\n\r\nexport const SimpleVolumeChart: React.FC<SimpleVolumeChartProps> = ({ timeRange = 'week' }) => {\r\n  const { weeklyVolume, hasFilteredData } = useAnalyticsData({ timeRange });\r\n  const weightUnit = useSettingsStore((state) => state.weightUnit);\r\n\r\n  const data = weeklyVolume.high;\r\n\r\n  // Calculate Y-axis ticks\r\n  const rawMax = Math.max(...data.map((d) => d.value), 0);\r\n  const allowedIncrements = [10, 25, 50, 100, 250, 500, 1000, 2500, 5000, 10000, 25000, 50000];\r\n\r\n  let targetMax = 100;\r\n  let increment = 25;\r\n\r\n  if (rawMax > 0) {\r\n    for (const inc of allowedIncrements) {\r\n      const segs = Math.ceil(rawMax / inc);\r\n      if (segs >= 2 && segs <= 5) {\r\n        targetMax = segs * inc;\r\n        increment = inc;\r\n        break;\r\n      }\r\n    }\r\n    if (targetMax < rawMax) {\r\n      targetMax = Math.ceil(rawMax / 1000) * 1000;\r\n      increment = targetMax / 4;\r\n    }\r\n  }\r\n\r\n  const yTickValues: number[] = [];\r\n  for (let i = 0; i <= targetMax; i += increment) {\r\n    yTickValues.push(i);\r\n  }\r\n\r\n  const xCategories = data.map((d) => d.label.replace('\\n', ' '));\r\n  const chartData = data.map((d, index) => ({\r\n    x: index + 1,\r\n    y: d.value,\r\n  }));\r\n  const chartState = !hasFilteredData ? 'empty' : 'ready';\r\n  const emptyMessage = `No workout data for ${TIME_RANGE_SUBTITLES[timeRange].toLowerCase()}.`;\r\n\r\n  return (\r\n    <ChartWrapper\r\n      state={chartState}\r\n      emptyMessage={emptyMessage}\r\n      minHeight={CHART_HEIGHT + 40}\r\n    >\r\n      <View style={styles.container}>\r\n        <View style={styles.chartContainer}>\r\n          <VictoryChart\r\n            theme={VictoryTheme.material}\r\n            domainPadding={{ x: 30 }}\r\n            padding={{ top: 30, bottom: 40, left: 20, right: 20 }}\r\n            height={CHART_HEIGHT}\r\n            width={CHART_WIDTH}\r\n          >\r\n            <VictoryAxis\r\n              tickValues={chartData.map((d) => d.x)}\r\n              tickFormat={(t, index) => xCategories[index] || ''}\r\n              style={{\r\n                axis: { stroke: 'none' },\r\n                tickLabels: { fill: colors.text.primary, fontSize: 11, padding: 5 },\r\n                grid: { stroke: 'none' },\r\n              }}\r\n            />\r\n            <VictoryAxis\r\n              dependentAxis\r\n              tickValues={yTickValues}\r\n              tickFormat={() => ''}\r\n              style={{\r\n                axis: { stroke: 'none' },\r\n                ticks: { stroke: 'none' },\r\n                tickLabels: { fill: 'transparent' },\r\n                grid: { stroke: 'none' },\r\n              }}\r\n            />\r\n            <VictoryBar\r\n              data={chartData}\r\n              labels={({ datum }) =>\r\n                datum.y > 0\r\n                  ? datum.y >= 1000\r\n                    ? `${(datum.y / 1000).toFixed(1)}k`\r\n                    : Math.round(datum.y).toString()\r\n                  : ''\r\n              }\r\n              style={{\r\n                data: {\r\n                  fill: colors.accent.orange,\r\n                  width: Math.min(32, (CHART_WIDTH - 100) / chartData.length - 8),\r\n                },\r\n                labels: {\r\n                  fill: colors.text.primary,\r\n                  fontSize: 10,\r\n                  fontWeight: '600',\r\n                },\r\n              }}\r\n              cornerRadius={{ top: 4 }}\r\n            />\r\n          </VictoryChart>\r\n        </View>\r\n      </View>\r\n    </ChartWrapper>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    alignItems: 'center',\r\n    paddingVertical: spacing.sm,\r\n  },\r\n  chartContainer: {\r\n    alignItems: 'center',\r\n    position: 'relative',\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\TimePickerModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\TrainingBalanceCard.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'workouts' conditional could make the dependencies of useMemo Hook (at line 345) change on every render. Move it inside the useMemo callback. Alternatively, wrap the initialization of 'workouts' in its own useMemo() Hook.","line":178,"column":9,"nodeType":"VariableDeclarator","endLine":178,"endColumn":69}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * TrainingBalanceCard\r\n * Shows push/pull and other muscle balance metrics\r\n * Consolidated view with both volume and sets data in one card\r\n */\r\n\r\nimport React, { useMemo, useState } from 'react';\r\nimport { View, StyleSheet } from 'react-native';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { SurfaceCard } from '@/components/atoms/SurfaceCard';\r\nimport { TimeRangeSelector } from '@/components/atoms/TimeRangeSelector';\r\nimport { colors, spacing, radius } from '@/constants/theme';\r\nimport { useWorkoutSessionsStore } from '@/store/workoutSessionsStore';\r\nimport { useDevToolsStore } from '@/store/devToolsStore';\r\nimport { useUserProfileStore } from '@/store/userProfileStore';\r\nimport exercisesData from '@/data/exercises.json';\r\nimport hierarchyData from '@/data/hierarchy.json';\r\nimport { TIME_RANGE_SUBTITLES } from '@/types/analytics';\r\nimport type { TimeRange } from '@/types/analytics';\r\nimport type { ExerciseType } from '@/types/exercise';\r\n\r\nconst EMPTY_MIN_HEIGHT = 240;\r\n\r\ninterface ExerciseMetadata {\r\n  push_pull: 'push' | 'pull' | null;\r\n  upper_lower: 'upper' | 'lower' | null;\r\n  is_compound: boolean;\r\n  exercise_type: ExerciseType;\r\n}\r\n\r\nconst EXERCISE_METADATA = exercisesData.reduce((acc, ex) => {\r\n  acc[ex.name] = {\r\n    push_pull: ex.push_pull as 'push' | 'pull' | null,\r\n    upper_lower: ex.upper_lower as 'upper' | 'lower' | null,\r\n    is_compound: ex.is_compound ?? false,\r\n    exercise_type: (ex.exercise_type as ExerciseType) || 'weight',\r\n  };\r\n  return acc;\r\n}, {} as Record<string, ExerciseMetadata>);\r\n\r\nconst EXERCISE_MUSCLES = exercisesData.reduce((acc, ex) => {\r\n  if (ex.muscles) {\r\n    acc[ex.name] = ex.muscles as unknown as Record<string, number>;\r\n  }\r\n  return acc;\r\n}, {} as Record<string, Record<string, number>>);\r\n\r\nconst buildLeafToL1 = (): Record<string, string> => {\r\n  const leafToL1: Record<string, string> = {};\r\n  const hierarchy = hierarchyData.muscle_hierarchy as Record<string, any>;\r\n\r\n  Object.entries(hierarchy).forEach(([l1, l1Data]) => {\r\n    if (l1Data?.muscles) {\r\n      Object.entries(l1Data.muscles).forEach(([l2, l2Data]: [string, any]) => {\r\n        leafToL1[l2] = l1;\r\n        if (l2Data?.muscles) {\r\n          Object.entries(l2Data.muscles).forEach(([l3, l3Data]: [string, any]) => {\r\n            leafToL1[l3] = l1;\r\n            if (l3Data?.muscles) {\r\n              Object.keys(l3Data.muscles).forEach((l4) => {\r\n                leafToL1[l4] = l1;\r\n              });\r\n            }\r\n          });\r\n        }\r\n      });\r\n    }\r\n  });\r\n\r\n  return leafToL1;\r\n};\r\n\r\nconst LEAF_TO_L1 = buildLeafToL1();\r\n\r\ninterface BalanceBarProps {\r\n  label: string;\r\n  leftValue: number;\r\n  rightValue: number;\r\n}\r\n\r\nconst BalanceBar: React.FC<BalanceBarProps> = ({\r\n  label,\r\n  leftValue,\r\n  rightValue,\r\n}) => {\r\n  const total = leftValue + rightValue;\r\n  const leftPercent = total > 0 ? (leftValue / total) * 100 : 50;\r\n  const rightPercent = total > 0 ? (rightValue / total) * 100 : 50;\r\n  \r\n  // Determine colors based on which side is higher\r\n  const isBalanced = Math.abs(leftPercent - rightPercent) < 1;\r\n  const leftIsHigher = leftPercent > rightPercent;\r\n  \r\n  const leftBarColor = isBalanced \r\n    ? colors.accent.orange \r\n    : leftIsHigher \r\n      ? colors.accent.orange \r\n      : 'rgba(255, 107, 74, 0.4)';\r\n  \r\n  const rightBarColor = isBalanced \r\n    ? colors.accent.orange \r\n    : !leftIsHigher \r\n      ? colors.accent.orange \r\n      : 'rgba(255, 107, 74, 0.4)';\r\n\r\n  return (\r\n    <View style={styles.balanceItem}>\r\n      <View style={styles.balanceHeader}>\r\n        <Text variant=\"labelMedium\" color=\"primary\">{label}</Text>\r\n      </View>\r\n\r\n      <View style={styles.barContainer}>\r\n        <View style={[styles.barSegment, { flex: leftPercent, backgroundColor: leftBarColor }]}>\r\n          <Text variant=\"captionSmall\" color=\"primary\" style={styles.barText}>\r\n            {Math.round(leftPercent)}%\r\n          </Text>\r\n        </View>\r\n        {isBalanced && <View style={styles.divider} />}\r\n        <View style={[styles.barSegment, { flex: rightPercent, backgroundColor: rightBarColor }]}>\r\n          <Text variant=\"captionSmall\" color=\"primary\" style={styles.barText}>\r\n            {Math.round(rightPercent)}%\r\n          </Text>\r\n        </View>\r\n      </View>\r\n    </View>\r\n  );\r\n};\r\n\r\ninterface BalanceData {\r\n  push: number;\r\n  pull: number;\r\n  quad: number;\r\n  hip: number;\r\n  upper: number;\r\n  lower: number;\r\n  compound: number;\r\n  isolated: number;\r\n}\r\n\r\ninterface BalanceSectionProps {\r\n  title: string;\r\n  data: BalanceData;\r\n}\r\n\r\nconst BalanceSection: React.FC<BalanceSectionProps> = ({ title, data }) => {\r\n  return (\r\n    <View style={styles.section}>\r\n      <Text variant=\"labelMedium\" color=\"secondary\" style={styles.sectionTitle}>\r\n        {title}\r\n      </Text>\r\n      <View style={styles.sectionContent}>\r\n        <BalanceBar\r\n          label=\"Push / Pull\"\r\n          leftValue={data.push}\r\n          rightValue={data.pull}\r\n        />\r\n\r\n        <BalanceBar\r\n          label=\"Upper / Lower\"\r\n          leftValue={data.upper}\r\n          rightValue={data.lower}\r\n        />\r\n\r\n        <BalanceBar\r\n          label=\"Compound / Isolated\"\r\n          leftValue={data.compound}\r\n          rightValue={data.isolated}\r\n        />\r\n      </View>\r\n    </View>\r\n  );\r\n};\r\n\r\nexport const TrainingBalanceCard: React.FC = () => {\r\n  const forceEmptyAnalytics = useDevToolsStore((state) => state.forceEmptyAnalytics);\r\n  const rawWorkouts = useWorkoutSessionsStore((state) => state.workouts);\r\n  const workouts = __DEV__ && forceEmptyAnalytics ? [] : rawWorkouts;\r\n  const userBodyWeight = useUserProfileStore((state) => state.profile?.weightLbs);\r\n  const [timeRange, setTimeRange] = useState<TimeRange>('week');\r\n\r\n  // Calculate balance data for both volume and sets\r\n  const { volumeData, setData, hasData } = useMemo(() => {\r\n    const volumeBalance: BalanceData = { push: 0, pull: 0, quad: 0, hip: 0, upper: 0, lower: 0, compound: 0, isolated: 0 };\r\n    const setBalance: BalanceData = { push: 0, pull: 0, quad: 0, hip: 0, upper: 0, lower: 0, compound: 0, isolated: 0 };\r\n\r\n    // Calculate cutoff date based on time range (match useAnalyticsData semantics)\r\n    const now = new Date();\r\n    let cutoff: Date;\r\n\r\n    switch (timeRange) {\r\n      case 'week':\r\n        // Last 7 days\r\n        cutoff = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\r\n        break;\r\n      case 'month':\r\n        // Since first of current month\r\n        cutoff = new Date(now.getFullYear(), now.getMonth(), 1);\r\n        break;\r\n      case 'year':\r\n        // Since first of current year\r\n        cutoff = new Date(now.getFullYear(), 0, 1);\r\n        break;\r\n      case 'all':\r\n      default:\r\n        cutoff = new Date(0); // All time\r\n        break;\r\n    }\r\n\r\n    workouts\r\n      .filter((w) => new Date(w.date) >= cutoff)\r\n      .forEach((workout) => {\r\n        workout.exercises.forEach((exercise: any) => {\r\n          const metadata = EXERCISE_METADATA[exercise.name];\r\n          if (!metadata) return;\r\n\r\n          const exerciseType = metadata.exercise_type || 'weight';\r\n\r\n          // Skip cardio and pure duration exercises from balance stats\r\n          if (exerciseType === 'cardio' || exerciseType === 'duration') {\r\n            return;\r\n          }\r\n\r\n          // Count completed sets for this exercise\r\n          const completedSets = exercise.sets.filter((set: any) => {\r\n            if (!set.completed) return false;\r\n            // For weight/assisted/bodyweight/reps_only, ensure we have meaningful reps/weight\r\n            const reps = set.reps ?? 0;\r\n            const weight = set.weight ?? 0;\r\n            const assistanceWeight = set.assistanceWeight ?? 0;\r\n\r\n            switch (exerciseType) {\r\n              case 'weight':\r\n                return reps > 0 && weight > 0;\r\n              case 'bodyweight':\r\n              case 'reps_only':\r\n                return reps > 0;\r\n              case 'assisted':\r\n                return reps > 0 && (weight > 0 || assistanceWeight > 0);\r\n              default:\r\n                return false;\r\n            }\r\n          });\r\n\r\n          const setCount = completedSets.length;\r\n          if (setCount === 0) return;\r\n\r\n          // Calculate total volume for this exercise using global analytics semantics\r\n          let totalVolume = 0;\r\n\r\n          completedSets.forEach((set: any) => {\r\n            const reps = set.reps ?? 0;\r\n            if (reps <= 0) {\r\n              return;\r\n            }\r\n\r\n            let setVolume = 0;\r\n\r\n            switch (exerciseType) {\r\n              case 'bodyweight':\r\n                if (userBodyWeight && userBodyWeight > 0) {\r\n                  setVolume = userBodyWeight * reps;\r\n                }\r\n                break;\r\n              case 'assisted': {\r\n                if (!userBodyWeight || userBodyWeight <= 0) {\r\n                  break;\r\n                }\r\n                const assistanceWeight = set.assistanceWeight ?? 0;\r\n                const effectiveWeight = Math.max(0, userBodyWeight - assistanceWeight);\r\n                if (effectiveWeight > 0) {\r\n                  setVolume = effectiveWeight * reps;\r\n                }\r\n                break;\r\n              }\r\n              case 'reps_only':\r\n                // Resistance bands: do not contribute to volume-based balance\r\n                setVolume = 0;\r\n                break;\r\n              case 'weight':\r\n              default: {\r\n                const weight = set.weight ?? 0;\r\n                if (weight > 0) {\r\n                  setVolume = weight * reps;\r\n                }\r\n                break;\r\n              }\r\n            }\r\n\r\n            if (setVolume > 0) {\r\n              totalVolume += setVolume;\r\n            }\r\n          });\r\n\r\n          // Push/Pull classification\r\n          if (metadata.push_pull === 'push') {\r\n            setBalance.push += setCount;\r\n            volumeBalance.push += totalVolume;\r\n          } else if (metadata.push_pull === 'pull') {\r\n            setBalance.pull += setCount;\r\n            volumeBalance.pull += totalVolume;\r\n          }\r\n\r\n          // Upper/Lower classification (volume-based: distribute by muscle weights)\r\n          // Sets still use exercise-level classification\r\n          if (metadata.upper_lower === 'upper') {\r\n            setBalance.upper += setCount;\r\n          } else if (metadata.upper_lower === 'lower') {\r\n            setBalance.lower += setCount;\r\n          }\r\n\r\n          // Volume: distribute based on individual muscle contributions\r\n          const muscleWeights = EXERCISE_MUSCLES[exercise.name];\r\n          if (muscleWeights && totalVolume > 0) {\r\n            Object.entries(muscleWeights).forEach(([muscle, weight]) => {\r\n              const muscleVolume = totalVolume * weight;\r\n              const l1Category = LEAF_TO_L1[muscle];\r\n              if (l1Category === 'Upper Body' || l1Category === 'Core') {\r\n                volumeBalance.upper += muscleVolume;\r\n              } else if (l1Category === 'Lower Body') {\r\n                volumeBalance.lower += muscleVolume;\r\n              }\r\n            });\r\n          }\r\n\r\n          // Compound/Isolated classification\r\n          if (metadata.is_compound) {\r\n            setBalance.compound += setCount;\r\n            volumeBalance.compound += totalVolume;\r\n          } else {\r\n            setBalance.isolated += setCount;\r\n            volumeBalance.isolated += totalVolume;\r\n          }\r\n        });\r\n      });\r\n\r\n    const hasVolumeData = Object.values(volumeBalance).some((v) => v > 0);\r\n    const hasSetData = Object.values(setBalance).some((v) => v > 0);\r\n\r\n    return {\r\n      volumeData: volumeBalance,\r\n      setData: setBalance,\r\n      hasData: hasVolumeData || hasSetData,\r\n    };\r\n  }, [workouts, timeRange, userBodyWeight]);\r\n\r\n  return (\r\n    <SurfaceCard tone=\"neutral\" padding=\"md\" showAccentStripe={false}>\r\n      <View style={styles.container}>\r\n        <View style={[styles.header, styles.headerCentered]}>\r\n          <Text variant=\"heading3\" color=\"primary\">\r\n            Training Balance\r\n          </Text>\r\n        </View>\r\n\r\n        <View style={styles.timeRangeContainer}>\r\n          <TimeRangeSelector value={timeRange} onChange={setTimeRange} />\r\n        </View>\r\n\r\n        {!hasData ? (\r\n          <View style={styles.emptyState}>\r\n            <Text variant=\"body\" color=\"secondary\" style={styles.emptyText}>\r\n              {`No workout data for ${TIME_RANGE_SUBTITLES[timeRange].toLowerCase()}.`}\r\n            </Text>\r\n          </View>\r\n        ) : (\r\n          <View style={styles.sectionsContainer}>\r\n            <BalanceSection title=\"By Volume\" data={volumeData} />\r\n            <BalanceSection title=\"By Sets\" data={setData} />\r\n          </View>\r\n        )}\r\n      </View>\r\n    </SurfaceCard>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    gap: spacing.md,\r\n    paddingHorizontal: spacing.lg,\r\n  },\r\n  header: {\r\n    paddingTop: spacing.sm,\r\n    paddingBottom: spacing.xs,\r\n  },\r\n  headerCentered: {\r\n    alignItems: 'center',\r\n  },\r\n  timeRangeContainer: {\r\n    alignItems: 'center',\r\n    marginBottom: spacing.xl,\r\n  },\r\n  sectionsContainer: {\r\n    gap: spacing.xl,\r\n  },\r\n  section: {\r\n    gap: spacing.md,\r\n  },\r\n  sectionTitle: {\r\n    textAlign: 'center',\r\n    paddingBottom: spacing.sm,\r\n  },\r\n  sectionContent: {\r\n    gap: spacing.lg,\r\n  },\r\n  balanceItem: {\r\n    gap: spacing.sm,\r\n  },\r\n  balanceHeader: {\r\n    flexDirection: 'row',\r\n    justifyContent: 'space-between',\r\n    alignItems: 'center',\r\n  },\r\n  barContainer: {\r\n    flexDirection: 'row',\r\n    height: 28,\r\n    borderRadius: radius.sm,\r\n    overflow: 'hidden',\r\n  },\r\n  barSegment: {\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n  },\r\n  divider: {\r\n    width: 2,\r\n    backgroundColor: colors.primary.bg,\r\n  },\r\n  barText: {\r\n    color: colors.text.onAccent,\r\n    fontWeight: '600',\r\n  },\r\n  emptyState: {\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    padding: spacing.md,\r\n    minHeight: EMPTY_MIN_HEIGHT,\r\n  },\r\n  emptyText: {\r\n    textAlign: 'center',\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\TypingIndicator.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'radius' is defined but never used.","line":18,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":18,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * TypingIndicator\r\n * Animated dot-dot-dot indicator for AI typing state\r\n */\r\n\r\nimport React, { useEffect } from 'react';\r\nimport { View, StyleSheet } from 'react-native';\r\nimport Animated, {\r\n  useSharedValue,\r\n  useAnimatedStyle,\r\n  withRepeat,\r\n  withSequence,\r\n  withTiming,\r\n  withDelay,\r\n} from 'react-native-reanimated';\r\n\r\nimport { useTheme } from '@/hooks/useTheme';\r\nimport { spacing, radius } from '@/constants/theme';\r\n\r\ninterface TypingIndicatorProps {\r\n  isVisible: boolean;\r\n}\r\n\r\nconst DOT_SIZE = 8;\r\nconst ANIMATION_DURATION = 400;\r\n\r\nexport const TypingIndicator: React.FC<TypingIndicatorProps> = ({ isVisible }) => {\r\n  const { theme } = useTheme();\r\n\r\n  const dot1Opacity = useSharedValue(0.3);\r\n  const dot2Opacity = useSharedValue(0.3);\r\n  const dot3Opacity = useSharedValue(0.3);\r\n\r\n  useEffect(() => {\r\n    if (isVisible) {\r\n      dot1Opacity.value = withRepeat(\r\n        withSequence(\r\n          withTiming(1, { duration: ANIMATION_DURATION }),\r\n          withTiming(0.3, { duration: ANIMATION_DURATION })\r\n        ),\r\n        -1,\r\n        false\r\n      );\r\n\r\n      dot2Opacity.value = withDelay(\r\n        ANIMATION_DURATION / 3,\r\n        withRepeat(\r\n          withSequence(\r\n            withTiming(1, { duration: ANIMATION_DURATION }),\r\n            withTiming(0.3, { duration: ANIMATION_DURATION })\r\n          ),\r\n          -1,\r\n          false\r\n        )\r\n      );\r\n\r\n      dot3Opacity.value = withDelay(\r\n        (ANIMATION_DURATION / 3) * 2,\r\n        withRepeat(\r\n          withSequence(\r\n            withTiming(1, { duration: ANIMATION_DURATION }),\r\n            withTiming(0.3, { duration: ANIMATION_DURATION })\r\n          ),\r\n          -1,\r\n          false\r\n        )\r\n      );\r\n    } else {\r\n      dot1Opacity.value = 0.3;\r\n      dot2Opacity.value = 0.3;\r\n      dot3Opacity.value = 0.3;\r\n    }\r\n  }, [isVisible, dot1Opacity, dot2Opacity, dot3Opacity]);\r\n\r\n  const dot1Style = useAnimatedStyle(() => ({\r\n    opacity: dot1Opacity.value,\r\n  }));\r\n\r\n  const dot2Style = useAnimatedStyle(() => ({\r\n    opacity: dot2Opacity.value,\r\n  }));\r\n\r\n  const dot3Style = useAnimatedStyle(() => ({\r\n    opacity: dot3Opacity.value,\r\n  }));\r\n\r\n  if (!isVisible) return null;\r\n\r\n  return (\r\n    <View style={styles.container}>\r\n      <View style={styles.dotsContainer}>\r\n        <Animated.View\r\n          style={[styles.dot, { backgroundColor: theme.text.secondary }, dot1Style]}\r\n        />\r\n        <Animated.View\r\n          style={[styles.dot, { backgroundColor: theme.text.secondary }, dot2Style]}\r\n        />\r\n        <Animated.View\r\n          style={[styles.dot, { backgroundColor: theme.text.secondary }, dot3Style]}\r\n        />\r\n      </View>\r\n    </View>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    marginVertical: spacing.sm,\r\n    paddingLeft: spacing.md,\r\n    paddingRight: spacing.md,\r\n    paddingVertical: spacing.md,\r\n    width: '100%',\r\n  },\r\n  dotsContainer: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    gap: spacing.xs,\r\n  },\r\n  dot: {\r\n    width: DOT_SIZE,\r\n    height: DOT_SIZE,\r\n    borderRadius: DOT_SIZE / 2,\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\UnitsModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'IconSymbol' is defined but never used.","line":12,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * UnitsModal\r\n * Modal for selecting granular unit preferences (weight, distance, size).\r\n */\r\n\r\nimport React, { useCallback } from 'react';\r\nimport { Modal, Pressable, ScrollView, StyleSheet, View } from 'react-native';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { Button } from '@/components/atoms/Button';\r\nimport { IconSymbol } from '@/components/ui/icon-symbol';\r\nimport { radius, shadows, spacing } from '@/constants/theme';\r\nimport { useTheme } from '@/hooks/useTheme';\r\nimport {\r\n  useSettingsStore,\r\n  WeightUnit,\r\n  DistanceUnit,\r\n} from '@/store/settingsStore';\r\n\r\ninterface UnitsModalProps {\r\n  visible: boolean;\r\n  onClose: () => void;\r\n}\r\n\r\ninterface UnitRowProps {\r\n  label: string;\r\n  options: { value: string; label: string }[];\r\n  selectedValue: string;\r\n  onSelect: (value: string) => void;\r\n}\r\n\r\nconst UnitRow: React.FC<UnitRowProps> = ({\r\n  label,\r\n  options,\r\n  selectedValue,\r\n  onSelect,\r\n}) => {\r\n  const { theme } = useTheme();\r\n\r\n  return (\r\n    <View style={styles.unitRow}>\r\n      <Text variant=\"bodySemibold\" color=\"primary\" style={styles.unitLabel}>\r\n        {label}\r\n      </Text>\r\n      <View style={styles.toggleContainer}>\r\n        {options.map((option) => {\r\n          const isSelected = selectedValue === option.value;\r\n          return (\r\n            <Pressable\r\n              key={option.value}\r\n              style={[\r\n                styles.toggleOption,\r\n                { borderColor: theme.border.light, backgroundColor: theme.surface.card },\r\n                isSelected && { backgroundColor: theme.accent.orange, borderColor: theme.accent.orange },\r\n              ]}\r\n              onPress={() => {\r\n                triggerHaptic('selection');\r\n                onSelect(option.value);\r\n              }}\r\n            >\r\n              <View style={styles.toggleOptionContent}>\r\n                <Text\r\n                  variant=\"bodySemibold\"\r\n                  color={isSelected ? 'onAccent' : 'primary'}\r\n                  style={styles.toggleOptionText}\r\n                >\r\n                  {option.label.split(' ')[0]}\r\n                </Text>\r\n                <Text\r\n                  variant=\"caption\"\r\n                  color={isSelected ? 'onAccent' : 'primary'}\r\n                  style={styles.toggleOptionUnit}\r\n                >\r\n                  {option.label.split(' ')[1]}\r\n                </Text>\r\n              </View>\r\n            </Pressable>\r\n          );\r\n        })}\r\n      </View>\r\n    </View>\r\n  );\r\n};\r\n\r\nexport const UnitsModal: React.FC<UnitsModalProps> = ({ visible, onClose }) => {\r\n  const { theme } = useTheme();\r\n  const {\r\n    weightUnit,\r\n    distanceUnit,\r\n    setWeightUnit,\r\n    setDistanceUnit,\r\n  } = useSettingsStore();\r\n\r\n  const handleClose = useCallback(() => {\r\n    triggerHaptic('selection');\r\n    onClose();\r\n  }, [onClose]);\r\n\r\n  const handleSave = useCallback(() => {\r\n    triggerHaptic('success');\r\n    onClose();\r\n  }, [onClose]);\r\n\r\n  return (\r\n    <Modal\r\n      visible={visible}\r\n      animationType=\"fade\"\r\n      transparent\r\n      onRequestClose={handleClose}\r\n    >\r\n      <Pressable style={styles.overlay} onPress={handleClose}>\r\n        <Pressable style={[styles.modalContent, { backgroundColor: theme.surface.card }]} onPress={(e) => e.stopPropagation()}>\r\n          <Text variant=\"heading2\" color=\"primary\" style={styles.title}>\r\n            Measurement Units\r\n          </Text>\r\n\r\n          <ScrollView style={styles.scrollContent} showsVerticalScrollIndicator={false}>\r\n            <View style={styles.optionsContainer}>\r\n              <UnitRow\r\n                label=\"Weight\"\r\n                options={[\r\n                  { value: 'lbs', label: 'Pounds (lbs)' },\r\n                  { value: 'kg', label: 'Kilograms (kg)' },\r\n                ]}\r\n                selectedValue={weightUnit}\r\n                onSelect={(value) => setWeightUnit(value as WeightUnit)}\r\n              />\r\n\r\n              <UnitRow\r\n                label=\"Distance\"\r\n                options={[\r\n                  { value: 'mi', label: 'Miles (mi)' },\r\n                  { value: 'km', label: 'Kilometers (km)' },\r\n                ]}\r\n                selectedValue={distanceUnit}\r\n                onSelect={(value) => setDistanceUnit(value as DistanceUnit)}\r\n              />\r\n            </View>\r\n          </ScrollView>\r\n\r\n          <View style={styles.buttonContainer}>\r\n            <Button\r\n              label=\"Done\"\r\n              variant=\"primary\"\r\n              onPress={handleSave}\r\n              style={styles.button}\r\n            />\r\n          </View>\r\n        </Pressable>\r\n      </Pressable>\r\n    </Modal>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  overlay: {\r\n    flex: 1,\r\n    backgroundColor: 'rgba(0, 0, 0, 0.5)',\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n    padding: spacing.lg,\r\n  },\r\n  modalContent: {\r\n    borderRadius: radius.xl,\r\n    padding: spacing.xl,\r\n    width: '100%',\r\n    maxWidth: 400,\r\n    maxHeight: '80%',\r\n    ...shadows.lg,\r\n  },\r\n  title: {\r\n    marginBottom: spacing.md,\r\n  },\r\n  scrollContent: {\r\n    flexGrow: 0,\r\n  },\r\n  optionsContainer: {\r\n    gap: spacing.md,\r\n    marginBottom: spacing.md,\r\n  },\r\n  unitRow: {\r\n    gap: spacing.xs,\r\n  },\r\n  unitLabel: {\r\n    marginBottom: spacing.xxs,\r\n  },\r\n  toggleContainer: {\r\n    flexDirection: 'row',\r\n    gap: spacing.sm,\r\n  },\r\n  toggleOption: {\r\n    flex: 1,\r\n    paddingVertical: spacing.sm,\r\n    paddingHorizontal: spacing.sm,\r\n    borderRadius: radius.lg,\r\n    borderWidth: 1,\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n  },\r\n  toggleOptionContent: {\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n  },\r\n  toggleOptionText: {\r\n    textAlign: 'center',\r\n  },\r\n  toggleOptionUnit: {\r\n    textAlign: 'center',\r\n    marginTop: 1,\r\n  },\r\n  buttonContainer: {\r\n    marginTop: spacing.sm,\r\n  },\r\n  button: {\r\n    width: '100%',\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\UpgradePremiumCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\ViewAllProgramsModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\ViewAllWorkoutsModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\VolumeTrendChart.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\WeeklyCardioGoalCard.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'distanceUnit' is assigned a value but never used.","line":120,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":120,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * WeeklyCardioGoalCard\r\n * Shows weekly cardio goal progress with swipeable Time/Distance slides.\r\n * Features a circular progress ring matching BalanceScoreCard style.\r\n */\r\nimport React, { useState, useRef, useCallback } from 'react';\r\nimport { View, StyleSheet, ScrollView, Pressable, Dimensions, NativeSyntheticEvent, NativeScrollEvent } from 'react-native';\r\nimport Svg, { Circle } from 'react-native-svg';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { SurfaceCard } from '@/components/atoms/SurfaceCard';\r\nimport { IconSymbol } from '@/components/ui/icon-symbol';\r\nimport { CardioGoalModal, CardioGoalType } from '@/components/molecules/CardioGoalModal';\r\nimport { colors, spacing, radius, sizing } from '@/constants/theme';\r\nimport { useTheme } from '@/hooks/useTheme';\r\nimport { useSettingsStore } from '@/store/settingsStore';\r\nimport { useWeeklyCardioProgress } from '@/hooks/useWeeklyCardioProgress';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\n\r\nconst SCREEN_WIDTH = Dimensions.get('window').width;\r\nconst CARD_PADDING = spacing.md * 2;\r\nconst SLIDE_WIDTH = SCREEN_WIDTH - CARD_PADDING - spacing.md * 2;\r\n\r\ninterface CircularProgressProps {\r\n  percentage: number;\r\n  size: number;\r\n}\r\n\r\nconst CircularProgress: React.FC<CircularProgressProps> = ({ percentage, size }) => {\r\n  const ringSize = size - 20;\r\n  const strokeWidth = 10;\r\n  const radiusValue = ringSize / 2;\r\n  const effectiveRadius = radiusValue - strokeWidth / 2;\r\n  const circumference = 2 * Math.PI * effectiveRadius;\r\n\r\n  // Clamp progress for visual ring (max 100%), but display actual percentage\r\n  const visualProgress = Math.min(percentage, 100) / 100;\r\n  const strokeDashoffset = circumference * (1 - visualProgress);\r\n\r\n  // Display percentage can exceed 100%\r\n  const displayPercentage = Math.round(percentage);\r\n\r\n  return (\r\n    <View style={[styles.progressContainer, { width: size, height: size }]}>\r\n      <Svg width={ringSize} height={ringSize}>\r\n        {/* Background ring - always muted orange */}\r\n        <Circle\r\n          cx={radiusValue}\r\n          cy={radiusValue}\r\n          r={effectiveRadius}\r\n          stroke={colors.accent.orangeMuted}\r\n          strokeWidth={strokeWidth}\r\n          fill=\"none\"\r\n        />\r\n\r\n        {/* Foreground progress ring - primary orange, proportional to score */}\r\n        {visualProgress > 0 && (\r\n          <Circle\r\n            cx={radiusValue}\r\n            cy={radiusValue}\r\n            r={effectiveRadius}\r\n            stroke={colors.accent.orange}\r\n            strokeWidth={strokeWidth}\r\n            fill=\"none\"\r\n            strokeDasharray={`${circumference}`}\r\n            strokeDashoffset={strokeDashoffset}\r\n            strokeLinecap=\"round\"\r\n            rotation=\"-90\"\r\n            origin={`${radiusValue}, ${radiusValue}`}\r\n          />\r\n        )}\r\n      </Svg>\r\n\r\n      {/* Percentage text in center */}\r\n      <View style={styles.percentageContainer}>\r\n        <Text variant=\"heading3\" color=\"primary\">\r\n          {displayPercentage}%\r\n        </Text>\r\n      </View>\r\n    </View>\r\n  );\r\n};\r\n\r\nconst formatDuration = (totalSeconds: number): string => {\r\n  const hours = Math.floor(totalSeconds / 3600);\r\n  const minutes = Math.floor((totalSeconds % 3600) / 60);\r\n\r\n  if (hours > 0) {\r\n    if (minutes < 10) {\r\n      return `${hours}:0${minutes}`;\r\n    }\r\n    return `${hours}:${minutes}`;\r\n  }\r\n  return `${minutes}m`;\r\n};\r\n\r\nconst formatGoalDuration = (totalSeconds: number): string => {\r\n  const hours = Math.floor(totalSeconds / 3600);\r\n  const minutes = Math.floor((totalSeconds % 3600) / 60);\r\n\r\n  if (hours > 0 && minutes > 0) {\r\n    return `${hours}h ${minutes}m`;\r\n  }\r\n  if (hours > 0) {\r\n    return `${hours}h`;\r\n  }\r\n  return `${minutes}m`;\r\n};\r\n\r\nexport const WeeklyCardioGoalCard: React.FC = () => {\r\n  const { theme } = useTheme();\r\n  const scrollRef = useRef<ScrollView>(null);\r\n  const [activeSlide, setActiveSlide] = useState(0);\r\n  const [goalModalVisible, setGoalModalVisible] = useState(false);\r\n  const [goalModalType, setGoalModalType] = useState<CardioGoalType>('time');\r\n\r\n  const {\r\n    weeklyCardioTimeGoal,\r\n    weeklyCardioDistanceGoal,\r\n    distanceUnit,\r\n    convertDistance,\r\n    getDistanceUnitShort,\r\n  } = useSettingsStore();\r\n\r\n  const { weeklyTime, weeklyDistance } = useWeeklyCardioProgress();\r\n\r\n  // Calculate percentages\r\n  const timePercentage = weeklyCardioTimeGoal && weeklyCardioTimeGoal > 0\r\n    ? (weeklyTime / weeklyCardioTimeGoal) * 100\r\n    : 0;\r\n  \r\n  const distancePercentage = weeklyCardioDistanceGoal && weeklyCardioDistanceGoal > 0\r\n    ? (weeklyDistance / weeklyCardioDistanceGoal) * 100\r\n    : 0;\r\n\r\n  const handleScroll = useCallback((event: NativeSyntheticEvent<NativeScrollEvent>) => {\r\n    const offsetX = event.nativeEvent.contentOffset.x;\r\n    const newIndex = Math.round(offsetX / SLIDE_WIDTH);\r\n    if (newIndex !== activeSlide && (newIndex === 0 || newIndex === 1)) {\r\n      setActiveSlide(newIndex);\r\n      triggerHaptic('selection');\r\n    }\r\n  }, [activeSlide]);\r\n\r\n  const handleDotPress = useCallback((index: number) => {\r\n    triggerHaptic('selection');\r\n    scrollRef.current?.scrollTo({ x: index * SLIDE_WIDTH, animated: true });\r\n    setActiveSlide(index);\r\n  }, []);\r\n\r\n  const openGoalModal = useCallback((type: CardioGoalType) => {\r\n    triggerHaptic('selection');\r\n    setGoalModalType(type);\r\n    setGoalModalVisible(true);\r\n  }, []);\r\n\r\n  const distanceUnitShort = getDistanceUnitShort();\r\n\r\n  // Format progress/goal text for time\r\n  const formatTimeProgress = () => {\r\n    const progressStr = formatDuration(weeklyTime);\r\n    const goalStr = weeklyCardioTimeGoal ? formatGoalDuration(weeklyCardioTimeGoal) : '';\r\n    return `${progressStr} / ${goalStr}`;\r\n  };\r\n\r\n  // Format progress/goal text for distance\r\n  const formatDistanceProgress = () => {\r\n    const progressValue = convertDistance(weeklyDistance);\r\n    const progressStr = progressValue.toFixed(1);\r\n    const goalValue = weeklyCardioDistanceGoal ? convertDistance(weeklyCardioDistanceGoal) : null;\r\n    const goalStr = goalValue ? goalValue.toFixed(1) : '';\r\n    return `${progressStr} / ${goalStr} ${distanceUnitShort}`;\r\n  };\r\n\r\n  const renderTimeSlide = () => {\r\n    const hasGoal = weeklyCardioTimeGoal && weeklyCardioTimeGoal > 0;\r\n\r\n    return (\r\n      <View style={[styles.slide, { width: SLIDE_WIDTH }]}>\r\n        <View style={styles.slideHeader}>\r\n          <Text variant=\"body\" color=\"primary\" style={styles.slideTitle}>Time Goal</Text>\r\n          <Pressable\r\n            onPress={() => openGoalModal('time')}\r\n            hitSlop={spacing.sm}\r\n            style={styles.settingsButton}\r\n          >\r\n            <IconSymbol\r\n              name={hasGoal ? 'edit' : 'add'}\r\n              size={sizing.iconSM}\r\n              color={theme.accent.orange}\r\n            />\r\n          </Pressable>\r\n        </View>\r\n\r\n        {hasGoal ? (\r\n          <View style={styles.progressContent}>\r\n            <CircularProgress percentage={timePercentage} size={120} />\r\n            <Text variant=\"body\" color=\"secondary\" style={styles.progressText}>\r\n              {formatTimeProgress()}\r\n            </Text>\r\n          </View>\r\n        ) : (\r\n          <Pressable style={styles.emptyState} onPress={() => openGoalModal('time')}>\r\n            <View style={styles.emptyIconContainer}>\r\n              <IconSymbol name=\"add\" size={sizing.iconLG} color={theme.accent.orange} />\r\n            </View>\r\n            <Text variant=\"body\" color=\"secondary\" style={styles.emptyText}>\r\n              Set a weekly time goal\r\n            </Text>\r\n          </Pressable>\r\n        )}\r\n      </View>\r\n    );\r\n  };\r\n\r\n  const renderDistanceSlide = () => {\r\n    const hasGoal = weeklyCardioDistanceGoal && weeklyCardioDistanceGoal > 0;\r\n\r\n    return (\r\n      <View style={[styles.slide, { width: SLIDE_WIDTH }]}>\r\n        <View style={styles.slideHeader}>\r\n          <Text variant=\"body\" color=\"primary\" style={styles.slideTitle}>Distance Goal</Text>\r\n          <Pressable\r\n            onPress={() => openGoalModal('distance')}\r\n            hitSlop={spacing.sm}\r\n            style={styles.settingsButton}\r\n          >\r\n            <IconSymbol\r\n              name={hasGoal ? 'edit' : 'add'}\r\n              size={sizing.iconSM}\r\n              color={theme.accent.orange}\r\n            />\r\n          </Pressable>\r\n        </View>\r\n\r\n        {hasGoal ? (\r\n          <View style={styles.progressContent}>\r\n            <CircularProgress percentage={distancePercentage} size={120} />\r\n            <Text variant=\"body\" color=\"secondary\" style={styles.progressText}>\r\n              {formatDistanceProgress()}\r\n            </Text>\r\n          </View>\r\n        ) : (\r\n          <Pressable style={styles.emptyState} onPress={() => openGoalModal('distance')}>\r\n            <View style={styles.emptyIconContainer}>\r\n              <IconSymbol name=\"add\" size={sizing.iconLG} color={theme.accent.orange} />\r\n            </View>\r\n            <Text variant=\"body\" color=\"secondary\" style={styles.emptyText}>\r\n              Set a weekly distance goal\r\n            </Text>\r\n          </Pressable>\r\n        )}\r\n      </View>\r\n    );\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <SurfaceCard tone=\"neutral\" padding=\"md\" showAccentStripe={false}>\r\n        <View style={styles.container}>\r\n          <View style={styles.header}>\r\n            <Text variant=\"heading3\" color=\"primary\">\r\n              Weekly Cardio Goal\r\n            </Text>\r\n          </View>\r\n\r\n          <ScrollView\r\n            ref={scrollRef}\r\n            horizontal\r\n            pagingEnabled\r\n            showsHorizontalScrollIndicator={false}\r\n            onScroll={handleScroll}\r\n            scrollEventThrottle={16}\r\n            decelerationRate=\"fast\"\r\n            snapToInterval={SLIDE_WIDTH}\r\n            contentContainerStyle={styles.scrollContent}\r\n          >\r\n            {renderTimeSlide()}\r\n            {renderDistanceSlide()}\r\n          </ScrollView>\r\n\r\n          {/* Page indicator dots */}\r\n          <View style={styles.dotsContainer}>\r\n            <Pressable\r\n              onPress={() => handleDotPress(0)}\r\n              hitSlop={spacing.sm}\r\n              style={styles.dotHitArea}\r\n            >\r\n              <View style={[\r\n                styles.dot,\r\n                activeSlide === 0 ? styles.dotActive : styles.dotInactive,\r\n              ]} />\r\n            </Pressable>\r\n            <Pressable\r\n              onPress={() => handleDotPress(1)}\r\n              hitSlop={spacing.sm}\r\n              style={styles.dotHitArea}\r\n            >\r\n              <View style={[\r\n                styles.dot,\r\n                activeSlide === 1 ? styles.dotActive : styles.dotInactive,\r\n              ]} />\r\n            </Pressable>\r\n          </View>\r\n        </View>\r\n      </SurfaceCard>\r\n\r\n      <CardioGoalModal\r\n        visible={goalModalVisible}\r\n        onClose={() => setGoalModalVisible(false)}\r\n        goalType={goalModalType}\r\n      />\r\n    </>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    gap: spacing.sm,\r\n  },\r\n  header: {\r\n    alignItems: 'center',\r\n    paddingTop: spacing.sm,\r\n    paddingBottom: spacing.xs,\r\n  },\r\n  scrollContent: {\r\n    paddingHorizontal: 0,\r\n  },\r\n  slide: {\r\n    paddingHorizontal: spacing.md,\r\n  },\r\n  slideHeader: {\r\n    flexDirection: 'row',\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n    marginBottom: spacing.md,\r\n    position: 'relative',\r\n  },\r\n  slideTitle: {\r\n    textAlign: 'center',\r\n  },\r\n  settingsButton: {\r\n    padding: spacing.xs,\r\n    position: 'absolute',\r\n    right: 0,\r\n  },\r\n  progressContent: {\r\n    alignItems: 'center',\r\n    paddingVertical: spacing.md,\r\n    gap: spacing.sm,\r\n  },\r\n  progressContainer: {\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n    position: 'relative',\r\n  },\r\n  percentageContainer: {\r\n    position: 'absolute',\r\n    top: 0,\r\n    right: 0,\r\n    bottom: 0,\r\n    left: 0,\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n  },\r\n  progressText: {\r\n    textAlign: 'center',\r\n  },\r\n  emptyState: {\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    paddingVertical: spacing.xl,\r\n    gap: spacing.md,\r\n  },\r\n  emptyIconContainer: {\r\n    width: 56,\r\n    height: 56,\r\n    borderRadius: radius.full,\r\n    backgroundColor: colors.accent.orangeMuted,\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n  },\r\n  emptyText: {\r\n    textAlign: 'center',\r\n  },\r\n  dotsContainer: {\r\n    flexDirection: 'row',\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n    gap: spacing.sm,\r\n    paddingTop: spacing.sm,\r\n  },\r\n  dotHitArea: {\r\n    padding: spacing.xs,\r\n  },\r\n  dot: {\r\n    width: 8,\r\n    height: 8,\r\n    borderRadius: 4,\r\n  },\r\n  dotActive: {\r\n    backgroundColor: colors.accent.orange,\r\n  },\r\n  dotInactive: {\r\n    backgroundColor: colors.accent.orangeMuted,\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\WeeklyScheduleEditor.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Button' is defined but never used.","line":10,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SurfaceCard' is defined but never used.","line":11,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isRest' is assigned a value but never used.","line":137,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":137,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * WeeklyScheduleEditor\r\n * Edit weekly schedule - assign workouts to days of the week.\r\n */\r\nimport React, { useCallback, useState } from 'react';\r\nimport { Modal, Pressable, ScrollView, StyleSheet, View } from 'react-native';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { Button } from '@/components/atoms/Button';\r\nimport { SurfaceCard } from '@/components/atoms/SurfaceCard';\r\nimport { IconSymbol } from '@/components/ui/icon-symbol';\r\nimport { colors, radius, spacing } from '@/constants/theme';\r\nimport type { WeeklyScheduleConfig, Weekday, ProgramWorkout } from '@/types/premadePlan';\r\n\r\ninterface WeeklyScheduleEditorProps {\r\n  schedule: WeeklyScheduleConfig;\r\n  workouts: ProgramWorkout[];\r\n  onChange: (schedule: WeeklyScheduleConfig) => void;\r\n}\r\n\r\nconst WEEKDAYS: { key: Weekday; label: string; short: string }[] = [\r\n  { key: 'monday', label: 'Monday', short: 'Mon' },\r\n  { key: 'tuesday', label: 'Tuesday', short: 'Tue' },\r\n  { key: 'wednesday', label: 'Wednesday', short: 'Wed' },\r\n  { key: 'thursday', label: 'Thursday', short: 'Thu' },\r\n  { key: 'friday', label: 'Friday', short: 'Fri' },\r\n  { key: 'saturday', label: 'Saturday', short: 'Sat' },\r\n  { key: 'sunday', label: 'Sunday', short: 'Sun' },\r\n];\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    gap: spacing.sm,\r\n  },\r\n  dayRow: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'space-between',\r\n    paddingVertical: spacing.sm,\r\n    paddingHorizontal: spacing.md,\r\n    borderRadius: radius.md,\r\n    backgroundColor: colors.surface.card,\r\n    borderWidth: 1,\r\n    borderColor: colors.border.light,\r\n  },\r\n  dayLabel: {\r\n    minWidth: 80,\r\n  },\r\n  workoutButton: {\r\n    flex: 1,\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'flex-end',\r\n    gap: spacing.xs,\r\n  },\r\n  restDay: {\r\n    opacity: 1,\r\n  },\r\n  modalOverlay: {\r\n    flex: 1,\r\n    backgroundColor: colors.overlay.scrim,\r\n    justifyContent: 'flex-end',\r\n  },\r\n  modalContent: {\r\n    backgroundColor: colors.primary.bg,\r\n    borderTopLeftRadius: radius.xl,\r\n    borderTopRightRadius: radius.xl,\r\n    paddingTop: spacing.lg,\r\n    paddingBottom: spacing.xl,\r\n    maxHeight: '70%',\r\n  },\r\n  modalHeader: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'space-between',\r\n    paddingHorizontal: spacing.lg,\r\n    marginBottom: spacing.md,\r\n  },\r\n  modalList: {\r\n    paddingHorizontal: spacing.lg,\r\n  },\r\n  workoutOption: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'space-between',\r\n    paddingVertical: spacing.md,\r\n    paddingHorizontal: spacing.md,\r\n    marginBottom: spacing.sm,\r\n    borderRadius: radius.md,\r\n    backgroundColor: colors.surface.card,\r\n    borderWidth: 1,\r\n    borderColor: colors.border.light,\r\n  },\r\n  workoutOptionSelected: {\r\n    borderColor: colors.accent.primary,\r\n    backgroundColor: colors.surface.tint,\r\n  },\r\n  restOption: {\r\n    borderStyle: 'dashed',\r\n  },\r\n});\r\n\r\nexport const WeeklyScheduleEditor: React.FC<WeeklyScheduleEditorProps> = ({\r\n  schedule,\r\n  workouts,\r\n  onChange,\r\n}) => {\r\n  const [selectedDay, setSelectedDay] = useState<Weekday | null>(null);\r\n\r\n  const handleDayPress = useCallback((day: Weekday) => {\r\n    triggerHaptic('selection');\r\n    setSelectedDay(day);\r\n  }, []);\r\n\r\n  const handleSelectWorkout = useCallback((workoutId: string | null) => {\r\n    if (!selectedDay) return;\r\n    \r\n    triggerHaptic('selection');\r\n    onChange({\r\n      ...schedule,\r\n      [selectedDay]: workoutId,\r\n    });\r\n    setSelectedDay(null);\r\n  }, [selectedDay, schedule, onChange]);\r\n\r\n  const getWorkoutName = useCallback((workoutId: string | null) => {\r\n    if (!workoutId) return 'Rest Day';\r\n    const workout = workouts.find(w => w.id === workoutId);\r\n    return workout?.name || 'Unknown';\r\n  }, [workouts]);\r\n\r\n  return (\r\n    <View style={styles.container}>\r\n      {WEEKDAYS.map(({ key, label }) => {\r\n        const workoutId = schedule[key];\r\n        const isRest = !workoutId;\r\n\r\n        return (\r\n          <Pressable\r\n            key={key}\r\n            style={styles.dayRow}\r\n            onPress={() => handleDayPress(key)}\r\n          >\r\n            <Text variant=\"bodySemibold\" color=\"primary\" style={styles.dayLabel}>\r\n              {label}\r\n            </Text>\r\n            <View style={styles.workoutButton}>\r\n              <Text \r\n                variant=\"bodySemibold\" \r\n                color=\"primary\"\r\n                numberOfLines={1}\r\n              >\r\n                {getWorkoutName(workoutId)}\r\n              </Text>\r\n              <IconSymbol \r\n                name=\"chevron-right\" \r\n                size={16} \r\n                color={colors.text.primary} \r\n              />\r\n            </View>\r\n          </Pressable>\r\n        );\r\n      })}\r\n\r\n      <Modal\r\n        visible={selectedDay !== null}\r\n        transparent\r\n        animationType=\"slide\"\r\n        onRequestClose={() => setSelectedDay(null)}\r\n      >\r\n        <Pressable \r\n          style={styles.modalOverlay}\r\n          onPress={() => setSelectedDay(null)}\r\n        >\r\n          <Pressable \r\n            style={styles.modalContent}\r\n            onPress={e => e.stopPropagation()}\r\n          >\r\n            <View style={styles.modalHeader}>\r\n              <Text variant=\"heading3\" color=\"primary\">\r\n                {selectedDay ? WEEKDAYS.find(d => d.key === selectedDay)?.label : ''}\r\n              </Text>\r\n              <Pressable onPress={() => setSelectedDay(null)} hitSlop={8}>\r\n                <IconSymbol name=\"close\" size={24} color={colors.text.secondary} />\r\n              </Pressable>\r\n            </View>\r\n\r\n            <ScrollView style={styles.modalList}>\r\n              {/* Rest Day Option */}\r\n              <Pressable\r\n                style={[\r\n                  styles.workoutOption,\r\n                  styles.restOption,\r\n                  selectedDay && !schedule[selectedDay] && styles.workoutOptionSelected,\r\n                ]}\r\n                onPress={() => handleSelectWorkout(null)}\r\n              >\r\n                <Text variant=\"body\" color=\"primary\">Rest Day</Text>\r\n                {selectedDay && !schedule[selectedDay] && (\r\n                  <IconSymbol name=\"check\" size={20} color={colors.accent.primary} />\r\n                )}\r\n              </Pressable>\r\n\r\n              {/* Workout Options */}\r\n              {workouts\r\n                .filter(w => w.exercises.length > 0) // Filter out \"Rest Day\" placeholders\r\n                .map(workout => {\r\n                const isSelected = selectedDay && schedule[selectedDay] === workout.id;\r\n                \r\n                return (\r\n                  <Pressable\r\n                    key={workout.id}\r\n                    style={[\r\n                      styles.workoutOption,\r\n                      isSelected && styles.workoutOptionSelected,\r\n                    ]}\r\n                    onPress={() => handleSelectWorkout(workout.id)}\r\n                  >\r\n                    <View>\r\n                      <Text variant=\"bodySemibold\" color=\"primary\">\r\n                        {workout.name}\r\n                      </Text>\r\n                      <Text variant=\"caption\" color=\"secondary\">\r\n                        {workout.exercises.length} exercises\r\n                      </Text>\r\n                    </View>\r\n                    {isSelected && (\r\n                      <IconSymbol name=\"check\" size={20} color={colors.accent.primary} />\r\n                    )}\r\n                  </Pressable>\r\n                );\r\n              })}\r\n            </ScrollView>\r\n          </Pressable>\r\n        </Pressable>\r\n      </Modal>\r\n    </View>\r\n  );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\WeeklyVolumeChart.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'l2ToL1' is assigned a value but never used.","line":61,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":61,"endColumn":35},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'barWidth' is assigned a value but never used.","line":146,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":146,"endColumn":23},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useMemo has an unnecessary dependency: 'weightUnit'. Either exclude it or remove the dependency array.","line":358,"column":8,"nodeType":"ArrayExpression","endLine":358,"endColumn":45,"suggestions":[{"desc":"Update the dependencies array to be: [workouts, convertWeight]","fix":{"range":[14947,14984],"text":"[workouts, convertWeight]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useMemo, useState, useEffect, useCallback, useRef } from 'react';\r\nimport { View, Dimensions, StyleSheet, ScrollView, NativeSyntheticEvent, NativeScrollEvent, TouchableOpacity } from 'react-native';\r\nimport { VictoryChart, VictoryBar, VictoryAxis, VictoryTheme } from 'victory-native';\r\nimport { useFocusEffect } from '@react-navigation/native';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { colors, spacing, radius } from '@/constants/theme';\r\nimport { useWorkoutSessionsStore } from '@/store/workoutSessionsStore';\r\nimport { useSettingsStore } from '@/store/settingsStore';\r\n\r\n// Import data\r\nimport exercisesData from '@/data/exercises.json';\r\nimport hierarchyData from '@/data/hierarchy.json';\r\n\r\nconst SCREEN_WIDTH = Dimensions.get('window').width;\r\nconst CHART_WIDTH = SCREEN_WIDTH - spacing.xl * 2; // Match FocusDistributionChart width\r\n\r\n// Fixed chart heights for consistent layout\r\nconst CHART_CONTENT_HEIGHT = 250; // VictoryChart height\r\nconst TITLE_HEIGHT = 30; // Approximate title height\r\nconst CHART_CONTAINER_HEIGHT = CHART_CONTENT_HEIGHT + TITLE_HEIGHT + spacing.sm * 2;\r\n\r\n// Build Maps - handles up to 4 levels (high -> mid -> low -> detailed)\r\nconst buildMaps = () => {\r\n    const leafToL1: Record<string, string> = {}; // Specific -> Body Part (Upper/Lower/Core)\r\n    const leafToL2: Record<string, string> = {}; // Specific -> Muscle Group (Chest/Back/etc)\r\n    const l2ToL1: Record<string, string> = {}; // Muscle Group -> Body Part\r\n\r\n    const hierarchy = hierarchyData.muscle_hierarchy;\r\n\r\n    Object.entries(hierarchy).forEach(([l1, l1Data]) => {\r\n        if (l1Data?.muscles) {\r\n            Object.entries(l1Data.muscles).forEach(([l2, l2Data]: [string, any]) => {\r\n                // l2 is \"Chest\", \"Arms\", \"Calves\", etc.\r\n                leafToL1[l2] = l1;\r\n                leafToL2[l2] = l2;\r\n                l2ToL1[l2] = l1;\r\n\r\n                if (l2Data?.muscles) {\r\n                    Object.entries(l2Data.muscles).forEach(([l3, l3Data]: [string, any]) => {\r\n                        // l3 could be \"Upper Chest\" (low), \"Biceps\" (low with children), or \"Medial Head\" (detailed under Calves)\r\n                        leafToL1[l3] = l1;\r\n                        leafToL2[l3] = l2;\r\n\r\n                        // Handle L4 (detailed level, e.g., Long Head under Biceps)\r\n                        if (l3Data?.muscles) {\r\n                            Object.keys(l3Data.muscles).forEach(l4 => {\r\n                                leafToL1[l4] = l1;\r\n                                leafToL2[l4] = l2;\r\n                            });\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n    });\r\n\r\n    return { leafToL1, leafToL2, l2ToL1 };\r\n};\r\n\r\nconst { leafToL1, leafToL2, l2ToL1 } = buildMaps();\r\n\r\nconst EXERCISE_NAME_TO_MUSCLES = exercisesData.reduce((acc, ex) => {\r\n    if (ex.muscles) {\r\n        acc[ex.name] = ex.muscles as unknown as Record<string, number>;\r\n    }\r\n    return acc;\r\n}, {} as Record<string, Record<string, number>>);\r\n\r\ninterface ChartPageProps {\r\n    title: string;\r\n    data: {\r\n        labels: string[];\r\n        values: number[];\r\n    };\r\n    selectedBar: { label: string; value: number } | null;\r\n    setSelectedBar: (bar: { label: string; value: number } | null) => void;\r\n    formatWeight: (lbs: number) => string;\r\n}\r\n\r\nconst ChartPage: React.FC<ChartPageProps> = ({ title, data, selectedBar, setSelectedBar, formatWeight }) => {\r\n    // Calculate Max Value and Y-axis ticks\r\n    const rawMax = Math.max(...data.values, 0);\r\n\r\n    // Allowed increment values\r\n    const allowedIncrements = [\r\n        0.1, 0.25, 0.5, 1, 2.5, 5, 10, 25, 50, 100, 200, 250, 300, 400, 500,\r\n        1000, 2000, 2500, 3000, 4000, 5000, 10000, 20000, 25000, 50000, 100000\r\n    ];\r\n\r\n    let targetMax = 10;\r\n    let increment = 2.5;\r\n\r\n    if (rawMax > 0) {\r\n        // Find the best increment that gives us 2-5 segments\r\n        for (const inc of allowedIncrements) {\r\n            const segs = Math.ceil(rawMax / inc);\r\n            if (segs >= 2 && segs <= 5) {\r\n                targetMax = segs * inc;\r\n                increment = inc;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Fallback: if no increment gives 2-5 segments, use the last one that fits\r\n        if (targetMax < rawMax) {\r\n            for (const inc of allowedIncrements) {\r\n                const segs = Math.ceil(rawMax / inc);\r\n                if (segs <= 5) {\r\n                    targetMax = segs * inc;\r\n                    increment = inc;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Generate Y-axis tick values\r\n    const yTickValues: number[] = [];\r\n    for (let i = 0; i <= targetMax; i += increment) {\r\n        yTickValues.push(i);\r\n    }\r\n\r\n    // Prepare chart data\r\n    const chartData = data.labels.map((label, index) => ({\r\n        x: label,\r\n        y: data.values[index] || 0,\r\n    }));\r\n\r\n    // Calculate tooltip position based on selected bar value and position\r\n    const getTooltipPosition = () => {\r\n        if (!selectedBar) return { top: 10, left: 0 };\r\n\r\n        const chartHeight = 250;\r\n        const chartWidth = CHART_WIDTH;\r\n        const chartPadding = { top: 20, bottom: 40, left: 40, right: 40 };\r\n        const usableHeight = chartHeight - chartPadding.top - chartPadding.bottom;\r\n        const usableWidth = chartWidth - chartPadding.left - chartPadding.right;\r\n        const maxValue = Math.max(...data.values, 1);\r\n\r\n        // Find the index of the selected bar\r\n        const barIndex = data.labels.indexOf(selectedBar.label);\r\n        const numBars = data.labels.length;\r\n\r\n        // Calculate bar position (center of the bar)\r\n        const barWidth = 32; // VictoryBar width from style\r\n        const domainPadding = 40; // domainPadding from VictoryChart\r\n        const barSpacing = (usableWidth - domainPadding * 2) / numBars;\r\n        const barCenterX = chartPadding.left + domainPadding + (barIndex * barSpacing) + (barSpacing / 2);\r\n\r\n        // Calculate vertical position (just above the bar top)\r\n        const barHeight = (selectedBar.value / maxValue) * usableHeight;\r\n        const tooltipTop = chartPadding.top + usableHeight - barHeight - 25; // 25px above bar top\r\n\r\n        return {\r\n            top: Math.max(chartPadding.top, tooltipTop),\r\n            left: barCenterX,\r\n        };\r\n    };\r\n\r\n    return (\r\n        <View style={styles.pageContainer}>\r\n            <Text variant=\"heading3\" color=\"primary\" style={styles.chartTitle}>{title}</Text>\r\n            <View style={styles.chartContainer}>\r\n                <VictoryChart\r\n                    theme={VictoryTheme.material}\r\n                    domainPadding={{ x: 40 }}\r\n                    padding={{ top: 20, bottom: 40, left: 40, right: 40 }}\r\n                    height={250}\r\n                    width={CHART_WIDTH}\r\n                >\r\n                    <VictoryAxis\r\n                        tickValues={data.labels}\r\n                        fixLabelOverlap\r\n                        style={{\r\n                            axis: { stroke: 'none' },\r\n                            tickLabels: { fill: colors.text.primary, fontSize: 9, padding: 3 },\r\n                            grid: { stroke: 'none' }\r\n                        }}\r\n                    />\r\n                    <VictoryAxis\r\n                        dependentAxis\r\n                        tickValues={yTickValues}\r\n                        tickFormat={(t) => `${Math.round(t)}`}\r\n                        style={{\r\n                            axis: { stroke: 'none' },\r\n                            tickLabels: { fill: colors.text.secondary, fontSize: 10, padding: 5 },\r\n                            grid: { stroke: colors.neutral.gray200, strokeDasharray: '4, 4' }\r\n                        }}\r\n                    />\r\n                    <VictoryBar\r\n                        data={chartData}\r\n                        style={{\r\n                            data: {\r\n                                fill: '#FF5500',\r\n                                width: 32,\r\n                            }\r\n                        }}\r\n                        cornerRadius={{ top: 6 }}\r\n                        animate={{\r\n                            duration: 500,\r\n                            onLoad: { duration: 500 }\r\n                        }}\r\n                        events={[{\r\n                            target: \"data\",\r\n                            eventHandlers: {\r\n                                onPressIn: () => {\r\n                                    return [\r\n                                        {\r\n                                            target: \"data\",\r\n                                            mutation: (props) => {\r\n                                                const barData = {\r\n                                                    label: props.datum.x,\r\n                                                    value: props.datum.y\r\n                                                };\r\n                                                // Toggle: if same bar is selected, close it; otherwise show new bar\r\n                                                const newBarData = selectedBar?.label === barData.label ? null : barData;\r\n                                                setSelectedBar(newBarData);\r\n                                                return null;\r\n                                            }\r\n                                        }\r\n                                    ];\r\n                                }\r\n                            }\r\n                        }]}\r\n                    />\r\n                </VictoryChart>\r\n\r\n                {/* Tooltip */}\r\n                {selectedBar && (\r\n                    <View style={[styles.tooltip, getTooltipPosition()]}>\r\n                        <Text variant=\"caption\" color=\"primary\" style={styles.tooltipText}>\r\n                            {selectedBar.label}: {formatWeight(selectedBar.value)}\r\n                        </Text>\r\n                    </View>\r\n                )}\r\n            </View>\r\n\r\n            {/* Transparent overlay to capture taps anywhere on screen */}\r\n            {selectedBar && (\r\n                <TouchableOpacity\r\n                    style={styles.fullScreenOverlay}\r\n                    onPress={() => setSelectedBar(null)}\r\n                    activeOpacity={1}\r\n                />\r\n            )}\r\n        </View>\r\n    );\r\n};\r\n\r\nexport const WeeklyVolumeChart: React.FC = () => {\r\n    const workouts = useWorkoutSessionsStore((state) => state.workouts);\r\n    // Subscribe to weightUnit to trigger re-renders when units change\r\n    const weightUnit = useSettingsStore((state) => state.weightUnit);\r\n    const { formatWeight, getWeightUnit, convertWeight } = useSettingsStore();\r\n    const [currentPage, setCurrentPage] = useState(0);\r\n    // Per-page selected bar state to prevent cross-page artifacts\r\n    const [selectedBars, setSelectedBars] = useState<Record<number, { label: string; value: number } | null>>({});\r\n    const scrollViewRef = useRef<ScrollView>(null);\r\n\r\n    // Get selected bar for current page\r\n    const selectedBar = selectedBars[currentPage] || null;\r\n    const setSelectedBar = useCallback((bar: { label: string; value: number } | null) => {\r\n        setSelectedBars(prev => ({ ...prev, [currentPage]: bar }));\r\n    }, [currentPage]);\r\n\r\n    // Clear selected bar when switching pages\r\n    useEffect(() => {\r\n        // Clear all selections when page changes to ensure clean state\r\n        setSelectedBars({});\r\n    }, [currentPage]);\r\n\r\n    // Reset state when user returns to the performance tab\r\n    useFocusEffect(\r\n        useCallback(() => {\r\n            setCurrentPage(0);\r\n            setSelectedBars({});\r\n            scrollViewRef.current?.scrollTo({ x: 0, animated: false });\r\n        }, [])\r\n    );\r\n\r\n    const { dataL1, dataUpper, dataLower, dataCore, hasData } = useMemo(() => {\r\n        const volumeL1: Record<string, number> = {\r\n            'Upper Body': 0,\r\n            'Lower Body': 0,\r\n            'Core': 0,\r\n        };\r\n        const volumeL2: Record<string, number> = {};\r\n\r\n        // Filter for last 7 days\r\n        const now = new Date();\r\n        const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\r\n\r\n        const recentWorkouts = workouts.filter(w => {\r\n            const wDate = new Date(w.date);\r\n            return wDate >= oneWeekAgo && wDate <= now;\r\n        });\r\n\r\n        recentWorkouts.forEach(workout => {\r\n            workout.exercises.forEach(exercise => {\r\n                const weights = EXERCISE_NAME_TO_MUSCLES[exercise.name];\r\n                if (!weights) return;\r\n\r\n                exercise.sets.forEach(set => {\r\n                    if (!set.completed || (set.weight ?? 0) <= 0 || (set.reps ?? 0) <= 0) return;\r\n\r\n                    const setVolume = convertWeight((set.weight ?? 0) * (set.reps ?? 0));\r\n\r\n                    Object.entries(weights).forEach(([muscle, weight]) => {\r\n                        const contribution = setVolume * weight;\r\n\r\n                        // L1 Accumulation\r\n                        const cat1 = leafToL1[muscle];\r\n                        if (cat1 && volumeL1[cat1] !== undefined) {\r\n                            volumeL1[cat1] += contribution;\r\n                        }\r\n\r\n                        // L2 Accumulation\r\n                        const cat2 = leafToL2[muscle];\r\n                        if (cat2) {\r\n                            volumeL2[cat2] = (volumeL2[cat2] || 0) + contribution;\r\n                        }\r\n                    });\r\n                });\r\n            });\r\n        });\r\n\r\n        const formatData = (labels: string[], values: number[]) => ({\r\n            labels,\r\n            values: values.map(v => Math.round(v))\r\n        });\r\n\r\n        // L1 Data\r\n        const dataL1 = formatData(\r\n            ['Upper\\nBody', 'Lower\\nBody', 'Core'],\r\n            [volumeL1['Upper Body'], volumeL1['Lower Body'], volumeL1['Core']]\r\n        );\r\n\r\n        // Helper to get L2 data for a specific L1 parent\r\n        const getL2Data = (parentL1: string) => {\r\n            const muscles = Object.keys(hierarchyData.muscle_hierarchy[parentL1 as keyof typeof hierarchyData.muscle_hierarchy].muscles);\r\n            const values = muscles.map(m => volumeL2[m] || 0);\r\n            const labels = muscles.map(m => {\r\n                if (m === 'Hip Stabilizers') return 'Hips';\r\n                if (m === 'Hamstrings') return 'Hams';\r\n                return m;\r\n            });\r\n            return formatData(labels, values);\r\n        };\r\n\r\n        const dataUpper = getL2Data('Upper Body');\r\n        const dataLower = getL2Data('Lower Body');\r\n        const dataCore = getL2Data('Core');\r\n\r\n        const hasData = [volumeL1, volumeL2].some(dict => Object.values(dict).some(v => v > 0));\r\n\r\n        return { dataL1, dataUpper, dataLower, dataCore, hasData };\r\n    }, [workouts, convertWeight, weightUnit]);\r\n\r\n    const handleMomentumScrollEnd = (event: NativeSyntheticEvent<NativeScrollEvent>) => {\r\n        const contentOffsetX = event.nativeEvent.contentOffset.x;\r\n        const pageIndex = Math.round(contentOffsetX / CHART_WIDTH);\r\n        if (pageIndex !== currentPage) {\r\n            setCurrentPage(pageIndex);\r\n        }\r\n    };\r\n\r\n    const handleScrollEndDrag = (event: NativeSyntheticEvent<NativeScrollEvent>) => {\r\n        const { contentOffset, velocity, targetContentOffset } = event.nativeEvent;\r\n\r\n        // 1. Trust the OS prediction if available (iOS mostly)\r\n        if (targetContentOffset) {\r\n            const targetPage = Math.round(targetContentOffset.x / CHART_WIDTH);\r\n            if (targetPage !== currentPage) {\r\n                setCurrentPage(targetPage);\r\n            }\r\n            return;\r\n        }\r\n\r\n        // 2. Fallback for Android/others: Predict based on velocity + position\r\n        let targetPage = currentPage;\r\n        const currentPosition = contentOffset.x / CHART_WIDTH;\r\n\r\n        if (velocity && Math.abs(velocity.x) > 0.2) {\r\n            if (velocity.x > 0) {\r\n                targetPage = Math.ceil(currentPosition);\r\n            } else {\r\n                targetPage = Math.floor(currentPosition);\r\n            }\r\n        } else {\r\n            targetPage = Math.round(currentPosition);\r\n        }\r\n\r\n        // Clamp to valid page range (0-3)\r\n        targetPage = Math.max(0, Math.min(3, targetPage));\r\n\r\n        if (targetPage !== currentPage) {\r\n            setCurrentPage(targetPage);\r\n        }\r\n    };\r\n\r\n    if (!hasData) {\r\n        return (\r\n            <View style={styles.emptyContainer}>\r\n                <Text variant=\"body\" color=\"secondary\" style={{ textAlign: 'center' }}>No workout data available yet.</Text>\r\n            </View>\r\n        );\r\n    }\r\n\r\n    return (\r\n        <View style={styles.container}>\r\n            <View style={styles.pagination}>\r\n                {[0, 1, 2, 3].map((index) => (\r\n                    <View\r\n                        key={index}\r\n                        style={[\r\n                            styles.dot,\r\n                            index === currentPage ? styles.activeDot : styles.inactiveDot\r\n                        ]}\r\n                    />\r\n                ))}\r\n            </View>\r\n\r\n            <View style={styles.chartWrapper}>\r\n                <ScrollView\r\n                    ref={scrollViewRef}\r\n                    horizontal\r\n                    pagingEnabled\r\n                    showsHorizontalScrollIndicator={false}\r\n                    onMomentumScrollEnd={handleMomentumScrollEnd}\r\n                    onScrollEndDrag={handleScrollEndDrag}\r\n                    style={{ width: CHART_WIDTH }}\r\n                    contentContainerStyle={{ alignItems: 'flex-start' }}\r\n                >\r\n                    <ChartPage title={`Total Volume (${getWeightUnit()})`} data={dataL1} selectedBar={selectedBar} setSelectedBar={setSelectedBar} formatWeight={formatWeight} />\r\n                    <ChartPage title=\"Upper Body\" data={dataUpper} selectedBar={selectedBar} setSelectedBar={setSelectedBar} formatWeight={formatWeight} />\r\n                    <ChartPage title=\"Lower Body\" data={dataLower} selectedBar={selectedBar} setSelectedBar={setSelectedBar} formatWeight={formatWeight} />\r\n                    <ChartPage title=\"Core\" data={dataCore} selectedBar={selectedBar} setSelectedBar={setSelectedBar} formatWeight={formatWeight} />\r\n                </ScrollView>\r\n            </View>\r\n        </View>\r\n    );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n    container: {\r\n        alignItems: 'center',\r\n        justifyContent: 'center',\r\n        width: '100%',\r\n    },\r\n    chartWrapper: {\r\n        overflow: 'hidden',\r\n        height: CHART_CONTAINER_HEIGHT,\r\n    },\r\n    pageContainer: {\r\n        width: CHART_WIDTH,\r\n        height: CHART_CONTAINER_HEIGHT,\r\n        alignItems: 'center',\r\n        justifyContent: 'flex-start',\r\n    },\r\n    chartContainer: {\r\n        alignItems: 'center',\r\n        justifyContent: 'center',\r\n    },\r\n    chartTitle: {\r\n        marginBottom: spacing.sm,\r\n        textAlign: 'center',\r\n    },\r\n    emptyContainer: {\r\n        padding: spacing.sm,\r\n        alignItems: 'center',\r\n        minHeight: 60,\r\n    },\r\n    pagination: {\r\n        flexDirection: 'row',\r\n        marginBottom: spacing.md,\r\n        gap: spacing.sm,\r\n    },\r\n    dot: {\r\n        width: 8,\r\n        height: 8,\r\n        borderRadius: radius.full,\r\n    },\r\n    activeDot: {\r\n        backgroundColor: colors.accent.primary,\r\n    },\r\n    inactiveDot: {\r\n        backgroundColor: colors.neutral.gray400,\r\n    },\r\n    tooltip: {\r\n        position: 'absolute',\r\n        backgroundColor: 'rgba(255, 255, 255, 0.9)',\r\n        paddingHorizontal: spacing.xs,\r\n        paddingVertical: 2,\r\n        borderRadius: radius.sm,\r\n        transform: [{ translateX: -50 }], // Center the tooltip on the calculated position\r\n    },\r\n    tooltipText: {\r\n        textAlign: 'center',\r\n    },\r\n    fullScreenOverlay: {\r\n        position: 'absolute',\r\n        top: 0,\r\n        left: 0,\r\n        right: 0,\r\n        bottom: 0,\r\n        backgroundColor: 'transparent',\r\n    },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\WorkoutBuilderCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\WorkoutCarousel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\WorkoutExerciseSummaryCard.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'weightUnit' is assigned a value but never used.","line":89,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":89,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'distanceUnitPref' is assigned a value but never used.","line":90,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":90,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * WorkoutExerciseSummaryCard\n * Molecule component that visualizes an exercise with its logged sets.\n */\n\nimport React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport Animated, { Layout } from 'react-native-reanimated';\n\nimport { Text } from '@/components/atoms/Text';\nimport { SurfaceCard } from '@/components/atoms/SurfaceCard';\nimport { colors, radius, spacing, sizing } from '@/constants/theme';\nimport { exercises as exerciseCatalog } from '@/constants/exercises';\nimport type { WorkoutExercise, SetLog } from '@/types/workout';\nimport type { ExerciseType } from '@/types/exercise';\nimport { useSettingsStore } from '@/store/settingsStore';\n\ninterface WorkoutExerciseSummaryCardProps {\n  exercise: WorkoutExercise;\n  index: number;\n}\n\n/**\n * Format duration in seconds to a readable string\n * Uses hr, min, s for clarity (not m which could be confused with meters)\n */\nconst formatDuration = (seconds: number): string => {\n  if (seconds >= 3600) {\n    const hrs = Math.floor(seconds / 3600);\n    const mins = Math.floor((seconds % 3600) / 60);\n    const secs = seconds % 60;\n    if (mins === 0 && secs === 0) return `${hrs} hr`;\n    if (secs === 0) return `${hrs} hr ${mins} min`;\n    return `${hrs} hr ${mins} min ${secs} s`;\n  }\n  if (seconds >= 60) {\n    const mins = Math.floor(seconds / 60);\n    const secs = seconds % 60;\n    return secs > 0 ? `${mins} min ${secs} s` : `${mins} min`;\n  }\n  return `${seconds} s`;\n};\n\n/**\n * Get the effort label for a set based on exercise type\n * For cardio: distance on left, time on right\n */\nconst getSetEffortLabel = (\n  set: SetLog,\n  exerciseType: ExerciseType,\n  formatWeight: (lbs: number) => string,\n  formatDistanceForExercise: (miles: number, distanceUnit?: 'miles' | 'meters' | 'floors') => string,\n  distanceUnit?: 'miles' | 'meters' | 'floors'\n): string => {\n  switch (exerciseType) {\n    case 'cardio':\n      const distance = formatDistanceForExercise(set.distance ?? 0, distanceUnit);\n      const duration = set.duration ? formatDuration(set.duration) : '0min';\n      return `${distance}  ${duration}`;\n    \n    case 'duration':\n      return formatDuration(set.duration ?? 0);\n    \n    case 'bodyweight':\n    case 'reps_only':\n      return `${set.reps ?? 0} reps`;\n    \n    case 'assisted':\n      return `${formatWeight(set.assistanceWeight ?? 0)} assist  ${set.reps ?? 0} reps`;\n    \n    case 'weight':\n    default:\n      return `${formatWeight(set.weight ?? 0)}  ${set.reps ?? 0} reps`;\n  }\n};\n\n/**\n * WorkoutExerciseSummaryCard\n * Displays an exercise name alongside its logged sets and completion state.\n *\n * @param exercise - The exercise data with sets to render.\n * @param index - Index for display ordering.\n */\nexport const WorkoutExerciseSummaryCard: React.FC<WorkoutExerciseSummaryCardProps> = ({\n  exercise,\n  index,\n}) => {\n  // Subscribe to unit values to trigger re-renders when units change\n  const weightUnit = useSettingsStore((state) => state.weightUnit);\n  const distanceUnitPref = useSettingsStore((state) => state.distanceUnit);\n  const { formatWeight, formatDistanceForExercise } = useSettingsStore();\n  // Look up exercise type from catalog\n  const catalogEntry = exerciseCatalog.find(e => e.name === exercise.name);\n  const exerciseType: ExerciseType = catalogEntry?.exerciseType || 'weight';\n  const exerciseDistanceUnit = catalogEntry?.distanceUnit;\n\n  // Only show completed sets in the summary\n  const completedSets = exercise.sets\n    .map((set, originalIndex) => ({ set, originalIndex }))\n    .filter(({ set }) => set.completed);\n\n  // Don't render the card if no sets were completed\n  if (completedSets.length === 0) {\n    return null;\n  }\n\n  return (\n    <Animated.View layout={Layout.springify()} style={styles.wrapper}>\n      <SurfaceCard tone=\"card\" padding=\"lg\" showAccentStripe={false} style={styles.card}>\n        <View style={styles.header}>\n          <View style={styles.titleGroup}>\n            <Text style={{ fontSize: 18, fontWeight: '500', color: colors.text.primary }}>\n              {exercise.name}\n            </Text>\n          </View>\n        </View>\n\n        <View style={styles.setList}>\n          {completedSets.map(({ set, originalIndex }, displayIndex) => {\n            const effortLabel = getSetEffortLabel(set, exerciseType, formatWeight, formatDistanceForExercise, exerciseDistanceUnit);\n\n            return (\n              <View key={`${exercise.name}-${originalIndex}`} style={styles.setRow}>\n                <View style={styles.setCircle}>\n                  <Text variant=\"bodySemibold\" style={styles.setCircleText}>\n                    {displayIndex + 1}\n                  </Text>\n                </View>\n                <Text variant=\"bodySemibold\" color=\"primary\" style={styles.setEffort}>\n                  {effortLabel}\n                </Text>\n              </View>\n            );\n          })}\n        </View>\n      </SurfaceCard>\n    </Animated.View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  wrapper: {\n    width: '100%',\n  },\n  card: {\n    gap: spacing.md,\n  },\n  header: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n  },\n  titleGroup: {\n    flex: 1,\n    gap: spacing.xs,\n    flexShrink: 1,\n  },\n  setList: {\n    gap: spacing.sm,\n  },\n  setRow: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'flex-start',\n    paddingVertical: spacing.xs,\n    paddingHorizontal: spacing.sm,\n    gap: spacing.md,\n  },\n  setCircle: {\n    width: sizing.iconLG,\n    height: sizing.iconLG,\n    borderRadius: radius.full,\n    backgroundColor: colors.surface.card,\n    borderWidth: 1,\n    borderColor: colors.accent.orange,\n    justifyContent: 'center',\n    alignItems: 'center',\n    flexShrink: 0,\n    display: 'flex',\n  },\n  setCircleText: {\n    color: colors.text.primary,\n    fontSize: 16,\n    fontWeight: '600',\n    lineHeight: 16,\n    textAlign: 'center',\n    includeFontPadding: false,\n  },\n  setEffort: {\n    flex: 1,\n    fontSize: 16,\n    fontWeight: '600',\n    lineHeight: 32,\n    includeFontPadding: false,\n  },\n});\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\WorkoutFilters.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'contentHeight' is assigned a value but never used.","line":76,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":76,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * WorkoutFilters\r\n * Modern collapsible filter section with horizontal scrolling chips\r\n * Inspired by industry-leading fitness apps for seamless UX\r\n */\r\nimport React, { useState } from 'react';\r\nimport { ScrollView, StyleSheet, View, Pressable } from 'react-native';\r\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring, withTiming, Easing } from 'react-native-reanimated';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { QuickFilterChip } from '@/components/atoms/QuickFilterChip';\r\nimport { FilterChip } from '@/components/atoms/FilterChip';\r\nimport { IconSymbol } from '@/components/ui/icon-symbol';\r\nimport { colors, spacing, radius, shadows } from '@/constants/theme';\r\nimport { springBouncy } from '@/constants/animations';\r\n\r\nexport type WorkoutFilterState = {\r\n  experienceLevel: 'all' | 'beginner' | 'intermediate' | 'advanced';\r\n  equipment: 'all' | 'full-gym' | 'dumbbells-only' | 'bodyweight' | 'minimal-equipment';\r\n  goal: 'all' | 'build-muscle' | 'strength' | 'lose-fat' | 'general-fitness';\r\n  workoutType: 'all' | 'full-body' | 'push' | 'pull' | 'upper-body' | 'lower-body' | 'core-mobility';\r\n  duration: 'all' | 'quick' | 'medium' | 'long';\r\n};\r\n\r\ninterface WorkoutFiltersProps {\r\n  filters: WorkoutFilterState;\r\n  onFiltersChange: (filters: WorkoutFilterState) => void;\r\n  showDurationFilter?: boolean;\r\n  showWorkoutTypeFilter?: boolean;\r\n}\r\n\r\nconst EQUIPMENT_FILTERS = [\r\n  { label: 'All Equipment', value: 'all' as const },\r\n  { label: 'Full Gym', value: 'full-gym' as const },\r\n  { label: 'Dumbbells Only', value: 'dumbbells-only' as const },\r\n  { label: 'Bodyweight', value: 'bodyweight' as const },\r\n  { label: 'Minimal Equipment', value: 'minimal-equipment' as const },\r\n];\r\n\r\nconst GOAL_FILTERS = [\r\n  { label: 'All Goals', value: 'all' as const },\r\n  { label: 'Build Muscle', value: 'build-muscle' as const },\r\n  { label: 'Strength', value: 'strength' as const },\r\n  { label: 'Lose Fat', value: 'lose-fat' as const },\r\n  { label: 'General Fitness', value: 'general-fitness' as const },\r\n];\r\n\r\nconst DURATION_FILTERS = [\r\n  { label: 'All Durations', value: 'all' as const },\r\n  { label: 'Quick (30min)', value: 'quick' as const },\r\n  { label: 'Medium (31-60min)', value: 'medium' as const },\r\n  { label: 'Long (>60min)', value: 'long' as const },\r\n];\r\n\r\nconst WORKOUT_TYPE_FILTERS = [\r\n  { label: 'All Types', value: 'all' as const },\r\n  { label: 'Full Body', value: 'full-body' as const },\r\n  { label: 'Push', value: 'push' as const },\r\n  { label: 'Pull', value: 'pull' as const },\r\n  { label: 'Upper Body', value: 'upper-body' as const },\r\n  { label: 'Lower Body', value: 'lower-body' as const },\r\n  { label: 'Core & Mobility', value: 'core-mobility' as const },\r\n];\r\n\r\nconst EXPERIENCE_FILTERS = [\r\n  { label: 'All Levels', value: 'all' as const },\r\n  { label: 'Beginner', value: 'beginner' as const },\r\n  { label: 'Intermediate', value: 'intermediate' as const },\r\n  { label: 'Advanced', value: 'advanced' as const },\r\n];\r\n\r\nexport const WorkoutFilters: React.FC<WorkoutFiltersProps> = ({ filters, onFiltersChange, showDurationFilter = true, showWorkoutTypeFilter = true }) => {\r\n  const [isExpanded, setIsExpanded] = useState(false);\r\n  const rotation = useSharedValue(0);\r\n  const contentHeight = useSharedValue(0);\r\n  const opacity = useSharedValue(0);\r\n\r\n  const animatedRotationStyle = useAnimatedStyle(() => ({\r\n    transform: [{ rotate: `${rotation.value}deg` }],\r\n  }));\r\n\r\n  const animatedContentStyle = useAnimatedStyle(() => ({\r\n    opacity: opacity.value,\r\n  }));\r\n\r\n  const toggleExpanded = () => {\r\n    triggerHaptic('selection');\r\n    const expanding = !isExpanded;\r\n    setIsExpanded(expanding);\r\n    \r\n    rotation.value = withSpring(expanding ? 180 : 0, springBouncy);\r\n    opacity.value = withTiming(expanding ? 1 : 0, {\r\n      duration: expanding ? 250 : 200,\r\n      easing: Easing.out(Easing.cubic),\r\n    });\r\n  };\r\n\r\n  const updateFilter = (key: keyof WorkoutFilterState, value: string) => {\r\n    onFiltersChange({\r\n      ...filters,\r\n      [key]: value,\r\n    });\r\n  };\r\n\r\n  const getActiveFiltersCount = () => {\r\n    let count = 0;\r\n    if (filters.experienceLevel !== 'all') count++;\r\n    if (filters.equipment !== 'all') count++;\r\n    if (filters.goal !== 'all') count++;\r\n    if (showWorkoutTypeFilter && filters.workoutType !== 'all') count++;\r\n    if (showDurationFilter && filters.duration !== 'all') count++;\r\n    return count;\r\n  };\r\n\r\n  const getFilterLabel = (key: keyof WorkoutFilterState, value: string) => {\r\n    switch (key) {\r\n      case 'experienceLevel':\r\n        return EXPERIENCE_FILTERS.find(f => f.value === value)?.label || value;\r\n      case 'equipment':\r\n        return EQUIPMENT_FILTERS.find(f => f.value === value)?.label || value;\r\n      case 'goal':\r\n        return GOAL_FILTERS.find(f => f.value === value)?.label || value;\r\n      case 'workoutType':\r\n        return WORKOUT_TYPE_FILTERS.find(f => f.value === value)?.label || value;\r\n      case 'duration':\r\n        return DURATION_FILTERS.find(f => f.value === value)?.label || value;\r\n      default:\r\n        return value;\r\n    }\r\n  };\r\n\r\n  const clearFilter = (key: keyof WorkoutFilterState) => {\r\n    updateFilter(key, 'all');\r\n  };\r\n\r\n  const clearAllFilters = () => {\r\n    onFiltersChange({\r\n      experienceLevel: 'all',\r\n      equipment: 'all',\r\n      goal: 'all',\r\n      workoutType: 'all',\r\n      duration: 'all',\r\n    });\r\n  };\r\n\r\n  const activeFiltersCount = getActiveFiltersCount();\r\n\r\n  return (\r\n    <View style={styles.container}>\r\n      {/* Compact header with toggle */}\r\n      <Pressable style={styles.header} onPress={toggleExpanded}>\r\n        <View style={styles.headerContent}>\r\n          <View style={styles.headerLeft}>\r\n            <IconSymbol name=\"filter-list\" size={20} color={colors.accent.primary} />\r\n            <Text variant=\"bodySemibold\" color=\"primary\">Filter</Text>\r\n            {activeFiltersCount > 0 && (\r\n              <View style={styles.badge}>\r\n                <Text variant=\"caption\" color=\"onAccent\" style={styles.badgeText}>{activeFiltersCount}</Text>\r\n              </View>\r\n            )}\r\n          </View>\r\n          <Animated.View style={animatedRotationStyle}>\r\n            <IconSymbol \r\n              name=\"keyboard-arrow-down\" \r\n              size={24} \r\n              color={colors.text.secondary} \r\n            />\r\n          </Animated.View>\r\n        </View>\r\n      </Pressable>\r\n\r\n      {/* Active filters horizontal scroll */}\r\n      {activeFiltersCount > 0 && !isExpanded && (\r\n        <ScrollView \r\n          horizontal \r\n          showsHorizontalScrollIndicator={false}\r\n          style={styles.activeFiltersScroll}\r\n          contentContainerStyle={styles.activeFiltersContent}\r\n        >\r\n          {filters.experienceLevel !== 'all' && (\r\n            <FilterChip\r\n              label={getFilterLabel('experienceLevel', filters.experienceLevel)}\r\n              onRemove={() => clearFilter('experienceLevel')}\r\n            />\r\n          )}\r\n          {filters.equipment !== 'all' && (\r\n            <FilterChip\r\n              label={getFilterLabel('equipment', filters.equipment)}\r\n              onRemove={() => clearFilter('equipment')}\r\n            />\r\n          )}\r\n          {filters.goal !== 'all' && (\r\n            <FilterChip\r\n              label={getFilterLabel('goal', filters.goal)}\r\n              onRemove={() => clearFilter('goal')}\r\n            />\r\n          )}\r\n          {showWorkoutTypeFilter && filters.workoutType !== 'all' && (\r\n            <FilterChip\r\n              label={getFilterLabel('workoutType', filters.workoutType)}\r\n              onRemove={() => clearFilter('workoutType')}\r\n            />\r\n          )}\r\n          {showDurationFilter && filters.duration !== 'all' && (\r\n            <FilterChip\r\n              label={getFilterLabel('duration', filters.duration)}\r\n              onRemove={() => clearFilter('duration')}\r\n            />\r\n          )}\r\n          {activeFiltersCount > 1 && (\r\n            <Pressable onPress={clearAllFilters} style={styles.clearAllChip}>\r\n              <Text variant=\"caption\" color=\"secondary\" style={styles.clearAllText}>Clear All</Text>\r\n            </Pressable>\r\n          )}\r\n        </ScrollView>\r\n      )}\r\n\r\n      {/* Expandable filter options with smooth animation */}\r\n      {isExpanded && (\r\n        <Animated.View style={[styles.expandedContent, animatedContentStyle]}>\r\n          {/* Experience Level - Horizontal Scroll */}\r\n          <View style={styles.filterSection}>\r\n            <Text variant=\"captionMedium\" color=\"primary\" style={styles.sectionTitle}>LEVEL</Text>\r\n            <ScrollView \r\n              horizontal \r\n              showsHorizontalScrollIndicator={false}\r\n              contentContainerStyle={styles.horizontalChipsContent}\r\n            >\r\n              {EXPERIENCE_FILTERS.map((filter) => (\r\n                <QuickFilterChip\r\n                  key={filter.value}\r\n                  label={filter.label}\r\n                  active={filters.experienceLevel === filter.value}\r\n                  onPress={() => updateFilter('experienceLevel', filter.value)}\r\n                />\r\n              ))}\r\n            </ScrollView>\r\n          </View>\r\n\r\n          {/* Equipment - Horizontal Scroll */}\r\n          <View style={styles.filterSection}>\r\n            <Text variant=\"captionMedium\" color=\"primary\" style={styles.sectionTitle}>EQUIPMENT</Text>\r\n            <ScrollView \r\n              horizontal \r\n              showsHorizontalScrollIndicator={false}\r\n              contentContainerStyle={styles.horizontalChipsContent}\r\n            >\r\n              {EQUIPMENT_FILTERS.map((filter) => (\r\n                <QuickFilterChip\r\n                  key={filter.value}\r\n                  label={filter.label}\r\n                  active={filters.equipment === filter.value}\r\n                  onPress={() => updateFilter('equipment', filter.value)}\r\n                />\r\n              ))}\r\n            </ScrollView>\r\n          </View>\r\n\r\n          {/* Goal - Horizontal Scroll */}\r\n          <View style={styles.filterSection}>\r\n            <Text variant=\"captionMedium\" color=\"primary\" style={styles.sectionTitle}>GOAL</Text>\r\n            <ScrollView \r\n              horizontal \r\n              showsHorizontalScrollIndicator={false}\r\n              contentContainerStyle={styles.horizontalChipsContent}\r\n            >\r\n              {GOAL_FILTERS.map((filter) => (\r\n                <QuickFilterChip\r\n                  key={filter.value}\r\n                  label={filter.label}\r\n                  active={filters.goal === filter.value}\r\n                  onPress={() => updateFilter('goal', filter.value)}\r\n                />\r\n              ))}\r\n            </ScrollView>\r\n          </View>\r\n\r\n          {/* Workout Type - Horizontal Scroll */}\r\n          {showWorkoutTypeFilter && (\r\n            <View style={styles.filterSection}>\r\n              <Text variant=\"captionMedium\" color=\"primary\" style={styles.sectionTitle}>TYPE</Text>\r\n              <ScrollView \r\n                horizontal \r\n                showsHorizontalScrollIndicator={false}\r\n                contentContainerStyle={styles.horizontalChipsContent}\r\n              >\r\n                {WORKOUT_TYPE_FILTERS.map((filter) => (\r\n                  <QuickFilterChip\r\n                    key={filter.value}\r\n                    label={filter.label}\r\n                    active={filters.workoutType === filter.value}\r\n                    onPress={() => updateFilter('workoutType', filter.value)}\r\n                  />\r\n                ))}\r\n              </ScrollView>\r\n            </View>\r\n          )}\r\n\r\n          {/* Duration - Horizontal Scroll */}\r\n          {showDurationFilter && (\r\n            <View style={styles.filterSection}>\r\n              <Text variant=\"captionMedium\" color=\"primary\" style={styles.sectionTitle}>DURATION</Text>\r\n              <ScrollView \r\n                horizontal \r\n                showsHorizontalScrollIndicator={false}\r\n                contentContainerStyle={styles.horizontalChipsContent}\r\n              >\r\n                {DURATION_FILTERS.map((filter) => (\r\n                  <QuickFilterChip\r\n                    key={filter.value}\r\n                    label={filter.label}\r\n                    active={filters.duration === filter.value}\r\n                    onPress={() => updateFilter('duration', filter.value)}\r\n                  />\r\n                ))}\r\n              </ScrollView>\r\n            </View>\r\n          )}\r\n\r\n          {/* Clear all button */}\r\n          {activeFiltersCount > 0 && (\r\n            <Pressable style={styles.clearAllButton} onPress={clearAllFilters}>\r\n              <Text variant=\"bodySemibold\" color=\"secondary\">Clear All Filters</Text>\r\n            </Pressable>\r\n          )}\r\n        </Animated.View>\r\n      )}\r\n    </View>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    backgroundColor: colors.surface.card,\r\n    marginHorizontal: spacing.md,\r\n    marginBottom: spacing.md,\r\n    borderRadius: radius.lg,\r\n    ...shadows.cardSoft,\r\n    overflow: 'hidden',\r\n  },\r\n  header: {\r\n    paddingVertical: spacing.md,\r\n    paddingHorizontal: spacing.lg,\r\n    borderBottomWidth: 1,\r\n    borderBottomColor: colors.border.light,\r\n  },\r\n  headerContent: {\r\n    flexDirection: 'row',\r\n    justifyContent: 'space-between',\r\n    alignItems: 'center',\r\n  },\r\n  headerLeft: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    gap: spacing.sm,\r\n  },\r\n  badge: {\r\n    backgroundColor: colors.accent.primary,\r\n    borderRadius: radius.full,\r\n    paddingHorizontal: spacing.xs + 2,\r\n    paddingVertical: 2,\r\n    minWidth: 22,\r\n    height: 22,\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n  },\r\n  badgeText: {\r\n    fontSize: 11,\r\n    fontWeight: '700',\r\n  },\r\n  activeFiltersScroll: {\r\n    paddingVertical: spacing.sm,\r\n    paddingHorizontal: spacing.lg,\r\n    borderBottomWidth: 1,\r\n    borderBottomColor: colors.border.light,\r\n  },\r\n  activeFiltersContent: {\r\n    gap: spacing.sm,\r\n    paddingRight: spacing.lg,\r\n  },\r\n  clearAllChip: {\r\n    paddingVertical: spacing.xs,\r\n    paddingHorizontal: spacing.md,\r\n    borderRadius: radius.full,\r\n    borderWidth: 1,\r\n    borderColor: colors.border.light,\r\n    backgroundColor: colors.surface.subtle,\r\n    justifyContent: 'center',\r\n  },\r\n  clearAllText: {\r\n    fontWeight: '600',\r\n  },\r\n  expandedContent: {\r\n    paddingTop: spacing.md,\r\n    paddingBottom: spacing.lg,\r\n    gap: spacing.lg,\r\n  },\r\n  filterSection: {\r\n    gap: spacing.sm,\r\n  },\r\n  sectionTitle: {\r\n    paddingHorizontal: spacing.lg,\r\n    letterSpacing: 0.8,\r\n    fontWeight: '700',\r\n    fontSize: 11,\r\n  },\r\n  horizontalChipsContent: {\r\n    gap: spacing.sm,\r\n    paddingHorizontal: spacing.lg,\r\n  },\r\n  clearAllButton: {\r\n    marginHorizontal: spacing.lg,\r\n    marginTop: spacing.xs,\r\n    paddingVertical: spacing.md,\r\n    borderRadius: radius.md,\r\n    backgroundColor: colors.surface.subtle,\r\n    alignItems: 'center',\r\n    borderWidth: 1,\r\n    borderColor: colors.border.light,\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\WorkoutInProgressModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\WorkoutSubcardList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\molecules\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\organisms\\EditableWorkoutDetailContent.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'activeSelection' is assigned a value but never used.","line":122,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":122,"endColumn":25},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has an unnecessary dependency: 'weightUnit'. Either exclude it or remove the dependency array.","line":140,"column":6,"nodeType":"ArrayExpression","endLine":140,"endColumn":33,"suggestions":[{"desc":"Update the dependencies array to be: [convertWeight]","fix":{"range":[4900,4927],"text":"[convertWeight]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has an unnecessary dependency: 'distanceUnitPref'. Either exclude it or remove the dependency array.","line":152,"column":6,"nodeType":"ArrayExpression","endLine":152,"endColumn":75,"suggestions":[{"desc":"Update the dependencies array to be: [convertDistanceForExercise, effectiveDistanceUnit]","fix":{"range":[5356,5425],"text":"[convertDistanceForExercise, effectiveDistanceUnit]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'formatDistanceForDisplay', 'formatWeightForDisplay', 'set.assistanceWeight', 'set.distance', and 'set.weight'. Either include them or remove the dependency array. If 'setWeightInput' needs the current value of 'set.weight', you can also switch to useReducer instead of useState and read 'set.weight' in the reducer.","line":195,"column":6,"nodeType":"ArrayExpression","endLine":195,"endColumn":59,"suggestions":[{"desc":"Update the dependencies array to be: [weightUnit, distanceUnitPref, effectiveDistanceUnit, formatWeightForDisplay, set.weight, set.assistanceWeight, set.distance, formatDistanceForDisplay]","fix":{"range":[7714,7767],"text":"[weightUnit, distanceUnitPref, effectiveDistanceUnit, formatWeightForDisplay, set.weight, set.assistanceWeight, set.distance, formatDistanceForDisplay]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useMemo has an unnecessary dependency: 'weightUnit'. Either exclude it or remove the dependency array.","line":484,"column":6,"nodeType":"ArrayExpression","endLine":484,"endColumn":45,"suggestions":[{"desc":"Update the dependencies array to be: [totalVolume, formatWeight]","fix":{"range":[18782,18821],"text":"[totalVolume, formatWeight]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * EditableWorkoutDetailContent\r\n * Organism that renders editable exercise list for workout session editing.\r\n * Summary section auto-updates based on exercise data.\r\n */\r\n\r\nimport React, { useCallback, useMemo, useState, useEffect, useRef } from 'react';\r\nimport { StyleSheet, View, TextInput, Pressable, FlatList } from 'react-native';\r\nimport Animated, { Layout, FadeIn, FadeOut } from 'react-native-reanimated';\r\nimport { MaterialCommunityIcons } from '@expo/vector-icons';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { SurfaceCard } from '@/components/atoms/SurfaceCard';\r\nimport { TimePickerModal } from '@/components/molecules/TimePickerModal';\r\nimport { SheetModal } from '@/components/molecules/SheetModal';\r\nimport { spacing, colors, radius, sizing } from '@/constants/theme';\r\nimport { useTheme } from '@/hooks/useTheme';\r\nimport { exercises as exerciseCatalog } from '@/constants/exercises';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\nimport { formatDurationLabel, getWorkoutTotals, getWorkoutVolume } from '@/utils/workout';\r\nimport { searchExercises } from '@/utils/exerciseSearch';\r\nimport { useSettingsStore } from '@/store/settingsStore';\r\nimport type { Workout, WorkoutExercise, SetLog } from '@/types/workout';\r\nimport type { ExerciseType } from '@/types/exercise';\r\n\r\ninterface EditableWorkoutDetailContentProps {\r\n  workout: Workout;\r\n  onExercisesChange: (exercises: WorkoutExercise[]) => void;\r\n}\r\n\r\ninterface AddExerciseModalProps {\r\n  visible: boolean;\r\n  onClose: () => void;\r\n  onSelectExercise: (exercise: { name: string; exerciseType: ExerciseType }) => void;\r\n  existingExerciseNames: string[];\r\n}\r\n\r\ninterface EditableSetRowProps {\r\n  set: SetLog;\r\n  setIndex: number;\r\n  setId: string;\r\n  exerciseType: ExerciseType;\r\n  distanceUnit?: 'miles' | 'meters' | 'floors';\r\n  onSetChange: (index: number, set: SetLog) => void;\r\n  onDeleteSet: (index: number) => void;\r\n}\r\n\r\ntype ActiveSelectionTarget = {\r\n  type: 'weight' | 'reps' | 'distance' | 'assistance';\r\n  index: number;\r\n};\r\n\r\n// Format duration for display (drop leading zero on hours/minutes)\r\nconst formatDurationForSummary = (seconds: number): string => {\r\n  const hours = Math.floor(seconds / 3600);\r\n  const mins = Math.floor((seconds % 3600) / 60);\r\n  const secs = seconds % 60;\r\n\r\n  if (hours > 0) {\r\n    return `${hours}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\r\n  }\r\n  return `${mins}:${secs.toString().padStart(2, '0')}`;\r\n};\r\n\r\nconst sanitizeWeightInput = (value: string): string => {\r\n  if (!value) {\r\n    return '';\r\n  }\r\n\r\n  const cleaned = value.replace(/[^0-9.]/g, '');\r\n  if (!cleaned) {\r\n    return '';\r\n  }\r\n\r\n  const [integerPartRaw, ...decimalParts] = cleaned.split('.');\r\n  const integerPart = integerPartRaw.replace(/^0+(?=\\d)/, '') || (decimalParts.length > 0 ? '0' : '');\r\n  const decimalPart = decimalParts.join('').replace(/\\./g, '');\r\n\r\n  // If there's a decimal point in the input, preserve it even if no digits follow\r\n  if (decimalParts.length > 0) {\r\n    return decimalPart.length > 0 ? `${integerPart}.${decimalPart}` : `${integerPart}.`;\r\n  }\r\n\r\n  return integerPart;\r\n};\r\n\r\nconst sanitizeRepsInput = (value: string): string => {\r\n  if (!value) {\r\n    return '';\r\n  }\r\n\r\n  const digitsOnly = value.replace(/[^0-9]/g, '');\r\n  if (!digitsOnly) {\r\n    return '';\r\n  }\r\n\r\n  return digitsOnly.replace(/^0+(?=\\d)/, '');\r\n};\r\n\r\nconst EditableSetRow: React.FC<EditableSetRowProps> = ({\r\n  set,\r\n  setIndex,\r\n  setId,\r\n  exerciseType,\r\n  distanceUnit,\r\n  onSetChange,\r\n  onDeleteSet,\r\n}) => {\r\n  const { theme } = useTheme();\r\n  // Subscribe to unit preferences so the row re-renders when units change\r\n  const weightUnit = useSettingsStore((state) => state.weightUnit);\r\n  const distanceUnitPref = useSettingsStore((state) => state.distanceUnit);\r\n\r\n  const {\r\n    convertWeight,\r\n    convertWeightToLbs,\r\n    getDistanceUnitForExercise,\r\n    convertDistanceForExercise,\r\n    convertDistanceToMilesForExercise,\r\n  } = useSettingsStore();\r\n  const [isTimePickerVisible, setIsTimePickerVisible] = useState(false);\r\n  const [activeSelection, setActiveSelection] = useState<ActiveSelectionTarget | null>(null);\r\n  \r\n  // Track the last values we sent to parent to distinguish user edits from external changes\r\n  const lastSentValuesRef = useRef({\r\n    weight: set.weight ?? 0,\r\n    reps: set.reps ?? 0,\r\n    distance: set.distance ?? 0,\r\n    assistanceWeight: set.assistanceWeight ?? 0,\r\n  });\r\n  \r\n  const effectiveDistanceUnit = distanceUnit ?? 'miles';\r\n  const distanceUnitLabel = getDistanceUnitForExercise(effectiveDistanceUnit);\r\n\r\n  // Helper to convert weight (stored as lbs) for display\r\n  const formatWeightForDisplay = useCallback((weightLbs: number) => {\r\n    if (weightLbs === 0) return '';\r\n    const display = convertWeight(weightLbs);\r\n    return display % 1 === 0 ? display.toFixed(0) : display.toFixed(1);\r\n  }, [convertWeight, weightUnit]);\r\n\r\n  // Helper to convert distance (stored as miles) for display\r\n  const formatDistanceForDisplay = useCallback((miles: number) => {\r\n    if (miles === 0) return '';\r\n    const display = convertDistanceForExercise(miles, effectiveDistanceUnit);\r\n\r\n    if (effectiveDistanceUnit === 'meters' || effectiveDistanceUnit === 'floors') {\r\n      return Math.round(display).toString();\r\n    }\r\n\r\n    return display.toFixed(2);\r\n  }, [convertDistanceForExercise, effectiveDistanceUnit, distanceUnitPref]);\r\n  \r\n  // Local string state for inputs\r\n  const [weightInput, setWeightInput] = useState(() => formatWeightForDisplay(set.weight ?? 0));\r\n  const [repsInput, setRepsInput] = useState(() => set.reps?.toString() ?? '');\r\n  const [distanceInput, setDistanceInput] = useState(() => formatDistanceForDisplay(set.distance ?? 0));\r\n  const [assistanceInput, setAssistanceInput] = useState(() => formatWeightForDisplay(set.assistanceWeight ?? 0));\r\n  \r\n  // Sync local state only when props change from EXTERNAL source (not our own updates)\r\n  useEffect(() => {\r\n    const currentWeight = set.weight ?? 0;\r\n    const currentReps = set.reps ?? 0;\r\n    const currentDistance = set.distance ?? 0;\r\n    const currentAssistance = set.assistanceWeight ?? 0;\r\n    \r\n    // Check if the change came from outside (values differ from what we last sent)\r\n    const weightDiff = Math.abs(currentWeight - lastSentValuesRef.current.weight) > 0.01;\r\n    const repsDiff = currentReps !== lastSentValuesRef.current.reps;\r\n    const distanceDiff = Math.abs(currentDistance - lastSentValuesRef.current.distance) > 0.01;\r\n    const assistanceDiff = Math.abs(currentAssistance - lastSentValuesRef.current.assistanceWeight) > 0.01;\r\n    \r\n    if (weightDiff || repsDiff || distanceDiff || assistanceDiff) {\r\n      // External change (deletion/reorder) - sync local state\r\n      setWeightInput(formatWeightForDisplay(currentWeight));\r\n      setRepsInput(currentReps?.toString() ?? '');\r\n      setDistanceInput(formatDistanceForDisplay(currentDistance));\r\n      setAssistanceInput(formatWeightForDisplay(currentAssistance));\r\n      \r\n      // Update our tracking ref\r\n      lastSentValuesRef.current = {\r\n        weight: currentWeight,\r\n        reps: currentReps,\r\n        distance: currentDistance,\r\n        assistanceWeight: currentAssistance,\r\n      };\r\n    }\r\n  }, [set.weight, set.reps, set.distance, set.assistanceWeight, formatWeightForDisplay, formatDistanceForDisplay]);\r\n\r\n  // If units change while the editor is open, update *display* strings from the stored base values.\r\n  useEffect(() => {\r\n    setWeightInput(formatWeightForDisplay(set.weight ?? 0));\r\n    setAssistanceInput(formatWeightForDisplay(set.assistanceWeight ?? 0));\r\n    setDistanceInput(formatDistanceForDisplay(set.distance ?? 0));\r\n  }, [weightUnit, distanceUnitPref, effectiveDistanceUnit]);\r\n\r\n  const handleWeightChange = useCallback((text: string) => {\r\n    const sanitized = sanitizeWeightInput(text);\r\n    setActiveSelection(null);\r\n    setWeightInput(sanitized);\r\n\r\n    const numValue = sanitized.length > 0 ? parseFloat(sanitized) : 0;\r\n    const weightInLbs = convertWeightToLbs(numValue);\r\n\r\n    lastSentValuesRef.current.weight = weightInLbs;\r\n    onSetChange(setIndex, { ...set, weight: weightInLbs });\r\n  }, [set, setIndex, onSetChange, convertWeightToLbs]);\r\n\r\n  const handleRepsChange = useCallback((text: string) => {\r\n    const sanitized = sanitizeRepsInput(text);\r\n    setActiveSelection(null);\r\n    setRepsInput(sanitized);\r\n    const numValue = sanitized.length > 0 ? parseInt(sanitized, 10) : 0;\r\n    lastSentValuesRef.current.reps = numValue;\r\n    onSetChange(setIndex, { ...set, reps: numValue });\r\n  }, [set, setIndex, onSetChange]);\r\n\r\n  const handleTimePickerConfirm = useCallback((totalSeconds: number) => {\r\n    onSetChange(setIndex, { ...set, duration: totalSeconds });\r\n    setIsTimePickerVisible(false);\r\n  }, [set, setIndex, onSetChange]);\r\n\r\n  const handleDistanceChange = useCallback((text: string) => {\r\n    const sanitized = sanitizeWeightInput(text);\r\n    setActiveSelection(null);\r\n    setDistanceInput(sanitized);\r\n\r\n    const numValue = sanitized.length > 0 ? parseFloat(sanitized) : 0;\r\n    const milesValue = convertDistanceToMilesForExercise(numValue, effectiveDistanceUnit);\r\n\r\n    lastSentValuesRef.current.distance = milesValue;\r\n    onSetChange(setIndex, { ...set, distance: milesValue });\r\n  }, [set, setIndex, onSetChange, convertDistanceToMilesForExercise, effectiveDistanceUnit]);\r\n\r\n  const handleAssistanceChange = useCallback((text: string) => {\r\n    const sanitized = sanitizeWeightInput(text);\r\n    setActiveSelection(null);\r\n    setAssistanceInput(sanitized);\r\n\r\n    const numValue = sanitized.length > 0 ? parseFloat(sanitized) : 0;\r\n    const weightInLbs = convertWeightToLbs(numValue);\r\n\r\n    lastSentValuesRef.current.assistanceWeight = weightInLbs;\r\n    onSetChange(setIndex, { ...set, assistanceWeight: weightInLbs });\r\n  }, [set, setIndex, onSetChange, convertWeightToLbs]);\r\n\r\n  const renderInputs = () => {\r\n    switch (exerciseType) {\r\n      case 'cardio':\r\n        return (\r\n          <>\r\n            <View style={styles.inputGroup}>\r\n              <TextInput\r\n                style={[styles.metricInput, { backgroundColor: theme.surface.card, color: theme.text.primary }]}\r\n                value={distanceInput}\r\n                onChangeText={handleDistanceChange}\r\n                keyboardType=\"decimal-pad\"\r\n                placeholder=\"0\"\r\n                placeholderTextColor={theme.text.tertiary}\r\n                textAlign=\"center\"\r\n                cursorColor={colors.accent.primary}\r\n                selectionColor={colors.accent.orangeLight}\r\n              />\r\n              <Text variant=\"caption\" color=\"secondary\">{distanceUnitLabel}</Text>\r\n            </View>\r\n            <Pressable \r\n              style={[styles.timeDisplayButton, { borderColor: theme.accent.orangeMuted, backgroundColor: theme.surface.card }]}\r\n              onPress={() => setIsTimePickerVisible(true)}\r\n            >\r\n              <Text style={[styles.timeDisplayText, { color: theme.text.primary }]}>\r\n                {formatDurationForSummary(set.duration ?? 0)}\r\n              </Text>\r\n            </Pressable>\r\n          </>\r\n        );\r\n\r\n      case 'duration':\r\n        return (\r\n          <Pressable \r\n            style={[styles.timeDisplayButton, { borderColor: theme.accent.orangeMuted, backgroundColor: theme.surface.card }]}\r\n            onPress={() => setIsTimePickerVisible(true)}\r\n          >\r\n            <Text style={[styles.timeDisplayText, { color: theme.text.primary }]}>\r\n              {formatDurationForSummary(set.duration ?? 0)}\r\n            </Text>\r\n          </Pressable>\r\n        );\r\n\r\n      case 'assisted':\r\n        return (\r\n          <>\r\n            <View style={styles.inputGroup}>\r\n              <TextInput\r\n                style={[styles.metricInput, { backgroundColor: theme.surface.card, color: theme.text.primary }]}\r\n                value={assistanceInput}\r\n                onChangeText={handleAssistanceChange}\r\n                keyboardType=\"decimal-pad\"\r\n                placeholder=\"0\"\r\n                placeholderTextColor={theme.text.tertiary}\r\n                textAlign=\"center\"\r\n                cursorColor={colors.accent.primary}\r\n                selectionColor={colors.accent.orangeLight}\r\n              />\r\n              <Text variant=\"caption\" color=\"secondary\">{weightUnit}</Text>\r\n            </View>\r\n            <View style={styles.inputGroup}>\r\n              <TextInput\r\n                style={[styles.metricInput, { backgroundColor: theme.surface.card, color: theme.text.primary }]}\r\n                value={repsInput}\r\n                onChangeText={handleRepsChange}\r\n                keyboardType=\"number-pad\"\r\n                placeholder=\"0\"\r\n                placeholderTextColor={theme.text.tertiary}\r\n                textAlign=\"center\"\r\n                cursorColor={colors.accent.primary}\r\n                selectionColor={colors.accent.orangeLight}\r\n              />\r\n              <Text variant=\"caption\" color=\"secondary\">reps</Text>\r\n            </View>\r\n          </>\r\n        );\r\n\r\n      case 'weight':\r\n      default:\r\n        return (\r\n          <>\r\n            <View style={styles.inputGroup}>\r\n              <TextInput\r\n                style={[styles.metricInput, { backgroundColor: theme.surface.card, color: theme.text.primary }]}\r\n                value={weightInput}\r\n                onChangeText={handleWeightChange}\r\n                keyboardType=\"decimal-pad\"\r\n                placeholder=\"0\"\r\n                placeholderTextColor={theme.text.tertiary}\r\n                textAlign=\"center\"\r\n                cursorColor={colors.accent.primary}\r\n                selectionColor={colors.accent.orangeLight}\r\n              />\r\n              <Text variant=\"caption\" color=\"secondary\">{weightUnit}</Text>\r\n            </View>\r\n            <View style={styles.inputGroup}>\r\n              <TextInput\r\n                style={[styles.metricInput, { backgroundColor: theme.surface.card, color: theme.text.primary }]}\r\n                value={repsInput}\r\n                onChangeText={handleRepsChange}\r\n                keyboardType=\"number-pad\"\r\n                placeholder=\"0\"\r\n                placeholderTextColor={theme.text.tertiary}\r\n                textAlign=\"center\"\r\n                cursorColor={colors.accent.primary}\r\n                selectionColor={colors.accent.orangeLight}\r\n              />\r\n              <Text variant=\"caption\" color=\"secondary\">reps</Text>\r\n            </View>\r\n          </>\r\n        );\r\n    }\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <Animated.View \r\n        entering={FadeIn.duration(200)} \r\n        exiting={FadeOut.duration(200)}\r\n        layout={Layout.springify()}\r\n        style={[styles.setRow, { backgroundColor: theme.surface.subtle }]}\r\n      >\r\n        <View \r\n          style={[\r\n            styles.setCircle, \r\n            { backgroundColor: theme.surface.card, borderColor: theme.accent.orangeMuted }\r\n          ]}\r\n        >\r\n          <Text variant=\"bodySemibold\" style={[styles.setCircleText, { color: theme.text.primary }]}>\r\n            {setIndex + 1}\r\n          </Text>\r\n        </View>\r\n        \r\n        <View style={styles.inputsContainer}>\r\n          {renderInputs()}\r\n        </View>\r\n        \r\n        <Pressable \r\n          style={styles.deleteSetButton}\r\n          onPress={() => {\r\n            triggerHaptic('selection');\r\n            onDeleteSet(setIndex);\r\n          }}\r\n        >\r\n          <MaterialCommunityIcons name=\"close\" size={18} color={theme.text.tertiary} />\r\n        </Pressable>\r\n      </Animated.View>\r\n      <TimePickerModal\r\n        visible={isTimePickerVisible}\r\n        onClose={() => setIsTimePickerVisible(false)}\r\n        onConfirm={handleTimePickerConfirm}\r\n        initialSeconds={set.duration ?? 0}\r\n      />\r\n    </>\r\n  );\r\n};\r\n\r\nconst AddExerciseModal: React.FC<AddExerciseModalProps> = ({\r\n  visible,\r\n  onClose,\r\n  onSelectExercise,\r\n  existingExerciseNames,\r\n}) => {\r\n  const { theme } = useTheme();\r\n  const [searchTerm, setSearchTerm] = useState('');\r\n  \r\n  const filteredExercises = useMemo(() => {\r\n    const excludeIds = exerciseCatalog\r\n      .filter(ex => existingExerciseNames.includes(ex.name))\r\n      .map(ex => ex.id);\r\n    return searchExercises(searchTerm, exerciseCatalog, { excludeIds, limit: 50 });\r\n  }, [searchTerm, existingExerciseNames]);\r\n  \r\n  return (\r\n    <SheetModal\r\n      visible={visible}\r\n      onClose={onClose}\r\n      title=\"Add Exercise\"\r\n      headerContent={\r\n        <TextInput\r\n          style={[styles.searchInput, { backgroundColor: theme.surface.elevated, color: theme.text.primary, borderColor: theme.border.light }]}\r\n          placeholder=\"Search by name or category\"\r\n          placeholderTextColor={theme.text.tertiary}\r\n          value={searchTerm}\r\n          onChangeText={setSearchTerm}\r\n          autoCapitalize=\"none\"\r\n          autoCorrect={false}\r\n        />\r\n      }\r\n    >\r\n      <FlatList\r\n        data={filteredExercises}\r\n        keyExtractor={(item) => item.id}\r\n        style={styles.modalList}\r\n        contentContainerStyle={styles.modalListContent}\r\n        showsVerticalScrollIndicator\r\n        keyboardShouldPersistTaps=\"handled\"\r\n        keyboardDismissMode=\"on-drag\"\r\n        ListEmptyComponent={\r\n          <View style={styles.modalEmptyState}>\r\n            <Text variant=\"body\" color=\"secondary\">\r\n              No exercises match that search yet.\r\n            </Text>\r\n          </View>\r\n        }\r\n        renderItem={({ item }) => (\r\n          <Pressable\r\n            style={styles.modalItem}\r\n            onPress={() => {\r\n              triggerHaptic('selection');\r\n              onSelectExercise({ name: item.name, exerciseType: item.exerciseType });\r\n              setSearchTerm('');\r\n              onClose();\r\n            }}\r\n          >\r\n            <Text variant=\"bodySemibold\" color=\"primary\">{item.name}</Text>\r\n            <Text variant=\"caption\" color=\"secondary\">{item.muscleGroup}</Text>\r\n          </Pressable>\r\n        )}\r\n      />\r\n    </SheetModal>\r\n  );\r\n};\r\n\r\nexport const EditableWorkoutDetailContent: React.FC<EditableWorkoutDetailContentProps> = ({ \r\n  workout,\r\n  onExercisesChange,\r\n}) => {\r\n  const { theme } = useTheme();\r\n  const weightUnit = useSettingsStore((state) => state.weightUnit);\r\n  const { formatWeight } = useSettingsStore();\r\n  const [isAddExerciseModalVisible, setIsAddExerciseModalVisible] = useState(false);\r\n  const durationLabel = useMemo(() => formatDurationLabel(workout.duration), [workout.duration]);\r\n  const { completedSets } = useMemo(() => getWorkoutTotals(workout), [workout]);\r\n  const totalVolume = useMemo(() => getWorkoutVolume(workout), [workout]);\r\n  const volumeLabel = useMemo(() => {\r\n    if (totalVolume === 0) return '';\r\n    return formatWeight(totalVolume);\r\n  }, [totalVolume, formatWeight, weightUnit]);\r\n  \r\n  const existingExerciseNames = useMemo(() => \r\n    workout.exercises.map(ex => ex.name), \r\n    [workout.exercises]\r\n  );\r\n\r\n  const handleSetChange = useCallback((exerciseIndex: number, setIndex: number, updatedSet: SetLog) => {\r\n    const newExercises = [...workout.exercises];\r\n    newExercises[exerciseIndex] = {\r\n      ...newExercises[exerciseIndex],\r\n      sets: newExercises[exerciseIndex].sets.map((s, i) => i === setIndex ? updatedSet : s),\r\n    };\r\n    onExercisesChange(newExercises);\r\n  }, [workout.exercises, onExercisesChange]);\r\n\r\n  const handleDeleteSet = useCallback((exerciseIndex: number, setIndex: number) => {\r\n    const newExercises = [...workout.exercises];\r\n    newExercises[exerciseIndex] = {\r\n      ...newExercises[exerciseIndex],\r\n      sets: newExercises[exerciseIndex].sets.filter((_, i) => i !== setIndex),\r\n    };\r\n    onExercisesChange(newExercises);\r\n  }, [workout.exercises, onExercisesChange]);\r\n\r\n  const handleAddSet = useCallback((exerciseIndex: number) => {\r\n    triggerHaptic('selection');\r\n    const exercise = workout.exercises[exerciseIndex];\r\n    const lastSet = exercise.sets[exercise.sets.length - 1];\r\n    const newSet: SetLog = lastSet \r\n      ? { ...lastSet, completed: false }\r\n      : { weight: 0, reps: 8, completed: false };\r\n    \r\n    const newExercises = [...workout.exercises];\r\n    newExercises[exerciseIndex] = {\r\n      ...newExercises[exerciseIndex],\r\n      sets: [...newExercises[exerciseIndex].sets, newSet],\r\n    };\r\n    onExercisesChange(newExercises);\r\n  }, [workout.exercises, onExercisesChange]);\r\n\r\n  const handleDeleteExercise = useCallback((exerciseIndex: number) => {\r\n    triggerHaptic('selection');\r\n    const newExercises = workout.exercises.filter((_, i) => i !== exerciseIndex);\r\n    onExercisesChange(newExercises);\r\n  }, [workout.exercises, onExercisesChange]);\r\n  \r\n  const handleAddExercise = useCallback((exercise: { name: string; exerciseType: ExerciseType }) => {\r\n    triggerHaptic('selection');\r\n    const newExercise: WorkoutExercise = {\r\n      name: exercise.name,\r\n      sets: [{ weight: 0, reps: 8, completed: true }],\r\n    };\r\n    onExercisesChange([...workout.exercises, newExercise]);\r\n  }, [workout.exercises, onExercisesChange]);\r\n  \r\n  const handleMoveExercise = useCallback((exerciseIndex: number, direction: 'up' | 'down') => {\r\n    triggerHaptic('selection');\r\n    const newExercises = [...workout.exercises];\r\n    const targetIndex = direction === 'up' ? exerciseIndex - 1 : exerciseIndex + 1;\r\n    \r\n    if (targetIndex < 0 || targetIndex >= newExercises.length) return;\r\n    \r\n    [newExercises[exerciseIndex], newExercises[targetIndex]] = \r\n      [newExercises[targetIndex], newExercises[exerciseIndex]];\r\n    \r\n    onExercisesChange(newExercises);\r\n  }, [workout.exercises, onExercisesChange]);\r\n\r\n  return (\r\n    <Animated.View layout={Layout.springify()} style={[styles.container, { paddingBottom: 100 }]}>\r\n      <View style={styles.summarySection}>\r\n        <Text style={{ fontSize: 24, fontWeight: '600', color: theme.text.primary }}>\r\n          Summary\r\n        </Text>\r\n        <SurfaceCard tone=\"card\" padding=\"xl\" showAccentStripe={false} style={styles.metricsCard}>\r\n          <View style={styles.metricsColumn}>\r\n            <View style={styles.metricRow}>\r\n              <Text style={{ fontSize: 20, fontWeight: '500', color: theme.text.primary }}>\r\n                Duration:\r\n              </Text>\r\n              <Text style={{ fontSize: 20, fontWeight: '700', color: theme.accent.orange, textAlign: 'right', flexShrink: 0 }}>\r\n                {durationLabel}\r\n              </Text>\r\n            </View>\r\n            <View style={styles.metricRow}>\r\n              <Text style={{ fontSize: 20, fontWeight: '500', color: theme.text.primary }}>\r\n                Sets:\r\n              </Text>\r\n              <Text style={{ fontSize: 20, fontWeight: '700', color: theme.accent.orange, textAlign: 'right', flexShrink: 0 }}>\r\n                {completedSets}\r\n              </Text>\r\n            </View>\r\n            <View style={styles.metricRow}>\r\n              <Text style={{ fontSize: 20, fontWeight: '500', color: theme.text.primary }}>\r\n                Volume:\r\n              </Text>\r\n              <Text style={{ fontSize: 20, fontWeight: '700', color: theme.accent.orange, textAlign: 'right', flexShrink: 0 }}>\r\n                {volumeLabel}\r\n              </Text>\r\n            </View>\r\n          </View>\r\n        </SurfaceCard>\r\n      </View>\r\n\r\n      <View style={styles.exerciseSection}>\r\n        <Text style={{ fontSize: 24, fontWeight: '600', color: theme.text.primary }}>\r\n          Exercises\r\n        </Text>\r\n        <View style={styles.exerciseList}>\r\n          {workout.exercises.map((exercise, exerciseIndex) => {\r\n            const catalogEntry = exerciseCatalog.find(e => e.name === exercise.name);\r\n            const exerciseType: ExerciseType = catalogEntry?.exerciseType || 'weight';\r\n            const exerciseDistanceUnit = catalogEntry?.distanceUnit;\r\n\r\n            return (\r\n              <Animated.View \r\n                key={`${exercise.name}-${exerciseIndex}`}\r\n                layout={Layout.springify()}\r\n              >\r\n                <SurfaceCard \r\n                  tone=\"card\" \r\n                  padding=\"lg\" \r\n                  showAccentStripe={false} \r\n                  style={[styles.exerciseCard, { borderColor: theme.accent.orangeMuted }]}\r\n                >\r\n                  <View style={styles.exerciseHeader}>\r\n                    <View style={styles.exerciseTitleGroup}>\r\n                      <Text style={{ fontSize: 18, fontWeight: '500', color: theme.text.primary }}>\r\n                        {exercise.name}\r\n                      </Text>\r\n                    </View>\r\n                    <View style={styles.exerciseActions}>\r\n                      <Pressable\r\n                        style={[styles.reorderButton, { opacity: exerciseIndex === 0 ? 0.3 : 1 }]}\r\n                        onPress={() => handleMoveExercise(exerciseIndex, 'up')}\r\n                        disabled={exerciseIndex === 0}\r\n                      >\r\n                        <MaterialCommunityIcons name=\"chevron-up\" size={22} color={theme.text.secondary} />\r\n                      </Pressable>\r\n                      <Pressable\r\n                        style={[styles.reorderButton, { opacity: exerciseIndex === workout.exercises.length - 1 ? 0.3 : 1 }]}\r\n                        onPress={() => handleMoveExercise(exerciseIndex, 'down')}\r\n                        disabled={exerciseIndex === workout.exercises.length - 1}\r\n                      >\r\n                        <MaterialCommunityIcons name=\"chevron-down\" size={22} color={theme.text.secondary} />\r\n                      </Pressable>\r\n                      <Pressable\r\n                        style={styles.deleteExerciseButton}\r\n                        onPress={() => handleDeleteExercise(exerciseIndex)}\r\n                      >\r\n                        <MaterialCommunityIcons \r\n                          name=\"trash-can-outline\" \r\n                          size={20} \r\n                          color={theme.accent.warning} \r\n                        />\r\n                      </Pressable>\r\n                    </View>\r\n                  </View>\r\n\r\n                  <View style={styles.setList}>\r\n                    {exercise.sets.map((set, setIndex) => (\r\n                      <EditableSetRow\r\n                        key={`set-${exerciseIndex}-${setIndex}`}\r\n                        set={set}\r\n                        setIndex={setIndex}\r\n                        setId={`${exerciseIndex}-${setIndex}`}\r\n                        exerciseType={exerciseType}\r\n                        distanceUnit={exerciseDistanceUnit}\r\n                        onSetChange={(idx, updatedSet) => handleSetChange(exerciseIndex, idx, updatedSet)}\r\n                        onDeleteSet={(idx) => handleDeleteSet(exerciseIndex, idx)}\r\n                      />\r\n                    ))}\r\n                  </View>\r\n\r\n                  <Pressable \r\n                    style={[styles.addSetButton, { borderColor: theme.accent.orangeMuted }]}\r\n                    onPress={() => handleAddSet(exerciseIndex)}\r\n                  >\r\n                    <MaterialCommunityIcons name=\"plus\" size={18} color={theme.accent.orange} />\r\n                    <Text variant=\"bodySemibold\" style={{ color: theme.accent.orange }}>\r\n                      Add Set\r\n                    </Text>\r\n                  </Pressable>\r\n                </SurfaceCard>\r\n              </Animated.View>\r\n            );\r\n          })}\r\n          \r\n          <Pressable \r\n            style={[styles.addExerciseButton, { borderColor: theme.accent.orangeMuted }]}\r\n            onPress={() => {\r\n              triggerHaptic('selection');\r\n              setIsAddExerciseModalVisible(true);\r\n            }}\r\n          >\r\n            <MaterialCommunityIcons name=\"plus\" size={20} color={theme.accent.orange} />\r\n            <Text variant=\"bodySemibold\" style={{ color: theme.accent.orange }}>\r\n              Add Exercise\r\n            </Text>\r\n          </Pressable>\r\n        </View>\r\n      </View>\r\n      \r\n      <AddExerciseModal\r\n        visible={isAddExerciseModalVisible}\r\n        onClose={() => setIsAddExerciseModalVisible(false)}\r\n        onSelectExercise={handleAddExercise}\r\n        existingExerciseNames={existingExerciseNames}\r\n      />\r\n    </Animated.View>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    gap: spacing['2xl'],\r\n  },\r\n  metricsCard: {\r\n    gap: spacing.lg,\r\n    overflow: 'hidden',\r\n  },\r\n  metricsColumn: {\r\n    flexDirection: 'column',\r\n    gap: spacing.md,\r\n  },\r\n  metricRow: {\r\n    flexDirection: 'row',\r\n    justifyContent: 'space-between',\r\n    alignItems: 'center',\r\n  },\r\n  summarySection: {\r\n    gap: spacing.md,\r\n  },\r\n  exerciseSection: {\r\n    gap: spacing.md,\r\n  },\r\n  exerciseList: {\r\n    gap: spacing.md,\r\n  },\r\n  exerciseCard: {\r\n    gap: spacing.md,\r\n    borderWidth: 1,\r\n    borderColor: colors.accent.orangeMuted,\r\n  },\r\n  exerciseHeader: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'space-between',\r\n  },\r\n  exerciseTitleGroup: {\r\n    flex: 1,\r\n    gap: spacing.xs,\r\n    flexShrink: 1,\r\n  },\r\n  deleteExerciseButton: {\r\n    padding: spacing.xs,\r\n    borderRadius: radius.full,\r\n  },\r\n  setList: {\r\n    gap: spacing.sm,\r\n  },\r\n  setRow: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'flex-start',\r\n    paddingVertical: spacing.xs,\r\n    paddingHorizontal: spacing.sm,\r\n    gap: spacing.md,\r\n    backgroundColor: colors.surface.subtle,\r\n    borderRadius: radius.md,\r\n  },\r\n  setCircle: {\r\n    width: sizing.iconLG,\r\n    height: sizing.iconLG,\r\n    borderRadius: radius.full,\r\n    backgroundColor: colors.surface.card,\r\n    borderWidth: 1,\r\n    borderColor: colors.accent.orangeMuted,\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n    flexShrink: 0,\r\n  },\r\n  setCircleCompleted: {\r\n    backgroundColor: colors.accent.orange,\r\n    borderColor: colors.accent.orange,\r\n  },\r\n  setCircleText: {\r\n    color: colors.text.primary,\r\n    fontSize: 16,\r\n    fontWeight: '600',\r\n    lineHeight: 16,\r\n    textAlign: 'center',\r\n    includeFontPadding: false,\r\n  },\r\n  inputsContainer: {\r\n    flex: 1,\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    gap: spacing.md,\r\n  },\r\n  inputGroup: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    gap: spacing.xs,\r\n  },\r\n  setInput: {\r\n    minWidth: 60,\r\n    paddingHorizontal: spacing.sm,\r\n    paddingVertical: spacing.xs,\r\n    borderRadius: radius.md,\r\n    borderWidth: 1,\r\n    borderColor: colors.accent.orangeMuted,\r\n    backgroundColor: colors.surface.card,\r\n    fontSize: 16,\r\n    fontWeight: '600',\r\n    color: colors.text.primary,\r\n    textAlign: 'center',\r\n  },\r\n  metricInput: {\r\n    minWidth: 60,\r\n    fontSize: 16,\r\n    fontWeight: '600',\r\n    paddingVertical: spacing.xs,\r\n    paddingHorizontal: spacing.sm,\r\n    borderRadius: radius.md,\r\n    backgroundColor: colors.surface.card,\r\n    borderWidth: 1,\r\n    borderColor: colors.accent.orangeMuted,\r\n  },\r\n  deleteSetButton: {\r\n    padding: spacing.xs,\r\n    borderRadius: radius.full,\r\n  },\r\n  addSetButton: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    gap: spacing.xs,\r\n    paddingVertical: spacing.sm,\r\n    borderRadius: radius.md,\r\n    borderWidth: 1,\r\n    borderColor: colors.accent.orangeMuted,\r\n  },\r\n  timeDisplayButton: {\r\n    paddingHorizontal: spacing.sm,\r\n    paddingVertical: spacing.xs,\r\n    borderRadius: radius.md,\r\n    borderWidth: 1,\r\n    minWidth: 80,\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n  },\r\n  timeDisplayText: {\r\n    fontSize: 16,\r\n    fontWeight: '600',\r\n    textAlign: 'center',\r\n  },\r\n  modalOverlay: {\r\n    flex: 1,\r\n    justifyContent: 'flex-end',\r\n  },\r\n  modalContent: {\r\n    maxHeight: '80%',\r\n    borderTopLeftRadius: radius.xl,\r\n    borderTopRightRadius: radius.xl,\r\n    paddingHorizontal: spacing.lg,\r\n    paddingTop: spacing.lg,\r\n    paddingBottom: spacing['2xl'],\r\n  },\r\n  modalHeader: {\r\n    flexDirection: 'row',\r\n    justifyContent: 'space-between',\r\n    alignItems: 'center',\r\n    marginBottom: spacing.md,\r\n  },\r\n  modalCloseButton: {\r\n    padding: spacing.xs,\r\n  },\r\n  searchInput: {\r\n    paddingHorizontal: spacing.md,\r\n    paddingVertical: spacing.sm,\r\n    borderRadius: radius.md,\r\n    borderWidth: 1,\r\n    fontSize: 16,\r\n    marginBottom: spacing.md,\r\n  },\r\n  exerciseListModal: {\r\n    flex: 1,\r\n  },\r\n  exerciseListItem: {\r\n    paddingVertical: spacing.md,\r\n    borderBottomWidth: 1,\r\n    gap: spacing.xxs,\r\n  },\r\n  addExerciseButton: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    gap: spacing.sm,\r\n    paddingVertical: spacing.md,\r\n    borderRadius: radius.md,\r\n    borderWidth: 1,\r\n    borderStyle: 'dashed',\r\n    marginTop: spacing.sm,\r\n  },\r\n  exerciseActions: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    gap: spacing.xs,\r\n  },\r\n  reorderButton: {\r\n    padding: spacing.xs,\r\n    borderRadius: radius.full,\r\n  },\r\n  modalList: {\r\n    flex: 1,\r\n  },\r\n  modalListContent: {\r\n    paddingHorizontal: spacing.lg,\r\n    paddingBottom: spacing.xl,\r\n  },\r\n  modalEmptyState: {\r\n    paddingVertical: spacing['2xl'],\r\n    alignItems: 'center',\r\n  },\r\n  modalItem: {\r\n    paddingVertical: spacing.md,\r\n    borderBottomWidth: 1,\r\n    borderBottomColor: colors.border.light,\r\n    gap: spacing.xxs,\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\organisms\\PersonalRecordsSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\organisms\\ScheduleEditorModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SurfaceCard' is defined but never used.","line":12,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * ScheduleEditorModal\r\n * Modal for editing the active schedule rule.\r\n * Supports Weekly, Rotating Cycle, and Plan-Driven schedule types.\r\n */\r\nimport React, { useState, useCallback, useMemo } from 'react';\r\nimport { View, StyleSheet, Modal, Pressable, ScrollView } from 'react-native';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\n\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { Button } from '@/components/atoms/Button';\r\nimport { SurfaceCard } from '@/components/atoms/SurfaceCard';\r\nimport { IconSymbol } from '@/components/ui/icon-symbol';\r\nimport { useActiveScheduleStore } from '@/store/activeScheduleStore';\r\nimport { useProgramsStore } from '@/store/programsStore';\r\nimport { usePlansStore } from '@/store/plansStore';\r\nimport { useTheme } from '@/hooks/useTheme';\r\nimport { spacing, radius, colors } from '@/constants/theme';\r\nimport type {\r\n  ScheduleRule,\r\n  ScheduleRuleType,\r\n  WeeklyScheduleRule,\r\n  RotatingScheduleRule,\r\n  PlanDrivenScheduleRule,\r\n  WeekdayKey,\r\n} from '@/types/activeSchedule';\r\n\r\ninterface ScheduleEditorModalProps {\r\n  visible: boolean;\r\n  onClose: () => void;\r\n}\r\n\r\ntype EditorStep = 'type-select' | 'configure';\r\n\r\nconst MAX_ROTATING_DAYS = 14;\r\n\r\nconst SCHEDULE_TYPES: { type: ScheduleRuleType; label: string; description: string }[] = [\r\n  {\r\n    type: 'weekly',\r\n    label: 'Weekly',\r\n    description: 'Same workout on the same day each week',\r\n  },\r\n  {\r\n    type: 'rotating',\r\n    label: 'Rotating Cycle',\r\n    description: 'Cycle through workouts regardless of day',\r\n  },\r\n  {\r\n    type: 'plan-driven',\r\n    label: 'Plan-Driven',\r\n    description: 'Follow a saved plan sequentially',\r\n  },\r\n];\r\n\r\nconst WEEKDAYS: { key: WeekdayKey; label: string; short: string }[] = [\r\n  { key: 'monday', label: 'Monday', short: 'Mon' },\r\n  { key: 'tuesday', label: 'Tuesday', short: 'Tue' },\r\n  { key: 'wednesday', label: 'Wednesday', short: 'Wed' },\r\n  { key: 'thursday', label: 'Thursday', short: 'Thu' },\r\n  { key: 'friday', label: 'Friday', short: 'Fri' },\r\n  { key: 'saturday', label: 'Saturday', short: 'Sat' },\r\n  { key: 'sunday', label: 'Sunday', short: 'Sun' },\r\n];\r\n\r\nconst createEmptyWeeklyRule = (): WeeklyScheduleRule => ({\r\n  type: 'weekly',\r\n  days: {\r\n    monday: null,\r\n    tuesday: null,\r\n    wednesday: null,\r\n    thursday: null,\r\n    friday: null,\r\n    saturday: null,\r\n    sunday: null,\r\n  },\r\n});\r\n\r\nconst createEmptyRotatingRule = (): RotatingScheduleRule => ({\r\n  type: 'rotating',\r\n  cycleWorkouts: [],\r\n  startDate: Date.now(),\r\n});\r\n\r\nconst createEmptyPlanDrivenRule = (planId: string, cycleWorkouts: (string | null)[] = [null]): PlanDrivenScheduleRule => ({\r\n  type: 'plan-driven',\r\n  planId,\r\n  startDate: Date.now(),\r\n  cycleWorkouts,\r\n  currentIndex: 0,\r\n});\r\n\r\nexport const ScheduleEditorModal: React.FC<ScheduleEditorModalProps> = ({\r\n  visible,\r\n  onClose,\r\n}) => {\r\n  const { theme } = useTheme();\r\n  const setActiveRule = useActiveScheduleStore((state) => state.setActiveRule);\r\n  const currentRule = useActiveScheduleStore((state) => state.state.activeRule);\r\n\r\n  const userPrograms = useProgramsStore((state) => state.userPrograms);\r\n  const plans = usePlansStore((state) => state.plans);\r\n\r\n  const [step, setStep] = useState<EditorStep>('type-select');\r\n  const [selectedType, setSelectedType] = useState<ScheduleRuleType | null>(\r\n    currentRule?.type || null\r\n  );\r\n  const [draftRule, setDraftRule] = useState<ScheduleRule | null>(currentRule);\r\n\r\n  const allWorkouts = useMemo(() => {\r\n    const workouts: { id: string; name: string; source: string }[] = [];\r\n\r\n    userPrograms.forEach((program) => {\r\n      program.workouts.forEach((w) => {\r\n        if (w.exercises.length > 0) {\r\n          workouts.push({ id: w.id, name: w.name, source: program.name });\r\n        }\r\n      });\r\n    });\r\n\r\n    plans.forEach((plan) => {\r\n      workouts.push({ id: plan.id, name: plan.name, source: 'Custom' });\r\n    });\r\n\r\n    return workouts;\r\n  }, [userPrograms, plans]);\r\n\r\n  const allPlans = useMemo(() => {\r\n    return userPrograms.map((p) => ({ id: p.id, name: p.name }));\r\n  }, [userPrograms]);\r\n\r\n  const handleTypeSelect = useCallback((type: ScheduleRuleType) => {\r\n    triggerHaptic('selection');\r\n    setSelectedType(type);\r\n\r\n    switch (type) {\r\n      case 'weekly':\r\n        setDraftRule(\r\n          currentRule?.type === 'weekly' ? currentRule : createEmptyWeeklyRule()\r\n        );\r\n        break;\r\n      case 'rotating':\r\n        setDraftRule(\r\n          currentRule?.type === 'rotating' ? currentRule : createEmptyRotatingRule()\r\n        );\r\n        break;\r\n      case 'plan-driven':\r\n        const defaultPlanId = allPlans[0]?.id || '';\r\n        setDraftRule(\r\n          currentRule?.type === 'plan-driven'\r\n            ? currentRule\r\n            : createEmptyPlanDrivenRule(defaultPlanId)\r\n        );\r\n        break;\r\n    }\r\n    setStep('configure');\r\n  }, [currentRule, allPlans]);\r\n\r\n  const handleBack = useCallback(() => {\r\n    triggerHaptic('selection');\r\n    setStep('type-select');\r\n  }, []);\r\n\r\n  const handleSave = useCallback(async () => {\r\n    triggerHaptic('success');\r\n    await setActiveRule(draftRule);\r\n    onClose();\r\n  }, [draftRule, setActiveRule, onClose]);\r\n\r\n  const handleClearSchedule = useCallback(async () => {\r\n    triggerHaptic('warning');\r\n    await setActiveRule(null);\r\n    onClose();\r\n  }, [setActiveRule, onClose]);\r\n\r\n  const handleClose = useCallback(() => {\r\n    triggerHaptic('selection');\r\n    setStep('type-select');\r\n    setSelectedType(currentRule?.type || null);\r\n    setDraftRule(currentRule);\r\n    onClose();\r\n  }, [currentRule, onClose]);\r\n\r\n  const updateWeeklyDay = useCallback((day: WeekdayKey, workoutId: string | null) => {\r\n    if (draftRule?.type !== 'weekly') return;\r\n    setDraftRule({\r\n      ...draftRule,\r\n      days: { ...draftRule.days, [day]: workoutId },\r\n    });\r\n  }, [draftRule]);\r\n\r\n  const updateRotatingCycle = useCallback((workouts: (string | null)[]) => {\r\n    if (draftRule?.type !== 'rotating') return;\r\n    setDraftRule({ ...draftRule, cycleWorkouts: workouts });\r\n  }, [draftRule]);\r\n\r\n  const updatePlanDrivenPlan = useCallback((planId: string) => {\r\n    if (draftRule?.type !== 'plan-driven') return;\r\n    setDraftRule({ ...draftRule, planId });\r\n  }, [draftRule]);\r\n\r\n  const addCycleDay = useCallback(() => {\r\n    if (draftRule?.type !== 'rotating') return;\r\n    if (draftRule.cycleWorkouts.length >= MAX_ROTATING_DAYS) return;\r\n    setDraftRule({\r\n      ...draftRule,\r\n      cycleWorkouts: [...draftRule.cycleWorkouts, null],\r\n    });\r\n  }, [draftRule]);\r\n\r\n  const removeCycleDay = useCallback((index: number) => {\r\n    if (draftRule?.type !== 'rotating') return;\r\n    const newCycle = [...draftRule.cycleWorkouts];\r\n    newCycle.splice(index, 1);\r\n    setDraftRule({ ...draftRule, cycleWorkouts: newCycle });\r\n  }, [draftRule]);\r\n\r\n  const renderTypeSelection = () => (\r\n    <View style={styles.stepContent}>\r\n      <Text variant=\"heading3\" color=\"primary\" style={styles.stepTitle}>\r\n        Choose Schedule Type\r\n      </Text>\r\n      <Text variant=\"body\" color=\"secondary\" style={styles.stepSubtitle}>\r\n        Select how you want to organize your training\r\n      </Text>\r\n\r\n      <View style={styles.typeList}>\r\n        {SCHEDULE_TYPES.map(({ type, label, description }) => {\r\n          const isSelected = selectedType === type;\r\n          return (\r\n            <Pressable\r\n              key={type}\r\n              style={[\r\n                styles.typeCard,\r\n                { backgroundColor: theme.surface.elevated },\r\n                isSelected && { borderColor: theme.accent.orange, borderWidth: 2 },\r\n              ]}\r\n              onPress={() => handleTypeSelect(type)}\r\n            >\r\n              <View style={styles.typeCardContent}>\r\n                <Text variant=\"bodySemibold\" color=\"primary\">\r\n                  {label}\r\n                </Text>\r\n                <Text variant=\"caption\" color=\"secondary\">\r\n                  {description}\r\n                </Text>\r\n              </View>\r\n              <IconSymbol\r\n                name=\"chevron-right\"\r\n                size={20}\r\n                color={theme.text.tertiary}\r\n              />\r\n            </Pressable>\r\n          );\r\n        })}\r\n      </View>\r\n\r\n      {currentRule && (\r\n        <Button\r\n          label=\"Clear Schedule\"\r\n          variant=\"ghost\"\r\n          size=\"md\"\r\n          onPress={handleClearSchedule}\r\n          textColor={colors.accent.warning}\r\n        />\r\n      )}\r\n    </View>\r\n  );\r\n\r\n  const renderWeeklyEditor = () => {\r\n    if (draftRule?.type !== 'weekly') return null;\r\n\r\n    return (\r\n      <View style={styles.stepContent}>\r\n        <Text variant=\"heading3\" color=\"primary\" style={styles.stepTitle}>\r\n          Weekly Schedule\r\n        </Text>\r\n        <Text variant=\"body\" color=\"secondary\" style={styles.stepSubtitle}>\r\n          Assign workouts to each day of the week\r\n        </Text>\r\n\r\n        <ScrollView style={styles.daysList} showsVerticalScrollIndicator={false}>\r\n          {WEEKDAYS.map(({ key, label }) => {\r\n            const selectedId = draftRule.days[key];\r\n            const selectedWorkout = allWorkouts.find((w) => w.id === selectedId);\r\n\r\n            return (\r\n              <View key={key} style={styles.dayRow}>\r\n                <Text variant=\"bodySemibold\" color=\"primary\" style={styles.dayLabel}>\r\n                  {label}\r\n                </Text>\r\n                <Pressable\r\n                  style={[styles.workoutPicker, { backgroundColor: theme.surface.elevated }]}\r\n                  onPress={() => {\r\n                    const currentIndex = allWorkouts.findIndex((w) => w.id === selectedId);\r\n                    const nextIndex = (currentIndex + 1) % (allWorkouts.length + 1);\r\n                    const nextWorkout = nextIndex < allWorkouts.length ? allWorkouts[nextIndex] : null;\r\n                    updateWeeklyDay(key, nextWorkout?.id || null);\r\n                  }}\r\n                >\r\n                  <Text\r\n                    variant=\"bodySemibold\"\r\n                    color=\"primary\"\r\n                    numberOfLines={1}\r\n                  >\r\n                    {selectedWorkout?.name || 'Rest Day'}\r\n                  </Text>\r\n                </Pressable>\r\n              </View>\r\n            );\r\n          })}\r\n        </ScrollView>\r\n      </View>\r\n    );\r\n  };\r\n\r\n  const renderRotatingEditor = () => {\r\n    if (draftRule?.type !== 'rotating') return null;\r\n\r\n    return (\r\n      <View style={styles.stepContent}>\r\n        <Text variant=\"heading3\" color=\"primary\" style={styles.stepTitle}>\r\n          Rotating Cycle\r\n        </Text>\r\n        <Text variant=\"body\" color=\"secondary\" style={styles.stepSubtitle}>\r\n          Define your cycle order (repeats indefinitely)\r\n        </Text>\r\n\r\n        <ScrollView style={styles.daysList} showsVerticalScrollIndicator={false}>\r\n          {draftRule.cycleWorkouts.map((workoutId, visualIndex) => {\r\n            const selectedWorkout = allWorkouts.find((w) => w.id === workoutId);\r\n\r\n            return (\r\n              <View key={visualIndex} style={styles.cycleRow}>\r\n                <Text variant=\"bodySemibold\" color=\"primary\" style={styles.cycleDayNum}>\r\n                  Day {visualIndex + 1}\r\n                </Text>\r\n                <Pressable\r\n                  style={[styles.workoutPicker, { backgroundColor: theme.surface.elevated, flex: 1 }]}\r\n                  onPress={() => {\r\n                    const currentIndex = allWorkouts.findIndex((w) => w.id === workoutId);\r\n                    const nextIndex = (currentIndex + 1) % (allWorkouts.length + 1);\r\n                    const nextWorkout = nextIndex < allWorkouts.length ? allWorkouts[nextIndex] : null;\r\n                    const newCycle = [...draftRule.cycleWorkouts];\r\n                    newCycle[visualIndex] = nextWorkout?.id || null;\r\n                    updateRotatingCycle(newCycle);\r\n                  }}\r\n                >\r\n                  <Text\r\n                    variant=\"bodySemibold\"\r\n                    color=\"primary\"\r\n                    numberOfLines={1}\r\n                  >\r\n                    {selectedWorkout?.name || 'Rest Day'}\r\n                  </Text>\r\n                </Pressable>\r\n                <Pressable\r\n                  style={styles.removeButton}\r\n                  onPress={() => removeCycleDay(visualIndex)}\r\n                >\r\n                  <IconSymbol name=\"close\" size={18} color={theme.accent.warning} />\r\n                </Pressable>\r\n              </View>\r\n            );\r\n          })}\r\n\r\n          <Button\r\n            label=\"Add Day\"\r\n            variant=\"secondary\"\r\n            size=\"sm\"\r\n            onPress={addCycleDay}\r\n            disabled={draftRule.cycleWorkouts.length >= MAX_ROTATING_DAYS}\r\n          />\r\n        </ScrollView>\r\n      </View>\r\n    );\r\n  };\r\n\r\n  const renderPlanDrivenEditor = () => {\r\n    if (draftRule?.type !== 'plan-driven') return null;\r\n\r\n    return (\r\n      <View style={styles.stepContent}>\r\n        <Text variant=\"heading3\" color=\"primary\" style={styles.stepTitle}>\r\n          Plan-Driven Schedule\r\n        </Text>\r\n        <Text variant=\"body\" color=\"secondary\" style={styles.stepSubtitle}>\r\n          Progress through a saved plan sequentially\r\n        </Text>\r\n\r\n        <View style={styles.planList}>\r\n          {allPlans.length === 0 ? (\r\n            <Text variant=\"body\" color=\"tertiary\">\r\n              No plans available. Create a plan first.\r\n            </Text>\r\n          ) : (\r\n            allPlans.map((plan) => {\r\n              const isSelected = draftRule.planId === plan.id;\r\n              return (\r\n                <Pressable\r\n                  key={plan.id}\r\n                  style={[\r\n                    styles.planCard,\r\n                    { backgroundColor: theme.surface.elevated },\r\n                    isSelected && { borderColor: theme.accent.orange, borderWidth: 2 },\r\n                  ]}\r\n                  onPress={() => updatePlanDrivenPlan(plan.id)}\r\n                >\r\n                  <Text variant=\"bodySemibold\" color=\"primary\">\r\n                    {plan.name}\r\n                  </Text>\r\n                  {isSelected && (\r\n                    <IconSymbol name=\"check-circle\" size={20} color={theme.accent.orange} />\r\n                  )}\r\n                </Pressable>\r\n              );\r\n            })\r\n          )}\r\n        </View>\r\n      </View>\r\n    );\r\n  };\r\n\r\n  const renderConfigureStep = () => {\r\n    switch (selectedType) {\r\n      case 'weekly':\r\n        return renderWeeklyEditor();\r\n      case 'rotating':\r\n        return renderRotatingEditor();\r\n      case 'plan-driven':\r\n        return renderPlanDrivenEditor();\r\n      default:\r\n        return null;\r\n    }\r\n  };\r\n\r\n  return (\r\n    <Modal\r\n      visible={visible}\r\n      transparent\r\n      animationType=\"slide\"\r\n      onRequestClose={handleClose}\r\n    >\r\n      <View style={[styles.overlay, { backgroundColor: colors.overlay.scrim }]}>\r\n        <View style={[styles.modalContainer, { backgroundColor: theme.surface.card }]}>\r\n          <View style={styles.header}>\r\n            {step === 'configure' && (\r\n              <Pressable style={styles.backButton} onPress={handleBack}>\r\n                <IconSymbol name=\"arrow-back\" size={24} color={theme.text.primary} />\r\n              </Pressable>\r\n            )}\r\n            <Text variant=\"heading3\" color=\"primary\" style={styles.headerTitle}>\r\n              {step === 'type-select' ? 'Edit Schedule' : 'Configure'}\r\n            </Text>\r\n            <Pressable style={styles.closeButton} onPress={handleClose}>\r\n              <IconSymbol name=\"close\" size={24} color={theme.text.primary} />\r\n            </Pressable>\r\n          </View>\r\n\r\n          {step === 'type-select' ? renderTypeSelection() : renderConfigureStep()}\r\n\r\n          {step === 'configure' && (\r\n            <View style={styles.footer}>\r\n              <Button\r\n                label=\"Save Schedule\"\r\n                variant=\"primary\"\r\n                size=\"lg\"\r\n                onPress={handleSave}\r\n              />\r\n            </View>\r\n          )}\r\n        </View>\r\n      </View>\r\n    </Modal>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  overlay: {\r\n    flex: 1,\r\n    justifyContent: 'flex-end',\r\n  },\r\n  modalContainer: {\r\n    borderTopLeftRadius: radius.xl,\r\n    borderTopRightRadius: radius.xl,\r\n    maxHeight: '85%',\r\n    paddingBottom: spacing.xl,\r\n  },\r\n  header: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n    paddingVertical: spacing.lg,\r\n    paddingHorizontal: spacing.lg,\r\n    borderBottomWidth: StyleSheet.hairlineWidth,\r\n    borderBottomColor: colors.border.light,\r\n  },\r\n  headerTitle: {\r\n    flex: 1,\r\n    textAlign: 'center',\r\n  },\r\n  backButton: {\r\n    position: 'absolute',\r\n    left: spacing.lg,\r\n    padding: spacing.xs,\r\n  },\r\n  closeButton: {\r\n    position: 'absolute',\r\n    right: spacing.lg,\r\n    padding: spacing.xs,\r\n  },\r\n  stepContent: {\r\n    padding: spacing.lg,\r\n    gap: spacing.lg,\r\n  },\r\n  stepTitle: {\r\n    textAlign: 'center',\r\n  },\r\n  stepSubtitle: {\r\n    textAlign: 'center',\r\n  },\r\n  typeList: {\r\n    gap: spacing.md,\r\n  },\r\n  typeCard: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    padding: spacing.lg,\r\n    borderRadius: radius.lg,\r\n    borderWidth: 1,\r\n    borderColor: 'transparent',\r\n  },\r\n  typeCardContent: {\r\n    flex: 1,\r\n    gap: spacing.xs,\r\n  },\r\n  daysList: {\r\n    maxHeight: 350,\r\n  },\r\n  dayRow: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    marginBottom: spacing.md,\r\n    gap: spacing.md,\r\n  },\r\n  dayLabel: {\r\n    width: 100,\r\n  },\r\n  workoutPicker: {\r\n    flex: 1,\r\n    padding: spacing.md,\r\n    borderRadius: radius.md,\r\n  },\r\n  cycleRow: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    marginBottom: spacing.md,\r\n    gap: spacing.sm,\r\n  },\r\n  cycleDayNum: {\r\n    width: 60,\r\n  },\r\n  removeButton: {\r\n    padding: spacing.sm,\r\n  },\r\n  planList: {\r\n    gap: spacing.md,\r\n  },\r\n  planCard: {\r\n    flexDirection: 'row',\r\n    alignItems: 'center',\r\n    justifyContent: 'space-between',\r\n    padding: spacing.lg,\r\n    borderRadius: radius.lg,\r\n    borderWidth: 1,\r\n    borderColor: 'transparent',\r\n  },\r\n  footer: {\r\n    padding: spacing.lg,\r\n    borderTopWidth: StyleSheet.hairlineWidth,\r\n    borderTopColor: colors.border.light,\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\organisms\\WorkoutCompletionOverlay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\organisms\\WorkoutDetailContent.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useMemo has an unnecessary dependency: 'weightUnit'. Either exclude it or remove the dependency array.","line":37,"column":6,"nodeType":"ArrayExpression","endLine":37,"endColumn":45,"suggestions":[{"desc":"Update the dependencies array to be: [totalVolume, formatWeight]","fix":{"range":[1549,1588],"text":"[totalVolume, formatWeight]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * WorkoutDetailContent\n * Organism that renders the core metrics and exercise list for a workout.\n */\n\nimport React, { useMemo } from 'react';\nimport { StyleSheet, View, type TextStyle } from 'react-native';\nimport Animated, { Layout } from 'react-native-reanimated';\n\nimport { Text } from '@/components/atoms/Text';\nimport { SurfaceCard } from '@/components/atoms/SurfaceCard';\nimport { WorkoutExerciseSummaryCard } from '@/components/molecules/WorkoutExerciseSummaryCard';\nimport { spacing, typography, colors } from '@/constants/theme';\nimport type { Workout } from '@/types/workout';\nimport { formatDurationLabel, getWorkoutTotals, getWorkoutVolume } from '@/utils/workout';\nimport { useSettingsStore } from '@/store/settingsStore';\n\ninterface WorkoutDetailContentProps {\n  workout: Workout;\n}\n\n/**\n * WorkoutDetailContent\n *\n * @param workout - Completed workout session to visualize.\n */\nexport const WorkoutDetailContent: React.FC<WorkoutDetailContentProps> = ({ workout }) => {\n  // Subscribe to weightUnit to trigger re-renders when units change\n  const weightUnit = useSettingsStore((state) => state.weightUnit);\n  const { formatWeight } = useSettingsStore();\n  const durationLabel = useMemo(() => formatDurationLabel(workout.duration), [workout.duration]);\n  const { completedSets } = useMemo(() => getWorkoutTotals(workout), [workout]);\n  const totalVolume = useMemo(() => getWorkoutVolume(workout), [workout]);\n  const volumeLabel = useMemo(() => {\n    if (totalVolume === 0) return '';\n    return formatWeight(totalVolume);\n  }, [totalVolume, formatWeight, weightUnit]);\n\n  return (\n    <Animated.View layout={Layout.springify()} style={styles.container}>\n      <View style={styles.summarySection}>\n        <Text style={{ fontSize: 24, fontWeight: '600', color: colors.text.primary }}>\n          Summary\n        </Text>\n        <SurfaceCard tone=\"card\" padding=\"xl\" showAccentStripe={false} style={styles.metricsCard}>\n          <View style={styles.metricsColumn}>\n            <View style={styles.metricRow}>\n              <Text style={{ fontSize: 20, fontWeight: '500', color: colors.text.primary }}>\n                Duration:\n              </Text>\n              <Text style={{ fontSize: 20, fontWeight: '700', color: colors.accent.orange, textAlign: 'right', flexShrink: 0 }}>\n                {durationLabel}\n              </Text>\n            </View>\n            <View style={styles.metricRow}>\n              <Text style={{ fontSize: 20, fontWeight: '500', color: colors.text.primary }}>\n                Sets:\n              </Text>\n              <Text style={{ fontSize: 20, fontWeight: '700', color: colors.accent.orange, textAlign: 'right', flexShrink: 0 }}>\n                {completedSets}\n              </Text>\n            </View>\n            <View style={styles.metricRow}>\n              <Text style={{ fontSize: 20, fontWeight: '500', color: colors.text.primary }}>\n                Volume:\n              </Text>\n              <Text style={{ fontSize: 20, fontWeight: '700', color: colors.accent.orange, textAlign: 'right', flexShrink: 0 }}>\n                {volumeLabel}\n              </Text>\n            </View>\n          </View>\n        </SurfaceCard>\n      </View>\n\n      <View style={styles.exerciseSection}>\n        <Text style={{ fontSize: 24, fontWeight: '600', color: colors.text.primary }}>\n          Exercises\n        </Text>\n        <View style={styles.exerciseList}>\n          {workout.exercises.map((exercise, index) => (\n            <WorkoutExerciseSummaryCard key={`${exercise.name}-${index}`} exercise={exercise} index={index} />\n          ))}\n        </View>\n      </View>\n    </Animated.View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    gap: spacing['2xl'],\n  },\n  metricsCard: {\n    gap: spacing.lg,\n    overflow: 'hidden',\n  },\n  metricsColumn: {\n    flexDirection: 'column',\n    gap: spacing.md,\n  },\n  metricRow: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n  },\n  metricLabel: {\n    ...typography.heading3,\n    lineHeight: typography.heading3.lineHeight,\n  } as TextStyle,\n  summarySection: {\n    gap: spacing.md,\n  },\n  exerciseSection: {\n    gap: spacing.md,\n  },\n  exerciseList: {\n    gap: spacing.md,\n  },\n  metricValue: {\n    ...typography.heading2,\n    lineHeight: typography.heading2.lineHeight,\n    textAlign: 'right',\n    flexShrink: 0,\n  } as TextStyle,\n});\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\organisms\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\templates\\TabSwipeContainer.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'zIndex' is defined but never used.","line":11,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * TabSwipeContainer\n * Template providing a vertically scrolling container with buttery flick momentum.\n * Removes horizontal swipe navigation to prioritize seamless vertical interaction.\n */\n\nimport React, { ReactNode, useMemo, forwardRef } from 'react';\nimport { Platform, ScrollView, StyleSheet, View, type StyleProp, type ViewStyle } from 'react-native';\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\n\nimport { sizing, spacing, zIndex } from '@/constants/theme';\nimport { useTheme } from '@/hooks/useTheme';\n\ninterface TabSwipeContainerProps {\n  /** Screen content */\n  children: ReactNode;\n  /** Optional content container style fed into ScrollView */\n  contentContainerStyle?: StyleProp<ViewStyle>;\n  /** Control visibility of the vertical scroll indicator */\n  showsVerticalScrollIndicator?: boolean;\n}\n\nconst momentumDeceleration = Platform.select<'normal' | 'fast' | number>({\n  ios: 0.998,\n  android: 0.985,\n  default: 'normal',\n});\n\nconst SCROLL_BOTTOM_BUFFER = spacing.md;\n\nexport const TabSwipeContainer = forwardRef<ScrollView, TabSwipeContainerProps>(({\n  children,\n  contentContainerStyle,\n  showsVerticalScrollIndicator = false,\n}, ref) => {\n  const { theme } = useTheme();\n  const insets = useSafeAreaInsets();\n\n  const paddingBottom = useMemo<number>(\n    () => SCROLL_BOTTOM_BUFFER + sizing.tabBarHeight + insets.bottom,\n    [insets.bottom]\n  );\n\n  const composedContentStyle = useMemo<StyleProp<ViewStyle>>(\n    () => [contentContainerStyle, { paddingBottom }],\n    [contentContainerStyle, paddingBottom]\n  );\n\n  return (\n    <View style={[styles.root, { paddingTop: insets.top, paddingBottom: insets.bottom, backgroundColor: theme.primary.bg }]}>\n      <View style={[styles.container, { backgroundColor: theme.primary.bg }]}>\n        <ScrollView\n          ref={ref}\n          style={[styles.scrollView, { backgroundColor: theme.primary.bg }]}\n          scrollEventThrottle={16}\n          nestedScrollEnabled\n          decelerationRate={momentumDeceleration}\n          overScrollMode=\"always\"\n          bounces={Platform.OS === 'ios'}\n          alwaysBounceVertical={Platform.OS === 'ios'}\n          showsVerticalScrollIndicator={showsVerticalScrollIndicator}\n          contentContainerStyle={composedContentStyle}\n        >\n          {children}\n        </ScrollView>\n      </View>\n    </View>\n  );\n});\n\nTabSwipeContainer.displayName = 'TabSwipeContainer';\n\nconst styles = StyleSheet.create({\n  root: {\n    flex: 1,\n  },\n  container: {\n    flex: 1,\n  },\n  scrollView: {\n    flex: 1,\n  },\n});\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\templates\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\components\\ui\\icon-symbol.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\constants\\animations.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\constants\\exercises.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\constants\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\constants\\navigation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\constants\\schedule.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\constants\\theme.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\hooks\\useAnalyticsData.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'colors' is defined but never used.","line":16,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":16},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'workouts' conditional could make the dependencies of useMemo Hook (at line 153) change on every render. To fix this, wrap the initialization of 'workouts' in its own useMemo() Hook.","line":146,"column":9,"nodeType":"VariableDeclarator","endLine":146,"endColumn":69},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'workouts' conditional could make the dependencies of useMemo Hook (at line 581) change on every render. To fix this, wrap the initialization of 'workouts' in its own useMemo() Hook.","line":146,"column":9,"nodeType":"VariableDeclarator","endLine":146,"endColumn":69},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useMemo has an unnecessary dependency: 'weightUnit'. Either exclude it or remove the dependency array.","line":260,"column":6,"nodeType":"ArrayExpression","endLine":260,"endColumn":67,"suggestions":[{"desc":"Update the dependencies array to be: [filteredWorkouts, userBodyWeight, convertWeight]","fix":{"range":[9028,9089],"text":"[filteredWorkouts, userBodyWeight, convertWeight]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useMemo has an unnecessary dependency: 'weightUnit'. Either exclude it or remove the dependency array.","line":345,"column":6,"nodeType":"ArrayExpression","endLine":345,"endColumn":67,"suggestions":[{"desc":"Update the dependencies array to be: [filteredWorkouts, userBodyWeight, convertWeight]","fix":{"range":[12390,12451],"text":"[filteredWorkouts, userBodyWeight, convertWeight]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useMemo has an unnecessary dependency: 'weightUnit'. Either exclude it or remove the dependency array.","line":470,"column":6,"nodeType":"ArrayExpression","endLine":470,"endColumn":67,"suggestions":[{"desc":"Update the dependencies array to be: [filteredWorkouts, userBodyWeight, convertWeight]","fix":{"range":[17643,17704],"text":"[filteredWorkouts, userBodyWeight, convertWeight]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useMemo has an unnecessary dependency: 'timeRange'. Either exclude it or remove the dependency array.","line":649,"column":6,"nodeType":"ArrayExpression","endLine":649,"endColumn":66,"suggestions":[{"desc":"Update the dependencies array to be: [filteredWorkouts, userBodyWeight, convertWeight]","fix":{"range":[23598,23658],"text":"[filteredWorkouts, userBodyWeight, convertWeight]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * useAnalyticsData Hook\r\n * Centralized hook for all muscle volume and analytics calculations\r\n * Extracts and consolidates logic from FocusDistributionChart and WeeklyVolumeChart\r\n */\r\n\r\nimport { useMemo } from 'react';\r\n\r\nimport { useWorkoutSessionsStore } from '@/store/workoutSessionsStore';\r\nimport { useUserProfileStore } from '@/store/userProfileStore';\r\nimport { useSettingsStore } from '@/store/settingsStore';\r\nimport { useDevToolsStore } from '@/store/devToolsStore';\r\nimport { exercises as exerciseCatalog } from '@/constants/exercises';\r\nimport exercisesData from '@/data/exercises.json';\r\nimport hierarchyData from '@/data/hierarchy.json';\r\nimport { colors } from '@/constants/theme';\r\nimport { formatLocalDate } from '@/utils/chartUtils';\r\nimport type {\r\n  TieredVolumeData,\r\n  TieredSetData,\r\n  WeeklyVolumeData,\r\n  StreakData,\r\n  CardioStats,\r\n  ChartSlice,\r\n  BarChartData,\r\n  TimeRange,\r\n  HierarchicalSetData,\r\n} from '@/types/analytics';\r\nimport type { ExerciseType } from '@/types/exercise';\r\n\r\n// Build exercise type lookup map\r\nconst EXERCISE_TYPE_MAP = exerciseCatalog.reduce((acc, ex) => {\r\n  acc[ex.name] = ex.exerciseType;\r\n  return acc;\r\n}, {} as Record<string, ExerciseType>);\r\n\r\n// Build muscle hierarchy maps once at module load\r\n// Maps each muscle (at any level) to its parent at each tier\r\n// L1 = high (Upper Body, Lower Body, Core)\r\n// L2 = mid (Chest, Back, Arms, etc.)\r\n// L3 = low (Biceps, Triceps, Forearms, Upper Chest, etc.)\r\n// L4 = detailed (Biceps - Long Head, etc.)\r\nconst buildMaps = () => {\r\n  const leafToL1: Record<string, string> = {};\r\n  const leafToL2: Record<string, string> = {};\r\n  const leafToL3: Record<string, string> = {};\r\n  const leafToL4: Record<string, string> = {};\r\n  const l2ToL1: Record<string, string> = {};\r\n\r\n  const hierarchy = hierarchyData.muscle_hierarchy;\r\n\r\n  Object.entries(hierarchy).forEach(([l1, l1Data]) => {\r\n    // L1 level (high): Upper Body, Lower Body, Core\r\n    if (l1Data?.muscles) {\r\n      Object.entries(l1Data.muscles).forEach(([l2, l2Data]: [string, any]) => {\r\n        // L2 level (mid): Chest, Back, Arms, etc.\r\n        leafToL1[l2] = l1;\r\n        leafToL2[l2] = l2;\r\n        l2ToL1[l2] = l1;\r\n\r\n        if (l2Data?.muscles) {\r\n          Object.entries(l2Data.muscles).forEach(([l3, l3Data]: [string, any]) => {\r\n            // L3 level (low): Biceps, Triceps, Upper Chest, etc.\r\n            leafToL1[l3] = l1;\r\n            leafToL2[l3] = l2;\r\n            leafToL3[l3] = l3;\r\n\r\n            if (l3Data?.muscles) {\r\n              // L4 level (detailed): Biceps - Long Head, etc.\r\n              Object.keys(l3Data.muscles).forEach((l4) => {\r\n                leafToL1[l4] = l1;\r\n                leafToL2[l4] = l2;\r\n                leafToL3[l4] = l3;\r\n                leafToL4[l4] = l4;\r\n              });\r\n            }\r\n          });\r\n        }\r\n      });\r\n    }\r\n  });\r\n\r\n  return { leafToL1, leafToL2, leafToL3, leafToL4, l2ToL1 };\r\n};\r\n\r\nconst { leafToL1, leafToL2, leafToL3, leafToL4, l2ToL1 } = buildMaps();\r\n\r\n// Exercise name to muscle weights map\r\nconst EXERCISE_MUSCLES = exercisesData.reduce((acc, ex) => {\r\n  if (ex.muscles) {\r\n    acc[ex.name] = ex.muscles as unknown as Record<string, number>;\r\n  }\r\n  return acc;\r\n}, {} as Record<string, Record<string, number>>);\r\n\r\n// Filter workouts by time range\r\nconst filterByTimeRange = (workouts: any[], range: TimeRange) => {\r\n  if (range === 'all') return workouts;\r\n\r\n  const now = new Date();\r\n  const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());\r\n\r\n  let cutoff: Date;\r\n\r\n  switch (range) {\r\n    case 'week': {\r\n      // Last 7 calendar days INCLUDING today (local time)\r\n      cutoff = new Date(todayStart);\r\n      cutoff.setDate(cutoff.getDate() - 6);\r\n      break;\r\n    }\r\n    case 'month':\r\n      // First of current month (inclusive, local)\r\n      cutoff = new Date(now.getFullYear(), now.getMonth(), 1);\r\n      break;\r\n    case 'year':\r\n      // First of current year (inclusive, local)\r\n      cutoff = new Date(now.getFullYear(), 0, 1);\r\n      break;\r\n    default:\r\n      return workouts;\r\n  }\r\n\r\n  return workouts.filter((w) => {\r\n    const workoutDate = new Date(w.startTime ?? w.date);\r\n    return workoutDate >= cutoff;\r\n  });\r\n};\r\n\r\n// Generate orange color with opacity based on index\r\nconst generateSliceColor = (index: number, total: number): string => {\r\n  if (total <= 1) return `rgba(255, 107, 74, 1.0)`;\r\n  const ratio = index / (total - 1);\r\n  const opacity = 1.0 - ratio * 0.7;\r\n  return `rgba(255, 107, 74, ${opacity})`;\r\n};\r\n\r\ninterface UseAnalyticsDataOptions {\r\n  timeRange?: TimeRange;\r\n}\r\n\r\nexport const useAnalyticsData = (options: UseAnalyticsDataOptions = {}) => {\r\n  const { timeRange = 'week' } = options;\r\n  const forceEmptyAnalytics = useDevToolsStore((state) => state.forceEmptyAnalytics);\r\n  const rawWorkouts = useWorkoutSessionsStore((state) => state.workouts);\r\n  const workouts = __DEV__ && forceEmptyAnalytics ? [] : rawWorkouts;\r\n  const userBodyWeight = useUserProfileStore((state) => state.profile?.weightLbs);\r\n  const { convertWeight, weightUnit } = useSettingsStore();\r\n\r\n  // Filter workouts based on time range\r\n  const filteredWorkouts = useMemo(() => {\r\n    return filterByTimeRange(workouts, timeRange);\r\n  }, [workouts, timeRange]);\r\n\r\n  // Calculate cardio statistics\r\n  const cardioStats = useMemo((): CardioStats => {\r\n    let totalDuration = 0;\r\n    const totalDistanceByType: Record<string, number> = {};\r\n    let sessionCount = 0;\r\n\r\n    filteredWorkouts.forEach((workout) => {\r\n      let hasCardio = false;\r\n      workout.exercises.forEach((exercise: any) => {\r\n        const exerciseType = EXERCISE_TYPE_MAP[exercise.name];\r\n        if (exerciseType !== 'cardio') return;\r\n\r\n        hasCardio = true;\r\n        exercise.sets.forEach((set: any) => {\r\n          if (!set.completed) return;\r\n          totalDuration += set.duration || 0;\r\n          if (set.distance) {\r\n            totalDistanceByType[exercise.name] = (totalDistanceByType[exercise.name] || 0) + set.distance;\r\n          }\r\n        });\r\n      });\r\n      if (hasCardio) sessionCount++;\r\n    });\r\n\r\n    return { totalDuration, totalDistanceByType, sessionCount };\r\n  }, [filteredWorkouts]);\r\n\r\n  // Calculate tiered volume data (weight  reps, with body weight for bodyweight/assisted)\r\n  const tieredVolume = useMemo((): TieredVolumeData => {\r\n    const high: Record<string, number> = { 'Upper Body': 0, 'Lower Body': 0, 'Core': 0 };\r\n    const mid: Record<string, number> = {};\r\n    const low: Record<string, number> = {};\r\n\r\n    filteredWorkouts.forEach((workout) => {\r\n      workout.exercises.forEach((exercise: any) => {\r\n        const weights = EXERCISE_MUSCLES[exercise.name];\r\n        if (!weights) return;\r\n\r\n        const exerciseType = EXERCISE_TYPE_MAP[exercise.name] || 'weight';\r\n\r\n        // Skip cardio and duration exercises for volume calculations\r\n        if (exerciseType === 'cardio' || exerciseType === 'duration') return;\r\n\r\n        exercise.sets.forEach((set: any) => {\r\n          if (!set.completed) return;\r\n\r\n          // Calculate set volume based on exercise type\r\n          let setVolume = 0;\r\n          const reps = set.reps ?? 0;\r\n\r\n          switch (exerciseType) {\r\n            case 'bodyweight':\r\n              // Use body weight if available, otherwise skip\r\n              if (userBodyWeight && reps > 0) {\r\n                setVolume = userBodyWeight * reps;\r\n              }\r\n              break;\r\n            case 'assisted':\r\n              // Effective weight = body weight - assistance weight\r\n              if (userBodyWeight && reps > 0) {\r\n                const effectiveWeight = Math.max(0, userBodyWeight - (set.assistanceWeight ?? 0));\r\n                setVolume = effectiveWeight * reps;\r\n              }\r\n              break;\r\n            case 'reps_only':\r\n              // Resistance bands - just count reps (no weight volume)\r\n              // Skip for volume calculations\r\n              return;\r\n            case 'weight':\r\n            default:\r\n              // Standard weight  reps\r\n              if ((set.weight ?? 0) > 0 && reps > 0) {\r\n                setVolume = set.weight * reps;\r\n              }\r\n              break;\r\n          }\r\n\r\n          // Convert volume to user's preferred unit (LBS -> User Unit)\r\n          setVolume = convertWeight(setVolume);\r\n\r\n          if (setVolume <= 0) return;\r\n\r\n          Object.entries(weights).forEach(([muscle, weight]) => {\r\n            const contribution = setVolume * weight;\r\n\r\n            const cat1 = leafToL1[muscle];\r\n            if (cat1 && high[cat1] !== undefined) {\r\n              high[cat1] += contribution;\r\n            }\r\n\r\n            const cat2 = leafToL2[muscle];\r\n            if (cat2) {\r\n              mid[cat2] = (mid[cat2] || 0) + contribution;\r\n            }\r\n\r\n            const cat3 = leafToL3[muscle];\r\n            if (cat3) {\r\n              low[cat3] = (low[cat3] || 0) + contribution;\r\n            }\r\n          });\r\n        });\r\n      });\r\n    });\r\n\r\n    return { high, mid, low };\r\n  }, [filteredWorkouts, userBodyWeight, convertWeight, weightUnit]);\r\n\r\n  // Calculate tiered volume distribution (volume = weight  reps  muscle_weighting)\r\n  // Only includes weight and assisted exercises\r\n  const tieredVolumeDistribution = useMemo((): TieredSetData => {\r\n    const distL1: Record<string, number> = {};\r\n    const distL2: Record<string, number> = {};\r\n    const distL3: Record<string, number> = {};\r\n\r\n    filteredWorkouts.forEach((workout) => {\r\n      workout.exercises.forEach((exercise: any) => {\r\n        const muscleWeights = EXERCISE_MUSCLES[exercise.name];\r\n        if (!muscleWeights) return;\r\n\r\n        const exerciseType = EXERCISE_TYPE_MAP[exercise.name] || 'weight';\r\n\r\n        // Only include weight and assisted exercises (exclude bodyweight and cardio from distribution)\r\n        if (exerciseType !== 'weight' && exerciseType !== 'assisted') return;\r\n\r\n        exercise.sets.forEach((set: any) => {\r\n          if (!set.completed) return;\r\n\r\n          const reps = set.reps ?? 0;\r\n          if (reps <= 0) return;\r\n\r\n          let setVolume = 0;\r\n\r\n          if (exerciseType === 'weight') {\r\n            const weight = set.weight ?? 0;\r\n            if (weight <= 0) return;\r\n            setVolume = weight * reps;\r\n          } else if (exerciseType === 'assisted') {\r\n            // Effective weight = body weight - assistance, clamped to avoid negatives\r\n            if (!userBodyWeight) return;\r\n            const assistanceWeight = set.assistanceWeight ?? 0;\r\n            const effectiveWeight = Math.max(0, userBodyWeight - assistanceWeight);\r\n            if (effectiveWeight <= 0) return;\r\n            setVolume = effectiveWeight * reps;\r\n          }\r\n\r\n          // Convert volume to user's preferred unit\r\n          setVolume = convertWeight(setVolume);\r\n\r\n          if (setVolume <= 0) return;\r\n\r\n          // Distribute volume to muscles based on weightings\r\n          Object.entries(muscleWeights).forEach(([muscle, muscleWeight]) => {\r\n            const contribution = setVolume * muscleWeight;\r\n\r\n            const cat1 = leafToL1[muscle];\r\n            if (cat1) distL1[cat1] = (distL1[cat1] || 0) + contribution;\r\n\r\n            const cat2 = leafToL2[muscle];\r\n            if (cat2) distL2[cat2] = (distL2[cat2] || 0) + contribution;\r\n\r\n            const cat3 = leafToL3[muscle];\r\n            if (cat3) distL3[cat3] = (distL3[cat3] || 0) + contribution;\r\n          });\r\n        });\r\n      });\r\n    });\r\n\r\n    // Format slices with percentages summing to 100% at each level\r\n    const formatSlices = (dist: Record<string, number>): ChartSlice[] => {\r\n      const sorted = Object.entries(dist).sort((a, b) => b[1] - a[1]);\r\n      const total = Object.values(dist).reduce((sum, val) => sum + val, 0);\r\n      if (total === 0) return [];\r\n\r\n      const threshold = total * 0.01; // 1% threshold\r\n      const filtered = sorted.filter(([, value]) => value >= threshold);\r\n      const filteredTotal = filtered.reduce((sum, [, val]) => sum + val, 0);\r\n\r\n      return filtered.map(([name, value], index) => ({\r\n        name,\r\n        value,\r\n        percentage: filteredTotal > 0 ? (value / filteredTotal) * 100 : 0,\r\n        color: generateSliceColor(index, filtered.length),\r\n      }));\r\n    };\r\n\r\n    return {\r\n      high: formatSlices(distL1),\r\n      mid: formatSlices(distL2),\r\n      low: formatSlices(distL3),\r\n    };\r\n  }, [filteredWorkouts, userBodyWeight, convertWeight, weightUnit]);\r\n\r\n  // Calculate hierarchical volume distribution for drill-down navigation\r\n  // Uses same logic as tieredVolumeDistribution but with parent grouping for drill-down\r\n  const hierarchicalVolumeDistribution = useMemo((): HierarchicalSetData => {\r\n    // Build distribution maps at each level with parent tracking\r\n    const distByLevel: Record<string, Record<string, number>> = {};\r\n\r\n    filteredWorkouts.forEach((workout) => {\r\n      workout.exercises.forEach((exercise: any) => {\r\n        const muscleWeights = EXERCISE_MUSCLES[exercise.name];\r\n        if (!muscleWeights) return;\r\n\r\n        const exerciseType = EXERCISE_TYPE_MAP[exercise.name] || 'weight';\r\n\r\n        // Only include weight and assisted exercises (exclude bodyweight and cardio from distribution)\r\n        if (exerciseType !== 'weight' && exerciseType !== 'assisted') return;\r\n\r\n        exercise.sets.forEach((set: any) => {\r\n          if (!set.completed) return;\r\n\r\n          const reps = set.reps ?? 0;\r\n          if (reps <= 0) return;\r\n\r\n          let setVolume = 0;\r\n\r\n          if (exerciseType === 'weight') {\r\n            const weight = set.weight ?? 0;\r\n            if (weight <= 0) return;\r\n            setVolume = weight * reps;\r\n          } else if (exerciseType === 'assisted') {\r\n            // Effective weight = body weight - assistance, clamped to avoid negatives\r\n            if (!userBodyWeight) return;\r\n            const assistanceWeight = set.assistanceWeight ?? 0;\r\n            const effectiveWeight = Math.max(0, userBodyWeight - assistanceWeight);\r\n            if (effectiveWeight <= 0) return;\r\n            setVolume = effectiveWeight * reps;\r\n          }\r\n\r\n          // Convert volume to user's preferred unit\r\n          setVolume = convertWeight(setVolume);\r\n\r\n          if (setVolume <= 0) return;\r\n\r\n          // Distribute volume to muscles based on weightings\r\n          Object.entries(muscleWeights).forEach(([muscle, muscleWeight]) => {\r\n            const contribution = setVolume * muscleWeight;\r\n\r\n            // Track at each level with its parent context\r\n            const l1 = leafToL1[muscle];\r\n            const l2 = leafToL2[muscle];\r\n            const l3 = leafToL3[muscle];\r\n            const l4 = leafToL4[muscle];\r\n\r\n            // Root level (L1): Upper Body, Lower Body, Core\r\n            if (l1) {\r\n              distByLevel['root'] = distByLevel['root'] || {};\r\n              distByLevel['root'][l1] = (distByLevel['root'][l1] || 0) + contribution;\r\n            }\r\n\r\n            // L2 grouped by L1 parent (e.g., \"Upper Body\" -> Chest, Back, Arms, etc.)\r\n            if (l1 && l2) {\r\n              const key = `L1:${l1}`;\r\n              distByLevel[key] = distByLevel[key] || {};\r\n              distByLevel[key][l2] = (distByLevel[key][l2] || 0) + contribution;\r\n            }\r\n\r\n            // L3 grouped by L2 parent (e.g., \"Arms\" -> Biceps, Triceps, Forearms)\r\n            // Only add if L3 exists and is different from L2\r\n            if (l2 && l3 && l2 !== l3) {\r\n              const key = `L2:${l2}`;\r\n              distByLevel[key] = distByLevel[key] || {};\r\n              distByLevel[key][l3] = (distByLevel[key][l3] || 0) + contribution;\r\n            }\r\n\r\n            // L4 grouped by L3 parent (e.g., \"Biceps\" -> Long Head, Short Head, Brachialis)\r\n            // Only add if L4 exists (detailed level muscles)\r\n            if (l3 && l4 && l3 !== l4) {\r\n              const key = `L3:${l3}`;\r\n              distByLevel[key] = distByLevel[key] || {};\r\n              distByLevel[key][l4] = (distByLevel[key][l4] || 0) + contribution;\r\n            }\r\n\r\n            // Special case: when L2 and L3 have the same name (e.g., Calves -> Calves),\r\n            // show L4 children directly under L2 to avoid redundant drill-down\r\n            if (l2 && l3 && l2 === l3 && l4) {\r\n              const key = `L2:${l2}`;\r\n              distByLevel[key] = distByLevel[key] || {};\r\n              distByLevel[key][l4] = (distByLevel[key][l4] || 0) + contribution;\r\n            }\r\n          });\r\n        });\r\n      });\r\n    });\r\n\r\n    // Format slices with percentages summing to 100% at each level\r\n    const formatSlicesForLevel = (dist: Record<string, number>): ChartSlice[] => {\r\n      const sorted = Object.entries(dist).sort((a, b) => b[1] - a[1]);\r\n      const total = Object.values(dist).reduce((sum, val) => sum + val, 0);\r\n      if (total === 0) return [];\r\n\r\n      const threshold = total * 0.01; // 1% threshold\r\n      const filtered = sorted.filter(([, value]) => value >= threshold);\r\n      const filteredTotal = filtered.reduce((sum, [, val]) => sum + val, 0);\r\n\r\n      return filtered.map(([name, value], index) => ({\r\n        name,\r\n        value,\r\n        percentage: filteredTotal > 0 ? (value / filteredTotal) * 100 : 0,\r\n        color: generateSliceColor(index, filtered.length),\r\n      }));\r\n    };\r\n\r\n    // Build the result\r\n    const byParent: Record<string, ChartSlice[]> = {};\r\n    Object.entries(distByLevel).forEach(([key, dist]) => {\r\n      if (key !== 'root') {\r\n        byParent[key] = formatSlicesForLevel(dist);\r\n      }\r\n    });\r\n\r\n    return {\r\n      root: formatSlicesForLevel(distByLevel['root'] || {}),\r\n      byParent,\r\n    };\r\n  }, [filteredWorkouts, userBodyWeight, convertWeight, weightUnit]);\r\n\r\n  // Weekly volume bar chart data\r\n  const weeklyVolume = useMemo((): WeeklyVolumeData => {\r\n    const formatBarData = (labels: string[], values: number[]): BarChartData[] =>\r\n      labels.map((label, i) => ({\r\n        label,\r\n        value: Math.round(values[i] || 0),\r\n      }));\r\n\r\n    const getL2Data = (parentL1: string): BarChartData[] => {\r\n      const muscles = Object.keys(\r\n        (hierarchyData.muscle_hierarchy as any)[parentL1]?.muscles || {}\r\n      );\r\n      const values = muscles.map((m) => tieredVolume.mid[m] || 0);\r\n      const labels = muscles.map((m) => {\r\n        if (m === 'Hip Stabilizers') return 'Hips';\r\n        if (m === 'Hamstrings') return 'Hams';\r\n        return m;\r\n      });\r\n      return formatBarData(labels, values);\r\n    };\r\n\r\n    return {\r\n      high: formatBarData(\r\n        ['Upper\\nBody', 'Lower\\nBody', 'Core'],\r\n        [tieredVolume.high['Upper Body'], tieredVolume.high['Lower Body'], tieredVolume.high['Core']]\r\n      ),\r\n      byBodyPart: {\r\n        upper: getL2Data('Upper Body'),\r\n        lower: getL2Data('Lower Body'),\r\n        core: getL2Data('Core'),\r\n      },\r\n    };\r\n  }, [tieredVolume]);\r\n\r\n  // Streak and consistency data\r\n  const streakData = useMemo((): StreakData => {\r\n    const now = new Date();\r\n    const today = now.toISOString().split('T')[0];\r\n\r\n    // Sort workouts by date descending\r\n    const sortedDates = [...new Set(workouts.map((w) => w.date.split('T')[0]))]\r\n      .sort((a, b) => new Date(b).getTime() - new Date(a).getTime());\r\n\r\n    // Calculate current streak\r\n    let currentStreak = 0;\r\n    let checkDate = new Date(today);\r\n\r\n    for (const date of sortedDates) {\r\n      const workoutDate = new Date(date);\r\n      const diffDays = Math.floor(\r\n        (checkDate.getTime() - workoutDate.getTime()) / (1000 * 60 * 60 * 24)\r\n      );\r\n\r\n      if (diffDays <= 1) {\r\n        currentStreak++;\r\n        checkDate = workoutDate;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Calculate longest streak\r\n    let longestStreak = 0;\r\n    let tempStreak = 0;\r\n    let prevDate: Date | null = null;\r\n\r\n    for (const date of sortedDates.reverse()) {\r\n      const workoutDate = new Date(date);\r\n      if (prevDate) {\r\n        const diff = Math.floor(\r\n          (workoutDate.getTime() - prevDate.getTime()) / (1000 * 60 * 60 * 24)\r\n        );\r\n        if (diff <= 1) {\r\n          tempStreak++;\r\n        } else {\r\n          longestStreak = Math.max(longestStreak, tempStreak);\r\n          tempStreak = 1;\r\n        }\r\n      } else {\r\n        tempStreak = 1;\r\n      }\r\n      prevDate = workoutDate;\r\n    }\r\n    longestStreak = Math.max(longestStreak, tempStreak);\r\n\r\n    // Workouts this week\r\n    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\r\n    const workoutsThisWeek = workouts.filter(\r\n      (w) => new Date(w.date) >= weekAgo\r\n    ).length;\r\n\r\n    // Workouts this month\r\n    const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\r\n    const workoutsThisMonth = workouts.filter(\r\n      (w) => new Date(w.date) >= monthAgo\r\n    ).length;\r\n\r\n    // Average per week (last 4 weeks)\r\n    const fourWeeksAgo = new Date(now.getTime() - 28 * 24 * 60 * 60 * 1000);\r\n    const recentWorkouts = workouts.filter((w) => new Date(w.date) >= fourWeeksAgo);\r\n    const averagePerWeek = recentWorkouts.length / 4;\r\n\r\n    return {\r\n      currentStreak,\r\n      longestStreak,\r\n      workoutsThisWeek,\r\n      workoutsThisMonth,\r\n      averagePerWeek: Math.round(averagePerWeek * 10) / 10,\r\n    };\r\n  }, [workouts]);\r\n\r\n  // Volume trend data over time - returns date-indexed volume data\r\n  const volumeTrendData = useMemo((): Record<string, number> => {\r\n    if (filteredWorkouts.length === 0) return {};\r\n\r\n    // Group workouts by date and calculate total volume per day\r\n    const volumeByDate: Record<string, number> = {};\r\n\r\n    filteredWorkouts.forEach((workout) => {\r\n      // Bucket by LOCAL calendar day so \"today\" always shows up on the 7-day chart\r\n      const dateKey = formatLocalDate(new Date(workout.startTime ?? workout.date));\r\n      \r\n      workout.exercises.forEach((exercise: any) => {\r\n        const exerciseType = EXERCISE_TYPE_MAP[exercise.name] || 'weight';\r\n        \r\n        // Skip cardio and pure duration exercises\r\n        if (exerciseType === 'cardio' || exerciseType === 'duration') {\r\n          return;\r\n        }\r\n\r\n        exercise.sets.forEach((set: any) => {\r\n          if (!set.completed) return;\r\n          \r\n          const reps = set.reps ?? 0;\r\n          if (reps <= 0) return;\r\n\r\n          let setVolume = 0;\r\n\r\n          switch (exerciseType) {\r\n            case 'bodyweight':\r\n              if (userBodyWeight && userBodyWeight > 0) {\r\n                setVolume = userBodyWeight * reps;\r\n              }\r\n              break;\r\n            case 'assisted':\r\n              if (userBodyWeight && userBodyWeight > 0) {\r\n                const assistance = set.assistanceWeight ?? 0;\r\n                const effective = Math.max(0, userBodyWeight - assistance);\r\n                if (effective > 0) {\r\n                  setVolume = effective * reps;\r\n                }\r\n              }\r\n              break;\r\n            case 'reps_only':\r\n              // Bands etc  do not contribute to volume\r\n              setVolume = 0;\r\n              break;\r\n            case 'weight':\r\n            default:\r\n              const weight = set.weight ?? 0;\r\n              if (weight > 0) {\r\n                setVolume = weight * reps;\r\n              }\r\n              break;\r\n          }\r\n\r\n          if (setVolume > 0) {\r\n            // Convert to user's preferred unit\r\n            const convertedVolume = convertWeight(setVolume);\r\n            volumeByDate[dateKey] = (volumeByDate[dateKey] || 0) + convertedVolume;\r\n          }\r\n        });\r\n      });\r\n    });\r\n\r\n    // Return date-indexed volume data (YYYY-MM-DD -> volume)\r\n    return volumeByDate;\r\n  }, [filteredWorkouts, userBodyWeight, convertWeight, timeRange]);\r\n\r\n  // Check if there's any data\r\n  const hasData = workouts.length > 0;\r\n  const hasFilteredData = filteredWorkouts.length > 0;\r\n\r\n  return {\r\n    // Raw data\r\n    workouts,\r\n    filteredWorkouts,\r\n\r\n    // Processed data\r\n    tieredVolume,\r\n    tieredVolumeDistribution,\r\n    hierarchicalVolumeDistribution,\r\n    weeklyVolume,\r\n    streakData,\r\n    cardioStats,\r\n    volumeTrendData,\r\n\r\n    // State\r\n    hasData,\r\n    hasFilteredData,\r\n\r\n    // Utilities\r\n    leafToL1,\r\n    leafToL2,\r\n    leafToL3,\r\n    l2ToL1,\r\n    EXERCISE_MUSCLES,\r\n  };\r\n};\r\n\r\nexport type { TieredVolumeData, TieredSetData, HierarchicalSetData, WeeklyVolumeData, StreakData, CardioStats };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\hooks\\useColorScheme.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\hooks\\useCreatePlanBuilder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\hooks\\useElapsedTimer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\hooks\\useGpsTracking.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\hooks\\useInsightsData.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\hooks\\useMonthlyCalendar.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'DAY_MS' is assigned a value but never used.","line":31,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":31,"endColumn":13}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback, useEffect, useMemo, useState } from 'react';\n\nimport {\n  formatDateToLocalISO,\n  getDeviceCurrentDate,\n  getTodayLocalISO,\n  parseLocalISODate,\n} from '@/utils/date';\n\nexport interface UseMonthlyCalendarOptions {\n  initialMonth?: string;\n  selectedDate?: string;\n  markers?: string[];\n  onSelectDate?: (isoDate: string) => void;\n  locale?: string;\n  currentMonth?: string;\n  onCurrentMonthChange?: (isoDate: string) => void;\n}\n\nexport interface CalendarGridItem {\n  isoDate: string;\n  date: Date;\n  dayLabel: string;\n  isCurrentMonth: boolean;\n  isToday: boolean;\n  isSelected: boolean;\n  hasMarker: boolean;\n}\n\nconst DAYS_IN_GRID = 42;\nconst DAY_MS = 86_400_000;\n\nconst createDateFromISO = (iso?: string): Date => {\n  if (!iso) return getDeviceCurrentDate();\n  return parseLocalISODate(iso);\n};\n\nconst startOfMonth = (date: Date): Date => new Date(date.getFullYear(), date.getMonth(), 1);\n\nconst getGridDates = (referenceDate: Date): Date[] => {\n  const firstOfMonth = startOfMonth(referenceDate);\n  const sundayOffset = firstOfMonth.getDay();\n  const startDate = new Date(firstOfMonth);\n  startDate.setDate(firstOfMonth.getDate() - sundayOffset);\n  return Array.from({ length: DAYS_IN_GRID }, (_, index) => {\n    const date = new Date(startDate);\n    date.setDate(startDate.getDate() + index);\n    return date;\n  });\n};\n\nconst getWeekdayLabels = (formatter: Intl.DateTimeFormat): string[] => {\n  const sundayReference = new Date(2024, 0, 7, 12); // Local Sunday at noon avoids timezone drift\n  return [0, 1, 2, 3, 4, 5, 6].map((offset) => {\n    const day = new Date(sundayReference);\n    day.setDate(sundayReference.getDate() + offset);\n    return formatter.format(day);\n  });\n};\n\nexport const useMonthlyCalendar = (options: UseMonthlyCalendarOptions = {}) => {\n  const {\n    initialMonth,\n    selectedDate,\n    markers = [],\n    onSelectDate,\n    locale = 'en-US',\n    currentMonth,\n    onCurrentMonthChange,\n  } = options;\n\n  const todayISO = useMemo(() => getTodayLocalISO(), []);\n  const [visibleMonth, setVisibleMonth] = useState<Date>(() =>\n    startOfMonth(createDateFromISO(initialMonth ?? todayISO))\n  );\n  const [internalSelectedDate, setInternalSelectedDate] = useState<string>(selectedDate ?? todayISO);\n\n  useEffect(() => {\n    if (!selectedDate) return;\n    setInternalSelectedDate(selectedDate);\n    const nextVisible = startOfMonth(createDateFromISO(selectedDate));\n    setVisibleMonth((prev) =>\n      prev.getFullYear() === nextVisible.getFullYear() && prev.getMonth() === nextVisible.getMonth()\n        ? prev\n        : nextVisible\n    );\n  }, [selectedDate]);\n\n  useEffect(() => {\n    if (!currentMonth) return;\n    const nextVisible = startOfMonth(createDateFromISO(currentMonth));\n    setVisibleMonth((prev) =>\n      prev.getFullYear() === nextVisible.getFullYear() && prev.getMonth() === nextVisible.getMonth()\n        ? prev\n        : nextVisible\n    );\n  }, [currentMonth]);\n\n  const markerSet = useMemo(() => new Set(markers), [markers]);\n  const monthFormatter = useMemo(\n    () => new Intl.DateTimeFormat(locale, { month: 'long', year: 'numeric' }),\n    [locale]\n  );\n  const weekdayFormatter = useMemo(\n    () => new Intl.DateTimeFormat(locale, { weekday: 'short' }),\n    [locale]\n  );\n\n  const weekdayLabels = useMemo(() => getWeekdayLabels(weekdayFormatter), [weekdayFormatter]);\n  const gridDates = useMemo(() => getGridDates(visibleMonth), [visibleMonth]);\n\n  const gridItems = useMemo<CalendarGridItem[]>(\n    () =>\n      gridDates.map((date) => {\n        const isoDate = formatDateToLocalISO(date);\n        return {\n          isoDate,\n          date,\n          dayLabel: `${date.getDate()}`,\n          isCurrentMonth: date.getMonth() === visibleMonth.getMonth(),\n          isToday: isoDate === todayISO,\n          isSelected: isoDate === internalSelectedDate,\n          hasMarker: markerSet.has(isoDate),\n        };\n      }),\n    [gridDates, internalSelectedDate, markerSet, todayISO, visibleMonth]\n  );\n\n  const monthLabel = useMemo(() => monthFormatter.format(visibleMonth), [monthFormatter, visibleMonth]);\n\n  const changeMonth = useCallback(\n    (offset: number) => {\n      setVisibleMonth((prev) => {\n        const newDate = new Date(prev.getFullYear(), prev.getMonth() + offset, 1);\n        onCurrentMonthChange?.(formatDateToLocalISO(newDate));\n        return newDate;\n      });\n    },\n    [onCurrentMonthChange]\n  );\n\n  const selectDate = useCallback(\n    (isoDate: string) => {\n      setInternalSelectedDate(isoDate);\n      const targetMonth = startOfMonth(createDateFromISO(isoDate));\n      setVisibleMonth((prev) =>\n        prev.getFullYear() === targetMonth.getFullYear() && prev.getMonth() === targetMonth.getMonth()\n          ? prev\n          : targetMonth\n      );\n      onSelectDate?.(isoDate);\n    },\n    [onSelectDate]\n  );\n\n  return {\n    monthLabel,\n    weekdayLabels,\n    gridItems,\n    visibleMonth,\n    selectedDate: internalSelectedDate,\n    todayISO,\n    goToPreviousMonth: () => changeMonth(-1),\n    goToNextMonth: () => changeMonth(1),\n    selectDate,\n  } as const;\n};\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\hooks\\usePlanBuilder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\hooks\\usePlanBuilderState.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'triggerHaptic' is defined but never used.","line":2,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_' is assigned a value but never used.","line":156,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":156,"endColumn":15},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'setIsLoading'. Either include it or remove the dependency array.","line":251,"column":6,"nodeType":"ArrayExpression","endLine":251,"endColumn":71,"suggestions":[{"desc":"Update the dependencies array to be: [editingPlan, editingPlanId, arePlansLoading, areProgramsLoading, setIsLoading]","fix":{"range":[9724,9789],"text":"[editingPlan, editingPlanId, arePlansLoading, areProgramsLoading, setIsLoading]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'setIsLoading'. Either include it or remove the dependency array.","line":263,"column":6,"nodeType":"ArrayExpression","endLine":263,"endColumn":17,"suggestions":[{"desc":"Update the dependencies array to be: [isLoading, setIsLoading]","fix":{"range":[10177,10188],"text":"[isLoading, setIsLoading]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'setIsLoading'. Either include it or remove the dependency array.","line":275,"column":6,"nodeType":"ArrayExpression","endLine":275,"endColumn":17,"suggestions":[{"desc":"Update the dependencies array to be: [isEditing, setIsLoading]","fix":{"range":[10441,10452],"text":"[isEditing, setIsLoading]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback, useEffect, useLayoutEffect, useMemo, useRef, useState } from 'react';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\n\r\nimport {\r\n  exercises as baseExercises,\r\n  exerciseFilterOptions,\r\n  type Exercise,\r\n  type ExerciseCatalogItem,\r\n  createCustomExerciseCatalogItem,\r\n} from '@/constants/exercises';\r\nimport { usePlansStore, type Plan } from '@/store/plansStore';\r\nimport { useProgramsStore } from '@/store/programsStore';\r\nimport { useCustomExerciseStore } from '@/store/customExerciseStore';\r\nimport { useSemanticExerciseSearch } from '@/hooks/useSemanticExerciseSearch';\r\nimport {\r\n  type ExerciseFilters,\r\n  type FilterDifficulty,\r\n  type FilterEquipment,\r\n  type FilterMuscleGroup,\r\n  type MuscleGroup,\r\n} from '@/types/exercise';\r\nimport {\r\n  createDefaultExerciseFilters,\r\n  matchesExerciseFilters,\r\n  toggleFilterValue,\r\n  countActiveFilters,\r\n} from '@/utils/exerciseFilters';\r\nimport { normalizeSearchText } from '@/utils/strings';\r\n\r\ninterface PlanBuilderState {\r\n  planName: string;\r\n  setPlanName: (value: string) => void;\r\n  searchTerm: string;\r\n  setSearchTerm: (value: string) => void;\r\n  selectedExercises: Exercise[];\r\n  isEditing: boolean;\r\n  isEditingPlanMissing: boolean;\r\n  isLoading: boolean;\r\n  suggestions: Exercise[];\r\n  availableExercises: Exercise[];\r\n  filteredAvailableExercises: Exercise[];\r\n  headerTitle: string;\r\n  headerSubtitle: string;\r\n  handleAddExercise: (exercise: Exercise) => void;\r\n  handleAddExercises: (exercisesToAdd: Exercise[]) => void;\r\n  handleRemoveExercise: (exerciseId: string) => void;\r\n  handleReorderExercise: (exerciseId: string, direction: 1 | -1) => void;\r\n  handleReorderExercises: (fromIndex: number, toIndex: number) => void;\r\n  resetBuilder: () => void;\r\n  editingPlanCreatedAt: number | null;\r\n  filters: ExerciseFilters;\r\n  toggleMuscleGroupFilter: (value: FilterMuscleGroup) => void;\r\n  toggleSpecificMuscleFilter: (value: MuscleGroup) => void;\r\n  toggleEquipmentFilter: (value: FilterEquipment) => void;\r\n  toggleDifficultyFilter: (value: FilterDifficulty) => void;\r\n  toggleBodyweightOnly: () => void;\r\n  toggleCompoundOnly: () => void;\r\n  resetFilters: () => void;\r\n  updateFilters: (newFilters: ExerciseFilters) => void;\r\n  filterOptions: typeof exerciseFilterOptions;\r\n  setIsLoading: (loading: boolean) => void;\r\n}\r\n\r\nexport const usePlanBuilderState = (editingPlanId: string | null): PlanBuilderState => {\r\n  const [planName, setPlanName] = useState<string>('');\r\n  const [searchTerm, setSearchTerm] = useState<string>('');\r\n  const [selectedExercises, setSelectedExercises] = useState<Exercise[]>([]);\r\n  const [filters, setFilters] = useState<ExerciseFilters>(() => createDefaultExerciseFilters());\r\n  const [isLoading, setIsLoadingState] = useState<boolean>(true); // Start with loading true to prevent flash\r\n  const hasInitializedFromPlan = useRef<boolean>(false);\r\n  const previousEditingPlanId = useRef<string | null>(null);\r\n  const loadingStartTime = useRef<number>(Date.now());\r\n  const pendingLoadingChange = useRef<ReturnType<typeof setTimeout> | null>(null);\r\n\r\n  // Minimum loading duration to prevent flash (ms)\r\n  const MIN_LOADING_DURATION = 150;\r\n\r\n  // Wrapper for setIsLoading that ensures minimum duration and waits for next paint\r\n  const setIsLoading = useCallback((loading: boolean) => {\r\n    // Clear any pending loading change\r\n    if (pendingLoadingChange.current) {\r\n      clearTimeout(pendingLoadingChange.current);\r\n      pendingLoadingChange.current = null;\r\n    }\r\n\r\n    if (loading) {\r\n      // When turning ON loading, do it immediately\r\n      loadingStartTime.current = Date.now();\r\n      setIsLoadingState(true);\r\n    } else {\r\n      // When turning OFF loading, ensure minimum duration and wait for next frame\r\n      const elapsed = Date.now() - loadingStartTime.current;\r\n      const remaining = Math.max(0, MIN_LOADING_DURATION - elapsed);\r\n\r\n      pendingLoadingChange.current = setTimeout(() => {\r\n        // Wait for next animation frame to ensure content is painted\r\n        requestAnimationFrame(() => {\r\n          requestAnimationFrame(() => {\r\n            setIsLoadingState(false);\r\n          });\r\n        });\r\n      }, remaining);\r\n    }\r\n  }, []);\r\n\r\n  useLayoutEffect(() => {\r\n    const editingChanged = previousEditingPlanId.current !== editingPlanId;\r\n    previousEditingPlanId.current = editingPlanId;\r\n    hasInitializedFromPlan.current = false;\r\n\r\n    if (editingPlanId && editingChanged) {\r\n      setPlanName('');\r\n      setSelectedExercises([]);\r\n      setSearchTerm('');\r\n      setFilters(createDefaultExerciseFilters());\r\n    }\r\n\r\n    // Always start with loading true when editingPlanId changes\r\n    // This ensures loading state is active immediately when entering edit mode\r\n    if (editingPlanId) {\r\n      loadingStartTime.current = Date.now();\r\n      setIsLoadingState(true);\r\n    } else {\r\n      // For create mode, hide loading after ensuring content is ready\r\n      setIsLoading(false);\r\n    }\r\n\r\n    // Cleanup pending loading changes on unmount\r\n    return () => {\r\n      if (pendingLoadingChange.current) {\r\n        clearTimeout(pendingLoadingChange.current);\r\n      }\r\n    };\r\n  }, [editingPlanId, setIsLoading]);\r\n\r\n  const plans = usePlansStore((state) => state.plans);\r\n  const arePlansLoading = usePlansStore((state) => state.isLoading);\r\n  const { userPrograms, isLoading: areProgramsLoading } = useProgramsStore();\r\n  const customExercises = useCustomExerciseStore((state) => state.customExercises);\r\n\r\n  // Merge base catalog with custom exercises\r\n  const allExercises = useMemo<ExerciseCatalogItem[]>(() => {\r\n    const customCatalogItems = customExercises.map((ce) =>\r\n      createCustomExerciseCatalogItem(ce.id, ce.name, ce.exerciseType)\r\n    );\r\n    return [...baseExercises, ...customCatalogItems];\r\n  }, [customExercises]);\r\n\r\n  const editingPlan = useMemo<Plan | null>(() => {\r\n    if (!editingPlanId) {\r\n      return null;\r\n    }\r\n\r\n    // Handle program workout editing (program:programId:workoutId)\r\n    if (editingPlanId.startsWith('program:')) {\r\n      const [_, programId, workoutId] = editingPlanId.split(':');\r\n      const program = userPrograms.find(p => p.id === programId);\r\n      const workout = program?.workouts.find(w => w.id === workoutId);\r\n\r\n      if (workout) {\r\n        // Create fresh copies of exercises to prevent mutations affecting the program data\r\n        // CRITICAL FIX: Don't filter out exercises that aren't in the catalog!\r\n        // AI-generated exercises may have slightly different names than catalog entries\r\n        const mappedExercises = workout.exercises\r\n          .map(ex => {\r\n            // Try to find exact match in catalog first\r\n            const found = allExercises.find(e => e.name.toLowerCase() === ex.name.toLowerCase());\r\n            if (found) {\r\n              return { ...found };\r\n            }\r\n            \r\n            // If not found, create a placeholder exercise from the stored data.\r\n            // This ensures AI-created exercises are preserved even if not in catalog.\r\n            const rawType = (ex as any).exerciseType;\r\n            const normalizedType: ExerciseCatalogItem['exerciseType'] = (\r\n              ['weight', 'cardio', 'bodyweight', 'assisted', 'reps_only', 'duration'] as const\r\n            ).includes(rawType)\r\n              ? rawType\r\n              : 'weight';\r\n\r\n            const placeholder = createCustomExerciseCatalogItem(\r\n              ex.id || `ai-exercise-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\r\n              ex.name,\r\n              normalizedType\r\n            );\r\n\r\n            const muscles =\r\n              (ex as any).muscles && typeof (ex as any).muscles === 'object' && !Array.isArray((ex as any).muscles)\r\n                ? (ex as any).muscles\r\n                : {};\r\n\r\n            return {\r\n              ...placeholder,\r\n              muscles,\r\n            };\r\n          });\r\n\r\n        console.log('[usePlanBuilderState] Loaded program workout:', workout.name, 'with', mappedExercises.length, 'exercises');\r\n\r\n        return {\r\n          id: workout.id,\r\n          name: workout.name,\r\n          exercises: mappedExercises,\r\n          createdAt: Date.now(),\r\n        } as Plan;\r\n      }\r\n      return null;\r\n    }\r\n\r\n    // Regular plan lookup from plansStore\r\n    const plan = plans.find((p) => p.id === editingPlanId);\r\n    if (!plan) return null;\r\n\r\n    // Resolve exercises from all available (including custom)\r\n    const resolvedExercises = plan.exercises.map(ex => {\r\n      const found = allExercises.find(e => e.name === ex.name);\r\n      return found ? { ...found } : ex;\r\n    });\r\n\r\n    return {\r\n      ...plan,\r\n      exercises: resolvedExercises,\r\n    };\r\n  }, [editingPlanId, plans, userPrograms, allExercises]);\r\n\r\n  const isEditing = Boolean(editingPlanId);\r\n\r\n  const hasActiveFilters = useMemo<boolean>(() => countActiveFilters(filters) > 0, [filters]);\r\n\r\n  // Handle the actual data loading and completion\r\n  useEffect(() => {\r\n    if (!editingPlanId) {\r\n      // Not editing, ensure loading is false\r\n      setIsLoading(false);\r\n      return;\r\n    }\r\n\r\n    if (editingPlan && !hasInitializedFromPlan.current) {\r\n      // We have the plan data and haven't initialized yet\r\n      // Initialize immediately for fast, responsive loading\r\n      setPlanName(editingPlan.name);\r\n      setSelectedExercises(editingPlan.exercises);\r\n      setSearchTerm('');\r\n      setFilters(createDefaultExerciseFilters());\r\n      hasInitializedFromPlan.current = true;\r\n      setIsLoading(false);\r\n    } else if (!arePlansLoading && !areProgramsLoading && !editingPlan && !hasInitializedFromPlan.current) {\r\n      // Stores are loaded but plan is missing, show error state\r\n      setIsLoading(false);\r\n    }\r\n  }, [editingPlan, editingPlanId, arePlansLoading, areProgramsLoading]);\r\n\r\n  // Safety timeout: If loading takes too long (e.g. race condition or stuck state), force exit\r\n  useEffect(() => {\r\n    if (isLoading) {\r\n      const timeoutId = setTimeout(() => {\r\n        console.warn('[usePlanBuilderState] Loading timeout reached, forcing completion');\r\n        setIsLoading(false);\r\n      }, 5000);\r\n\r\n      return () => clearTimeout(timeoutId);\r\n    }\r\n  }, [isLoading]);\r\n\r\n  const resetBuilder = useCallback(() => {\r\n    if (isEditing) {\r\n      return;\r\n    }\r\n\r\n    setPlanName('');\r\n    setSelectedExercises([]);\r\n    setSearchTerm('');\r\n    setFilters(createDefaultExerciseFilters());\r\n    setIsLoading(false);\r\n  }, [isEditing]);\r\n\r\n  const updateFilters = useCallback((newFilters: ExerciseFilters) => {\r\n    setFilters(newFilters);\r\n  }, []);\r\n\r\n  const toggleMuscleGroupFilter = useCallback((value: FilterMuscleGroup) => {\r\n    setFilters((prev: ExerciseFilters) => ({\r\n      ...prev,\r\n      muscleGroups: toggleFilterValue(prev.muscleGroups, value),\r\n    }));\r\n  }, []);\r\n\r\n  const toggleSpecificMuscleFilter = useCallback((value: MuscleGroup) => {\r\n    setFilters((prev: ExerciseFilters) => ({\r\n      ...prev,\r\n      specificMuscles: toggleFilterValue(prev.specificMuscles, value),\r\n    }));\r\n  }, []);\r\n\r\n  const toggleEquipmentFilter = useCallback((value: FilterEquipment) => {\r\n    setFilters((prev: ExerciseFilters) => ({\r\n      ...prev,\r\n      equipment: toggleFilterValue(prev.equipment, value),\r\n    }));\r\n  }, []);\r\n\r\n  const toggleDifficultyFilter = useCallback((value: FilterDifficulty) => {\r\n    setFilters((prev: ExerciseFilters) => ({\r\n      ...prev,\r\n      difficulty: toggleFilterValue(prev.difficulty, value),\r\n    }));\r\n  }, []);\r\n\r\n  const toggleBodyweightOnly = useCallback(() => {\r\n    setFilters((prev: ExerciseFilters) => ({ ...prev, bodyweightOnly: !prev.bodyweightOnly }));\r\n  }, []);\r\n\r\n  const toggleCompoundOnly = useCallback(() => {\r\n    setFilters((prev: ExerciseFilters) => ({ ...prev, compoundOnly: !prev.compoundOnly }));\r\n  }, []);\r\n\r\n  const resetFilters = useCallback(() => {\r\n    setFilters(createDefaultExerciseFilters());\r\n  }, []);\r\n\r\n  const availableCatalogExercises = useMemo<ExerciseCatalogItem[]>(() => {\r\n    const selectedIds = new Set(selectedExercises.map((exercise) => exercise.id));\r\n    return allExercises.filter((exercise) => !selectedIds.has(exercise.id));\r\n  }, [selectedExercises, allExercises]);\r\n\r\n  const catalogFilteredByFilters = useMemo<ExerciseCatalogItem[]>(\r\n    () => availableCatalogExercises.filter((exercise) => matchesExerciseFilters(exercise, filters)),\r\n    [availableCatalogExercises, filters],\r\n  );\r\n\r\n  const normalizedSearchQuery = useMemo(() => normalizeSearchText(searchTerm), [searchTerm]);\r\n\r\n  const hasSearchTerm = normalizedSearchQuery.length > 0;\r\n\r\n  const searchTokens = useMemo(() => {\r\n    if (!normalizedSearchQuery) {\r\n      return [] as string[];\r\n    }\r\n\r\n    return normalizedSearchQuery.split(' ').filter(Boolean);\r\n  }, [normalizedSearchQuery]);\r\n\r\n  const matchesSearchTokens = useCallback(\r\n    (exercise: ExerciseCatalogItem) => {\r\n      if (searchTokens.length === 0) {\r\n        return true;\r\n      }\r\n\r\n      const normalizedName = normalizeSearchText(exercise.name);\r\n\r\n      return searchTokens.every((token) => {\r\n        // For short tokens (1-2 chars), require word-start match\r\n        if (token.length <= 2) {\r\n          return normalizedName.startsWith(token) || normalizedName.includes(` ${token}`);\r\n        }\r\n\r\n        // For longer tokens, check name first (word-boundary aware), then searchIndex\r\n        if (normalizedName.includes(token)) {\r\n          return true;\r\n        }\r\n\r\n        // Only check searchIndex for 3+ char tokens to avoid noise\r\n        return exercise.searchIndex.includes(token);\r\n      });\r\n    },\r\n    [searchTokens],\r\n  );\r\n\r\n  const semanticFilteredAvailable = useSemanticExerciseSearch(searchTerm, catalogFilteredByFilters, {\r\n    limit: catalogFilteredByFilters.length,\r\n  });\r\n\r\n  const filteredAvailableExercises = useMemo<Exercise[]>(() => {\r\n    let result: Exercise[];\r\n\r\n    if (searchTokens.length === 0) {\r\n      result = catalogFilteredByFilters;\r\n    } else {\r\n      const tokenMatches = catalogFilteredByFilters.filter(matchesSearchTokens);\r\n\r\n      if (semanticFilteredAvailable.length === 0) {\r\n        result = tokenMatches;\r\n      } else if (tokenMatches.length === 0) {\r\n        result = semanticFilteredAvailable;\r\n      } else {\r\n        const tokenMatchIds = new Set(tokenMatches.map((exercise) => exercise.id));\r\n        const intersection = semanticFilteredAvailable.filter((exercise) => tokenMatchIds.has(exercise.id));\r\n\r\n        if (intersection.length > 0) {\r\n          result = intersection;\r\n        } else {\r\n          result = semanticFilteredAvailable;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Sort alphabetically A-Z by name only if not searching\r\n    if (searchTokens.length === 0) {\r\n      return result.sort((a, b) => a.name.localeCompare(b.name));\r\n    }\r\n\r\n    return result;\r\n  }, [\r\n    catalogFilteredByFilters,\r\n    matchesSearchTokens,\r\n    searchTokens,\r\n    semanticFilteredAvailable,\r\n  ]);\r\n\r\n  const suggestions = useMemo<Exercise[]>(\r\n    () => {\r\n      if (hasSearchTerm) {\r\n        return filteredAvailableExercises;\r\n      }\r\n\r\n      if (hasActiveFilters) {\r\n        return catalogFilteredByFilters;\r\n      }\r\n\r\n      return availableCatalogExercises;\r\n    },\r\n    [\r\n      availableCatalogExercises,\r\n      catalogFilteredByFilters,\r\n      filteredAvailableExercises,\r\n      hasActiveFilters,\r\n      hasSearchTerm,\r\n    ],\r\n  );\r\n\r\n  const handleAddExercise = useCallback((exercise: Exercise) => {\r\n    setSelectedExercises((prev) => (prev.some((item) => item.id === exercise.id) ? prev : [...prev, exercise]));\r\n  }, []);\r\n\r\n  const handleAddExercises = useCallback((exercisesToAdd: Exercise[]) => {\r\n    if (exercisesToAdd.length === 0) {\r\n      return;\r\n    }\r\n\r\n    setSelectedExercises((prev) => {\r\n      const existingIds = new Set(prev.map((exercise) => exercise.id));\r\n      const next = [...prev];\r\n\r\n      exercisesToAdd.forEach((exercise) => {\r\n        if (!existingIds.has(exercise.id)) {\r\n          existingIds.add(exercise.id);\r\n          next.push(exercise);\r\n        }\r\n      });\r\n\r\n      return next;\r\n    });\r\n  }, []);\r\n\r\n  const handleRemoveExercise = useCallback((exerciseId: string) => {\r\n    setSelectedExercises((prev) => prev.filter((exercise) => exercise.id !== exerciseId));\r\n  }, []);\r\n\r\n  const handleReorderExercise = useCallback((exerciseId: string, direction: 1 | -1) => {\r\n    setSelectedExercises((prev) => {\r\n      const currentIndex = prev.findIndex((exercise) => exercise.id === exerciseId);\r\n\r\n      if (currentIndex === -1) {\r\n        return prev;\r\n      }\r\n\r\n      const nextIndex = currentIndex + direction;\r\n\r\n      if (nextIndex < 0 || nextIndex >= prev.length) {\r\n        return prev;\r\n      }\r\n\r\n      const next = [...prev];\r\n      const [moved] = next.splice(currentIndex, 1);\r\n      next.splice(nextIndex, 0, moved);\r\n      return next;\r\n    });\r\n  }, []);\r\n\r\n  const handleReorderExercises = useCallback((fromIndex: number, toIndex: number) => {\r\n    setSelectedExercises((prev) => {\r\n      if (fromIndex < 0 || fromIndex >= prev.length || toIndex < 0 || toIndex >= prev.length) {\r\n        return prev;\r\n      }\r\n\r\n      const next = [...prev];\r\n      const [moved] = next.splice(fromIndex, 1);\r\n      next.splice(toIndex, 0, moved);\r\n      return next;\r\n    });\r\n  }, []);\r\n\r\n  let headerTitle = 'Create Workout';\r\n  let headerSubtitle = 'Build your workout template';\r\n\r\n  if (isEditing) {\r\n    headerTitle = 'Edit Workout';\r\n    headerSubtitle = 'Update your workout template';\r\n  }\r\n  const editingPlanCreatedAt = editingPlan?.createdAt ?? null;\r\n  const isEditingPlanMissing = isEditing && !editingPlan;\r\n\r\n  return {\r\n    planName,\r\n    setPlanName,\r\n    searchTerm,\r\n    setSearchTerm,\r\n    selectedExercises,\r\n    isEditing,\r\n    isEditingPlanMissing,\r\n    isLoading,\r\n    suggestions,\r\n    availableExercises: availableCatalogExercises,\r\n    filteredAvailableExercises,\r\n    headerTitle,\r\n    headerSubtitle,\r\n    handleAddExercise,\r\n    handleAddExercises,\r\n    handleRemoveExercise,\r\n    handleReorderExercise,\r\n    handleReorderExercises,\r\n    resetBuilder,\r\n    editingPlanCreatedAt,\r\n    filters,\r\n    toggleMuscleGroupFilter,\r\n    toggleSpecificMuscleFilter,\r\n    toggleEquipmentFilter,\r\n    toggleDifficultyFilter,\r\n    toggleBodyweightOnly,\r\n    toggleCompoundOnly,\r\n    resetFilters,\r\n    updateFilters,\r\n    filterOptions: exerciseFilterOptions,\r\n    setIsLoading,\r\n  };\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\hooks\\usePlanSaveHandler.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userPrograms' is assigned a value but never used.","line":48,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":48,"endColumn":23},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'globalSearchParams.source'. Either include it or remove the dependency array.","line":184,"column":6,"nodeType":"ArrayExpression","endLine":184,"endColumn":150,"suggestions":[{"desc":"Update the dependencies array to be: [editingPlanCreatedAt, editingPlanId, globalSearchParams.source, isEditing, isSaving, onSuccess, persistPlan, planName, plans, resetBuilder, selectedExercises, updatePlan]","fix":{"range":[6237,6381],"text":"[editingPlanCreatedAt, editingPlanId, globalSearchParams.source, isEditing, isSaving, onSuccess, persistPlan, planName, plans, resetBuilder, selectedExercises, updatePlan]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * usePlanSaveHandler\r\n * Handles persistence logic for Create Plan screen.\r\n */\r\nimport { useCallback, useMemo, useState } from 'react';\r\nimport { triggerHaptic } from '@/utils/haptics';\r\nimport { useGlobalSearchParams } from 'expo-router';\r\n\r\nimport type { Exercise } from '@/constants/exercises';\r\nimport { usePlansStore } from '@/store/plansStore';\r\nimport { useProgramsStore } from '@/store/programsStore';\r\nimport type { PlanExercise } from '@/types/plan';\r\n\r\nconst DEFAULT_PLAN_SET_COUNT = 3;\r\n\r\nexport type SubmitPlanResult = 'success' | 'missing-name' | 'no-exercises' | 'duplicate-name' | 'error';\r\n\r\ninterface UsePlanSaveHandlerParams {\r\n  editingPlanId: string | null;\r\n  planName: string;\r\n  selectedExercises: Exercise[];\r\n  editingPlanCreatedAt: number | null;\r\n  resetBuilder: () => void;\r\n  onSuccess?: () => void;\r\n}\r\n\r\ninterface PlanSaveHandlerState {\r\n  isSaving: boolean;\r\n  saveLabel: string;\r\n  selectedListTitle: string;\r\n  selectedListSubtitle: string;\r\n  isSaveDisabled: boolean;\r\n  handleSavePlan: () => Promise<SubmitPlanResult>;\r\n}\r\n\r\nexport const usePlanSaveHandler = ({\r\n  editingPlanId,\r\n  planName,\r\n  selectedExercises,\r\n  editingPlanCreatedAt,\r\n  resetBuilder,\r\n  onSuccess,\r\n}: UsePlanSaveHandlerParams): PlanSaveHandlerState => {\r\n  const [isSaving, setIsSaving] = useState<boolean>(false);\r\n  const persistPlan = usePlansStore((state) => state.addPlan);\r\n  const updatePlan = usePlansStore((state) => state.updatePlan);\r\n  const plans = usePlansStore((state) => state.plans);\r\n  const { userPrograms } = useProgramsStore();\r\n  const globalSearchParams = useGlobalSearchParams<{ source?: 'library' | 'recommended' }>();\r\n\r\n  const isEditing = Boolean(editingPlanId);\r\n\r\n  const handleSavePlan = useCallback(async (): Promise<SubmitPlanResult> => {\r\n    const trimmedName = planName.trim();\r\n\r\n    if (!trimmedName) {\r\n      return 'missing-name';\r\n    }\r\n\r\n    if (selectedExercises.length === 0) {\r\n      return 'no-exercises';\r\n    }\r\n\r\n    if (isSaving) {\r\n      return 'error';\r\n    }\r\n\r\n    setIsSaving(true);\r\n\r\n    const isProgramWorkout = editingPlanId?.startsWith('program:');\r\n\r\n    // For program workouts, allow the name change without auto-renaming\r\n    // (the user is editing their own copy)\r\n    let finalName = trimmedName;\r\n\r\n    // NOTE: Auto-renaming is disabled to allow users to use the same workout name \r\n    // across multiple plans, which the UI now groups and tags automatically.\r\n    // if (!isProgramWorkout && (!isEditing || isPremadeReview)) {\r\n    //   finalName = generateUniqueName(trimmedName);\r\n    // } else if (!isProgramWorkout && isEditing) {\r\n    //   const originalPlan = plans.find(p => p.id === editingPlanId);\r\n    //   const originalName = originalPlan?.name.trim().toLowerCase();\r\n    //   if (originalName !== trimmedBase.toLowerCase()) {\r\n    //     finalName = generateUniqueName(trimmedName, editingPlanId ?? undefined);\r\n    //   }\r\n    // }\r\n\r\n\r\n    const normalizedExercises: PlanExercise[] = selectedExercises.map((exercise) => ({\r\n      id: exercise.id,\r\n      name: exercise.name,\r\n      sets: DEFAULT_PLAN_SET_COUNT,\r\n    }));\r\n\r\n    // Get the name of the workout BEFORE it was edited to find matches in other plans\r\n    const originalPlan = plans.find(p => p.id === editingPlanId);\r\n    const originalName = isProgramWorkout ? planName : (originalPlan?.name || finalName);\r\n\r\n    try {\r\n      if (isProgramWorkout && editingPlanId) {\r\n        // Sync across ALL programs that have a workout with this name\r\n        const { updateWorkoutsByName } = useProgramsStore.getState();\r\n        await updateWorkoutsByName(originalName, {\r\n          name: finalName,\r\n          exercises: normalizedExercises,\r\n        });\r\n\r\n        // Also sync to standalone template if it exists with same name\r\n        const standaloneMatch = plans.find(p => p.name.trim().toLowerCase() === originalName.trim().toLowerCase());\r\n        if (standaloneMatch) {\r\n          await updatePlan({\r\n            id: standaloneMatch.id,\r\n            name: finalName,\r\n            exercises: selectedExercises,\r\n            createdAt: standaloneMatch.createdAt,\r\n          });\r\n        }\r\n\r\n        await triggerHaptic('success');\r\n        onSuccess?.();\r\n        return 'success';\r\n      }\r\n\r\n      const createdAtTimestamp = !isEditing ? Date.now() : (editingPlanCreatedAt ?? Date.now());\r\n\r\n      if (isEditing) {\r\n        // Update existing standalone template\r\n        await updatePlan({\r\n          id: editingPlanId!,\r\n          name: finalName,\r\n          exercises: selectedExercises,\r\n          createdAt: createdAtTimestamp,\r\n        });\r\n\r\n        // Also sync to all programs that used this template\r\n        const { updateWorkoutsByName } = useProgramsStore.getState();\r\n        await updateWorkoutsByName(originalName, {\r\n          name: finalName,\r\n          exercises: normalizedExercises,\r\n        });\r\n      } else {\r\n        // Creating a new standalone template\r\n        // Determine source from URL parameters\r\n        let workoutSource: 'premade' | 'custom' | 'library' | 'recommended' = 'custom';\r\n\r\n        const sourceParam = globalSearchParams.source;\r\n        if (sourceParam === 'library' || sourceParam === 'recommended') {\r\n          workoutSource = sourceParam;\r\n        }\r\n\r\n        await persistPlan({\r\n          name: finalName,\r\n          exercises: selectedExercises,\r\n          createdAt: createdAtTimestamp,\r\n          source: workoutSource,\r\n        });\r\n\r\n        // Even for new ones, check if they should sync to existing plans with same name\r\n        const { updateWorkoutsByName } = useProgramsStore.getState();\r\n        await updateWorkoutsByName(finalName, {\r\n          name: finalName,\r\n          exercises: normalizedExercises,\r\n        });\r\n      }\r\n\r\n      await triggerHaptic('success');\r\n\r\n      if (!isEditing) {\r\n        resetBuilder();\r\n      }\r\n\r\n      onSuccess?.();\r\n      return 'success';\r\n    } catch (error: any) {\r\n      // Re-throw limit errors so UI can handle them\r\n      if (error?.message === 'FREE_LIMIT_REACHED') {\r\n        throw error;\r\n      }\r\n      console.error('[usePlanSaveHandler] Failed to save plan', error);\r\n      return 'error';\r\n    } finally {\r\n      setIsSaving(false);\r\n    }\r\n  }, [editingPlanCreatedAt, editingPlanId, isEditing, isSaving, onSuccess, persistPlan, planName, plans, resetBuilder, selectedExercises, updatePlan]);\r\n\r\n\r\n  // Always use \"Save Workout\" for consistency across all modes\r\n  const saveLabel = 'Save Workout';\r\n  const selectedListTitle = 'Exercises';\r\n  const selectedListSubtitle = '';\r\n\r\n  const isSaveDisabled = useMemo(() => {\r\n    const trimmedName = planName.trim();\r\n    return trimmedName.length === 0 || selectedExercises.length === 0 || isSaving;\r\n  }, [planName, selectedExercises.length, isSaving]);\r\n\r\n  return {\r\n    isSaving,\r\n    saveLabel,\r\n    selectedListTitle,\r\n    selectedListSubtitle,\r\n    isSaveDisabled,\r\n    handleSavePlan,\r\n  };\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\hooks\\usePremiumStatus.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\hooks\\useScheduleEditor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\hooks\\useSemanticExerciseSearch.ts","messages":[],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useMemo has a missing dependency: 'excludeIds'. Either include it or remove the dependency array.","line":149,"column":6,"nodeType":"ArrayExpression","endLine":149,"endColumn":43,"suggestions":[{"desc":"Update the dependencies array to be: [query, excludeIds, exercises, limit]","fix":{"range":[5215,5252],"text":"[query, excludeIds, exercises, limit]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\hooks\\useTheme.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\hooks\\useTimer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\hooks\\useTrainingBalanceMetrics.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'workouts' conditional could make the dependencies of useMemo Hook (at line 248) change on every render. Move it inside the useMemo callback. Alternatively, wrap the initialization of 'workouts' in its own useMemo() Hook.","line":92,"column":9,"nodeType":"VariableDeclarator","endLine":92,"endColumn":69}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * useTrainingBalanceMetrics\n * Shared analytics logic for balance ratios so multiple components can reuse it.\n */\n\nimport { useMemo } from 'react';\n\nimport { useWorkoutSessionsStore } from '@/store/workoutSessionsStore';\nimport { useDevToolsStore } from '@/store/devToolsStore';\nimport { useUserProfileStore } from '@/store/userProfileStore';\nimport exercisesData from '@/data/exercises.json';\nimport hierarchyData from '@/data/hierarchy.json';\nimport type { TimeRange } from '@/types/analytics';\nimport type { ExerciseType } from '@/types/exercise';\n\nexport interface BalanceData {\n  push: number;\n  pull: number;\n  quad: number;\n  hip: number;\n  upper: number;\n  lower: number;\n  compound: number;\n  isolated: number;\n}\n\nconst EMPTY_BALANCE: BalanceData = {\n  push: 0,\n  pull: 0,\n  quad: 0,\n  hip: 0,\n  upper: 0,\n  lower: 0,\n  compound: 0,\n  isolated: 0,\n};\n\ninterface ExerciseMetadata {\n  push_pull: 'push' | 'pull' | null;\n  upper_lower: 'upper' | 'lower' | null;\n  is_compound: boolean;\n  exercise_type: ExerciseType;\n}\n\nconst EXERCISE_METADATA = exercisesData.reduce((acc, ex) => {\n  acc[ex.name] = {\n    push_pull: ex.push_pull as 'push' | 'pull' | null,\n    upper_lower: ex.upper_lower as 'upper' | 'lower' | null,\n    is_compound: ex.is_compound ?? false,\n    exercise_type: (ex.exercise_type as ExerciseType) || 'weight',\n  } satisfies ExerciseMetadata;\n  return acc;\n}, {} as Record<string, ExerciseMetadata>);\n\nconst EXERCISE_MUSCLES = exercisesData.reduce((acc, ex) => {\n  if (ex.muscles) {\n    acc[ex.name] = ex.muscles as unknown as Record<string, number>;\n  }\n  return acc;\n}, {} as Record<string, Record<string, number>>);\n\nconst buildLeafToL1 = (): Record<string, string> => {\n  const leafToL1: Record<string, string> = {};\n  const hierarchy = hierarchyData.muscle_hierarchy as Record<string, any>;\n\n  Object.entries(hierarchy).forEach(([l1, l1Data]) => {\n    if (l1Data?.muscles) {\n      Object.entries(l1Data.muscles).forEach(([l2, l2Data]: [string, any]) => {\n        leafToL1[l2] = l1;\n        if (l2Data?.muscles) {\n          Object.entries(l2Data.muscles).forEach(([l3, l3Data]: [string, any]) => {\n            leafToL1[l3] = l1;\n            if (l3Data?.muscles) {\n              Object.keys(l3Data.muscles).forEach((l4) => {\n                leafToL1[l4] = l1;\n              });\n            }\n          });\n        }\n      });\n    }\n  });\n\n  return leafToL1;\n};\n\nconst LEAF_TO_L1 = buildLeafToL1();\n\nexport const useTrainingBalanceMetrics = (timeRange: TimeRange) => {\n  const forceEmptyAnalytics = useDevToolsStore((state) => state.forceEmptyAnalytics);\n  const rawWorkouts = useWorkoutSessionsStore((state) => state.workouts);\n  const workouts = __DEV__ && forceEmptyAnalytics ? [] : rawWorkouts;\n  const userBodyWeight = useUserProfileStore((state) => state.profile?.weightLbs);\n\n  return useMemo(() => {\n    if (!workouts.length) {\n      return {\n        volumeData: { ...EMPTY_BALANCE },\n        setData: { ...EMPTY_BALANCE },\n        hasData: false,\n      };\n    }\n\n    const volumeBalance: BalanceData = { ...EMPTY_BALANCE };\n    const setBalance: BalanceData = { ...EMPTY_BALANCE };\n\n    const now = new Date();\n    let cutoff: Date;\n\n    switch (timeRange) {\n      case 'week':\n        cutoff = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\n        break;\n      case 'month':\n        cutoff = new Date(now.getFullYear(), now.getMonth(), 1);\n        break;\n      case 'year':\n        cutoff = new Date(now.getFullYear(), 0, 1);\n        break;\n      case 'all':\n      default:\n        cutoff = new Date(0);\n        break;\n    }\n\n    workouts\n      .filter((w) => new Date(w.date) >= cutoff)\n      .forEach((workout) => {\n        workout.exercises.forEach((exercise: any) => {\n          const metadata = EXERCISE_METADATA[exercise.name];\n          if (!metadata) return;\n\n          const exerciseType = metadata.exercise_type || 'weight';\n          if (exerciseType === 'cardio' || exerciseType === 'duration') {\n            return;\n          }\n\n          const completedSets = exercise.sets.filter((set: any) => {\n            if (!set.completed) return false;\n            const reps = set.reps ?? 0;\n            const weight = set.weight ?? 0;\n            const assistanceWeight = set.assistanceWeight ?? 0;\n\n            switch (exerciseType) {\n              case 'weight':\n                return reps > 0 && weight > 0;\n              case 'bodyweight':\n              case 'reps_only':\n                return reps > 0;\n              case 'assisted':\n                return reps > 0 && (weight > 0 || assistanceWeight > 0);\n              default:\n                return false;\n            }\n          });\n\n          const setCount = completedSets.length;\n          if (setCount === 0) return;\n\n          let totalVolume = 0;\n          completedSets.forEach((set: any) => {\n            const reps = set.reps ?? 0;\n            if (reps <= 0) {\n              return;\n            }\n\n            let setVolume = 0;\n            switch (exerciseType) {\n              case 'bodyweight':\n                if (userBodyWeight && userBodyWeight > 0) {\n                  setVolume = userBodyWeight * reps;\n                }\n                break;\n              case 'assisted': {\n                if (!userBodyWeight || userBodyWeight <= 0) {\n                  break;\n                }\n                const assistanceWeight = set.assistanceWeight ?? 0;\n                const effectiveWeight = Math.max(0, userBodyWeight - assistanceWeight);\n                if (effectiveWeight > 0) {\n                  setVolume = effectiveWeight * reps;\n                }\n                break;\n              }\n              case 'reps_only':\n                setVolume = 0;\n                break;\n              case 'weight':\n              default: {\n                const weight = set.weight ?? 0;\n                if (weight > 0) {\n                  setVolume = weight * reps;\n                }\n                break;\n              }\n            }\n\n            if (setVolume > 0) {\n              totalVolume += setVolume;\n            }\n          });\n\n          if (metadata.push_pull === 'push') {\n            setBalance.push += setCount;\n            volumeBalance.push += totalVolume;\n          } else if (metadata.push_pull === 'pull') {\n            setBalance.pull += setCount;\n            volumeBalance.pull += totalVolume;\n          }\n\n          if (metadata.upper_lower === 'upper') {\n            setBalance.upper += setCount;\n          } else if (metadata.upper_lower === 'lower') {\n            setBalance.lower += setCount;\n          }\n\n          const muscleWeights = EXERCISE_MUSCLES[exercise.name];\n          if (muscleWeights && totalVolume > 0) {\n            Object.entries(muscleWeights).forEach(([muscle, weight]) => {\n              const muscleVolume = totalVolume * weight;\n              const l1Category = LEAF_TO_L1[muscle];\n              if (l1Category === 'Upper Body' || l1Category === 'Core') {\n                volumeBalance.upper += muscleVolume;\n              } else if (l1Category === 'Lower Body') {\n                volumeBalance.lower += muscleVolume;\n              }\n            });\n          }\n\n          if (metadata.is_compound) {\n            setBalance.compound += setCount;\n            volumeBalance.compound += totalVolume;\n          } else {\n            setBalance.isolated += setCount;\n            volumeBalance.isolated += totalVolume;\n          }\n        });\n      });\n\n    const hasVolumeData = Object.values(volumeBalance).some((v) => v > 0);\n    const hasSetData = Object.values(setBalance).some((v) => v > 0);\n\n    return {\n      volumeData: volumeBalance,\n      setData: setBalance,\n      hasData: hasVolumeData || hasSetData,\n    };\n  }, [workouts, timeRange, userBodyWeight]);\n};\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\hooks\\useWeeklyCardioProgress.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'workouts' conditional could make the dependencies of useMemo Hook (at line 119) change on every render. Move it inside the useMemo callback. Alternatively, wrap the initialization of 'workouts' in its own useMemo() Hook.","line":65,"column":9,"nodeType":"VariableDeclarator","endLine":65,"endColumn":69}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * useWeeklyCardioProgress Hook\r\n * Calculates cardio progress for the current calendar week (Sunday-Saturday)\r\n */\r\n\r\nimport { useMemo } from 'react';\r\nimport { useWorkoutSessionsStore } from '@/store/workoutSessionsStore';\r\nimport { useDevToolsStore } from '@/store/devToolsStore';\r\nimport { exercises as exerciseCatalog } from '@/constants/exercises';\r\nimport type { ExerciseType } from '@/types/exercise';\r\n\r\n// Build exercise type lookup map\r\nconst EXERCISE_TYPE_MAP = exerciseCatalog.reduce((acc, ex) => {\r\n  acc[ex.name] = ex.exerciseType;\r\n  return acc;\r\n}, {} as Record<string, ExerciseType>);\r\n\r\n// Distance unit lookup for cardio exercises\r\nconst EXERCISE_DISTANCE_UNIT_MAP = exerciseCatalog.reduce((acc, ex) => {\r\n  acc[ex.name] = ex.distanceUnit;\r\n  return acc;\r\n}, {} as Record<string, 'miles' | 'meters' | 'floors' | undefined>);\r\n\r\ninterface WeeklyCardioProgress {\r\n  /** Total cardio time in seconds for the current calendar week */\r\n  weeklyTime: number;\r\n  /** Total cardio distance in miles for the current calendar week */\r\n  weeklyDistance: number;\r\n  /** Distance broken down by exercise type */\r\n  weeklyDistanceByType: Record<string, number>;\r\n  /** Start of the current calendar week (Sunday at midnight) */\r\n  weekStart: Date;\r\n  /** End of the current calendar week (Saturday at 23:59:59) */\r\n  weekEnd: Date;\r\n  /** Whether there's any cardio data for this week */\r\n  hasWeeklyData: boolean;\r\n}\r\n\r\n/**\r\n * Get the start of the current calendar week (Sunday at midnight local time)\r\n */\r\nconst getCalendarWeekStart = (): Date => {\r\n  const now = new Date();\r\n  const dayOfWeek = now.getDay(); // 0 = Sunday\r\n  const weekStart = new Date(now);\r\n  weekStart.setDate(now.getDate() - dayOfWeek);\r\n  weekStart.setHours(0, 0, 0, 0);\r\n  return weekStart;\r\n};\r\n\r\n/**\r\n * Get the end of the current calendar week (Saturday at 23:59:59 local time)\r\n */\r\nconst getCalendarWeekEnd = (): Date => {\r\n  const weekStart = getCalendarWeekStart();\r\n  const weekEnd = new Date(weekStart);\r\n  weekEnd.setDate(weekStart.getDate() + 6);\r\n  weekEnd.setHours(23, 59, 59, 999);\r\n  return weekEnd;\r\n};\r\n\r\nexport const useWeeklyCardioProgress = (): WeeklyCardioProgress => {\r\n  const forceEmptyAnalytics = useDevToolsStore((state) => state.forceEmptyAnalytics);\r\n  const rawWorkouts = useWorkoutSessionsStore((state) => state.workouts);\r\n  const workouts = __DEV__ && forceEmptyAnalytics ? [] : rawWorkouts;\r\n\r\n  const progress = useMemo(() => {\r\n    const weekStart = getCalendarWeekStart();\r\n    const weekEnd = getCalendarWeekEnd();\r\n\r\n    let weeklyTime = 0;\r\n    let weeklyDistance = 0;\r\n    const weeklyDistanceByType: Record<string, number> = {};\r\n\r\n    // Filter workouts to current calendar week\r\n    const weeklyWorkouts = workouts.filter((w) => {\r\n      const workoutDate = new Date(w.date);\r\n      return workoutDate >= weekStart && workoutDate <= weekEnd;\r\n    });\r\n\r\n    weeklyWorkouts.forEach((workout) => {\r\n      workout.exercises.forEach((exercise: any) => {\r\n        const exerciseType = EXERCISE_TYPE_MAP[exercise.name];\r\n        if (exerciseType !== 'cardio') return;\r\n\r\n        exercise.sets.forEach((set: any) => {\r\n          if (!set.completed) return;\r\n\r\n          // Accumulate time\r\n          if (set.duration && set.duration > 0) {\r\n            weeklyTime += set.duration;\r\n          }\r\n\r\n          // Accumulate distance\r\n          if (set.distance && set.distance > 0) {\r\n            const distanceUnit = EXERCISE_DISTANCE_UNIT_MAP[exercise.name];\r\n\r\n            // Only count real distance units towards weeklyDistance (mi/km goals).\r\n            // Floor-based activities are tracked in the per-activity breakdown only.\r\n            if (distanceUnit !== 'floors') {\r\n              weeklyDistance += set.distance;\r\n            }\r\n\r\n            weeklyDistanceByType[exercise.name] =\r\n              (weeklyDistanceByType[exercise.name] || 0) + set.distance;\r\n          }\r\n        });\r\n      });\r\n    });\r\n\r\n    return {\r\n      weeklyTime,\r\n      weeklyDistance,\r\n      weeklyDistanceByType,\r\n      weekStart,\r\n      weekEnd,\r\n      hasWeeklyData: weeklyTime > 0 || weeklyDistance > 0,\r\n    };\r\n  }, [workouts]);\r\n\r\n  return progress;\r\n};\r\n\r\nexport type { WeeklyCardioProgress };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\hooks\\useWorkoutDetailAnimation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\hooks\\useWorkoutEditor.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'convertWeight' and 'exerciseDrafts.length'. Either include them or remove the dependency array.","line":121,"column":6,"nodeType":"ArrayExpression","endLine":121,"endColumn":27,"suggestions":[{"desc":"Update the dependencies array to be: [workout, weightUnit, exerciseDrafts.length, convertWeight]","fix":{"range":[4342,4363],"text":"[workout, weightUnit, exerciseDrafts.length, convertWeight]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has an unnecessary dependency: 'weightUnit'. Either exclude it or remove the dependency array.","line":227,"column":6,"nodeType":"ArrayExpression","endLine":227,"endColumn":52,"suggestions":[{"desc":"Update the dependencies array to be: [workouts, workout, convertWeight]","fix":{"range":[7569,7615],"text":"[workouts, workout, convertWeight]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'convertWeightToLbs'. Either include it or remove the dependency array.","line":310,"column":6,"nodeType":"ArrayExpression","endLine":310,"endColumn":46,"suggestions":[{"desc":"Update the dependencies array to be: [convertWeightToLbs, exerciseDrafts, updateWorkout, workout]","fix":{"range":[10105,10145],"text":"[convertWeightToLbs, exerciseDrafts, updateWorkout, workout]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * useWorkoutEditor\n * Manages workout editing state: exercises, selection, and persistence.\n */\n\nimport { useCallback, useEffect, useMemo, useState } from 'react';\n\nimport {\n  exercises as baseExerciseCatalog,\n  type Exercise,\n  type ExerciseCatalogItem,\n  createCustomExerciseCatalogItem\n} from '@/constants/exercises';\nimport type { SetLog, Workout, WorkoutExercise } from '@/types/workout';\nimport { usePlansStore } from '@/store/plansStore';\n\nimport { useWorkoutSessionsStore } from '@/store/workoutSessionsStore';\nimport { useSettingsStore } from '@/store/settingsStore';\nimport { useCustomExerciseStore } from '@/store/customExerciseStore';\nimport { getLastCompletedSetsForExercise } from '@/utils/exerciseHistory';\n\ninterface WorkoutEditorHook {\n  workout: Workout | null;\n  planName: string | null;\n  exerciseDrafts: WorkoutExercise[];\n  expandedExercise: string | null;\n  toggleExercise: (name: string) => void;\n  updateExerciseSets: (name: string, sets: SetLog[]) => void;\n  removeExercise: (name: string) => void;\n  moveExercise: (name: string, direction: 'up' | 'down') => void;\n  addExercise: (exercise: Exercise) => void;\n  isPickerVisible: boolean;\n  openPicker: () => void;\n  closePicker: () => void;\n  filteredExercises: Exercise[];\n  searchTerm: string;\n  setSearchTerm: (value: string) => void;\n  exerciseCount: number;\n  saveWorkout: () => Promise<boolean>;\n  isLoading: boolean;\n  setIsLoading: (loading: boolean) => void;\n}\n\nconst DEFAULT_SET_COUNT = 3;\n\nconst createDefaultSetLogs = (exerciseName: string, workouts: Workout[], currentWorkoutId?: string): SetLog[] => {\n  // Filter out the current workout to avoid using incomplete data\n  const historicalWorkouts = currentWorkoutId\n    ? workouts.filter((w) => w.id !== currentWorkoutId)\n    : workouts;\n\n  // Try to get history for this exercise from other workouts\n  const lastSets = getLastCompletedSetsForExercise(exerciseName, historicalWorkouts);\n\n  if (lastSets && lastSets.length > 0) {\n    // Use the historical sets, but mark them as not completed\n    return lastSets.map((set) => ({\n      reps: set.reps,\n      weight: set.weight,\n      completed: false,\n    }));\n  }\n\n  // No history, use defaults\n  return Array.from({ length: DEFAULT_SET_COUNT }, () => ({ reps: 8, weight: 0, completed: false }));\n};\n\nexport const useWorkoutEditor = (workoutId?: string): WorkoutEditorHook => {\n  const workouts = useWorkoutSessionsStore((state) => state.workouts);\n  const hydrateWorkouts = useWorkoutSessionsStore((state) => state.hydrateWorkouts);\n  const updateWorkout = useWorkoutSessionsStore((state) => state.updateWorkout);\n  const plans = usePlansStore((state) => state.plans);\n  const customExercises = useCustomExerciseStore((state) => state.customExercises);\n\n  const hydratePlans = usePlansStore((state) => state.hydratePlans);\n  const { convertWeight, convertWeightToLbs, weightUnit } = useSettingsStore();\n\n  const [exerciseDrafts, setExerciseDrafts] = useState<WorkoutExercise[]>([]);\n  const [expandedExercise, setExpandedExercise] = useState<string | null>(null);\n  const [isPickerVisible, setPickerVisible] = useState<boolean>(false);\n  const [searchTerm, setSearchTerm] = useState<string>('');\n  const [isLoading, setIsLoading] = useState<boolean>(!!workoutId);\n\n  useEffect(() => {\n    void hydrateWorkouts();\n    void hydratePlans();\n  }, [hydratePlans, hydrateWorkouts]);\n\n  const workout = useMemo<Workout | null>(() => {\n    return workouts.find((item) => item.id === workoutId) ?? null;\n  }, [workouts, workoutId]);\n\n  // Merge base catalog with custom exercises\n  const allExercises = useMemo<ExerciseCatalogItem[]>(() => {\n    const customCatalogItems = customExercises.map((ce) =>\n      createCustomExerciseCatalogItem(ce.id, ce.name, ce.exerciseType)\n    );\n    return [...baseExerciseCatalog, ...customCatalogItems];\n  }, [customExercises]);\n\n  useEffect(() => {\n    if (!workout) {\n      setExerciseDrafts([]);\n      setExpandedExercise(null);\n      return;\n    }\n\n    const nextDrafts = workout.exercises.map((exercise) => ({\n      ...exercise,\n      sets: exercise.sets.map((set) => ({\n        ...set,\n        weight: convertWeight(set.weight ?? 0),\n      })),\n    }));\n\n    setExerciseDrafts(nextDrafts);\n    if (!exerciseDrafts.length) {\n      setExpandedExercise(nextDrafts[0]?.name ?? null);\n    }\n    setIsLoading(false);\n  }, [workout, weightUnit]);\n\n  useEffect(() => {\n    if (exerciseDrafts.length === 0) {\n      setExpandedExercise(null);\n      return;\n    }\n\n    setExpandedExercise((prev) => {\n      if (!prev || exerciseDrafts.some((exercise) => exercise.name === prev)) {\n        return prev ?? exerciseDrafts[0].name;\n      }\n\n      return exerciseDrafts[0].name;\n    });\n  }, [exerciseDrafts]);\n\n  const planName = useMemo(() => {\n    if (!workout?.planId) {\n      return null;\n    }\n\n    return plans.find((plan) => plan.id === workout.planId)?.name ?? null;\n  }, [plans, workout?.planId]);\n\n  const toggleExercise = useCallback((name: string) => {\n    setExpandedExercise((prev) => (prev === name ? null : name));\n  }, []);\n\n  const updateExerciseSets = useCallback((name: string, sets: SetLog[]) => {\n    setExerciseDrafts((prev) => prev.map((exercise) => (exercise.name === name ? { ...exercise, sets } : exercise)));\n  }, []);\n\n  const removeExercise = useCallback((name: string) => {\n    setExerciseDrafts((prev) => prev.filter((exercise) => exercise.name !== name));\n  }, []);\n\n  const moveExercise = useCallback((name: string, direction: 'up' | 'down') => {\n    setExerciseDrafts((prev) => {\n      const index = prev.findIndex((exercise) => exercise.name === name);\n\n      if (index === -1) {\n        return prev;\n      }\n\n      const targetIndex = direction === 'up' ? index - 1 : index + 1;\n\n      if (targetIndex < 0 || targetIndex >= prev.length) {\n        return prev;\n      }\n\n      const next = [...prev];\n      const temp = next[targetIndex];\n      next[targetIndex] = next[index];\n      next[index] = temp;\n      return next;\n    });\n  }, []);\n\n  const addExercise = useCallback((exercise: Exercise) => {\n    let resolvedName = exercise.name;\n    setExerciseDrafts((prev) => {\n      const existingNames = new Set(prev.map((item) => item.name));\n      let baseName = exercise.name;\n\n      if (existingNames.has(baseName)) {\n        let suffix = 2;\n        while (existingNames.has(`${baseName} (${suffix})`)) {\n          suffix += 1;\n        }\n        baseName = `${baseName} (${suffix})`;\n      }\n\n      // First, check if this exercise exists in the current workout with completed sets\n      const currentExercise = prev.find((ex) => ex.name === baseName);\n      let defaultSets: SetLog[];\n\n      if (currentExercise && currentExercise.sets.some((set) => set.completed)) {\n        // Use the current workout's data\n        defaultSets = currentExercise.sets.map((set) => ({\n          reps: set.reps,\n          weight: set.weight,\n          completed: false,\n        }));\n      } else {\n        // Fall back to historical workouts (excluding current workout)\n        defaultSets = createDefaultSetLogs(baseName, workouts, workout?.id);\n      }\n\n      // Convert default/historical sets from LBS (storage) to User Unit (display)\n      const convertedSets = defaultSets.map((set) => ({\n        ...set,\n        weight: convertWeight(set.weight ?? 0),\n      }));\n\n      const next: WorkoutExercise = {\n        name: baseName,\n        sets: convertedSets,\n      };\n\n      resolvedName = baseName;\n      return [...prev, next];\n    });\n    setPickerVisible(false);\n    setSearchTerm('');\n    setExpandedExercise(resolvedName);\n  }, [workouts, workout, convertWeight, weightUnit]);\n\n  const openPicker = useCallback(() => {\n    setPickerVisible(true);\n    setSearchTerm('');\n  }, []);\n\n  const closePicker = useCallback(() => {\n    setPickerVisible(false);\n    setSearchTerm('');\n  }, []);\n\n  const filteredExercises = useMemo(() => {\n    const query = searchTerm.trim().toLowerCase();\n\n    if (!query) {\n      return allExercises.sort((a, b) => a.name.localeCompare(b.name));\n    }\n\n    // For short queries (1-2 chars), require word-start match\n    const isShortQuery = query.length <= 2;\n\n    const filtered = allExercises.filter((exercise) => {\n      const name = exercise.name.toLowerCase();\n      const muscleGroup = exercise.muscleGroup.toLowerCase();\n\n      if (isShortQuery) {\n        // Require word-start match for short queries\n        return name.startsWith(query) || name.includes(` ${query}`) ||\n               muscleGroup.startsWith(query) || muscleGroup.includes(` ${query}`);\n      }\n\n      // For longer queries, standard includes is fine\n      return name.includes(query) || muscleGroup.includes(query);\n    });\n\n    // Sort by relevance: exact/prefix matches first, then alphabetically\n    return filtered.sort((a, b) => {\n      const aName = a.name.toLowerCase();\n      const bName = b.name.toLowerCase();\n\n      const aExact = aName === query;\n      const bExact = bName === query;\n      if (aExact !== bExact) return aExact ? -1 : 1;\n\n      const aStarts = aName.startsWith(query);\n      const bStarts = bName.startsWith(query);\n      if (aStarts !== bStarts) return aStarts ? -1 : 1;\n\n      const aWordStarts = aName.includes(` ${query}`);\n      const bWordStarts = bName.includes(` ${query}`);\n      if (aWordStarts !== bWordStarts) return aWordStarts ? -1 : 1;\n\n      return aName.localeCompare(bName);\n    });\n  }, [searchTerm, allExercises]);\n\n  const exerciseCount = exerciseDrafts.length;\n\n  const saveWorkout = useCallback(async () => {\n    if (!workout) {\n      return false;\n    }\n\n    try {\n      // Convert exercises from User Unit (display) to LBS (storage)\n      const preparedExercises = exerciseDrafts.map((exercise) => ({\n        ...exercise,\n        sets: exercise.sets.map((set) => ({\n          ...set,\n          weight: convertWeightToLbs(set.weight ?? 0),\n        })),\n      }));\n\n      await updateWorkout({\n        ...workout,\n        exercises: preparedExercises,\n      });\n      return true;\n    } catch (error) {\n      console.error('[useWorkoutEditor] Failed to update workout', error);\n      return false;\n    }\n  }, [exerciseDrafts, updateWorkout, workout]);\n\n  return {\n    workout,\n    planName,\n    exerciseDrafts,\n    expandedExercise,\n    toggleExercise,\n    updateExerciseSets,\n    removeExercise,\n    moveExercise,\n    addExercise,\n    isPickerVisible,\n    openPicker,\n    closePicker,\n    filteredExercises,\n    searchTerm,\n    setSearchTerm,\n    exerciseCount,\n    saveWorkout,\n    isLoading,\n    setIsLoading,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\lib\\supabaseClient.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\lib\\supabaseQueries.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'count' is assigned a value but never used.","line":715,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":715,"endColumn":35}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Supabase Database Queries\r\n * Centralized functions for interacting with Supabase tables\r\n */\r\n\r\nimport { supabaseClient } from './supabaseClient';\r\nimport type { Workout } from '@/types/workout';\r\nimport type { UserPlan, PlanWorkout } from '@/types/premadePlan';\r\nimport { migrateWorkoutExercises, migrateExerciseName } from '@/utils/exerciseMigration';\r\n\r\n// ============================================================================\r\n// RETRY UTILITY & ERROR HANDLING\r\n// ============================================================================\r\n\r\ninterface RetryOptions {\r\n    maxAttempts?: number;\r\n    initialDelayMs?: number;\r\n    maxDelayMs?: number;\r\n    backoffMultiplier?: number;\r\n}\r\n\r\nconst DEFAULT_RETRY_OPTIONS: Required<RetryOptions> = {\r\n    maxAttempts: 3,\r\n    initialDelayMs: 1000,\r\n    maxDelayMs: 10000,\r\n    backoffMultiplier: 2,\r\n};\r\n\r\n/**\r\n * Checks if an error is a network-related error that should be retried\r\n */\r\nfunction isNetworkError(error: unknown): boolean {\r\n    if (!(error instanceof Error)) return false;\r\n\r\n    const networkErrorPatterns = [\r\n        'network request failed',\r\n        'network error',\r\n        'failed to fetch',\r\n        'fetch failed',\r\n        'timeout',\r\n        'econnrefused',\r\n        'econnreset',\r\n        'enotfound',\r\n        'socket hang up',\r\n        'aborted',\r\n        'network is offline',\r\n        'internet connection',\r\n    ];\r\n\r\n    const message = error.message.toLowerCase();\r\n    return networkErrorPatterns.some(pattern => message.includes(pattern));\r\n}\r\n\r\n/**\r\n * Checks if an error is an auth error that should NOT be retried\r\n */\r\nfunction isAuthError(error: unknown): boolean {\r\n    if (!(error instanceof Error)) return false;\r\n\r\n    const authErrorPatterns = ['jwt', 'auth', 'unauthorized', '401', 'token'];\r\n    const message = error.message.toLowerCase();\r\n    return authErrorPatterns.some(pattern => message.includes(pattern));\r\n}\r\n\r\n/**\r\n * Retries an async function with exponential backoff\r\n * Automatically retries on network errors, skips retry on auth errors\r\n * @param fn The async function to retry\r\n * @param options Retry configuration options\r\n * @returns The result of the function\r\n */\r\nasync function withRetry<T>(\r\n    fn: () => Promise<T>,\r\n    options: RetryOptions = {}\r\n): Promise<T> {\r\n    const opts = { ...DEFAULT_RETRY_OPTIONS, ...options };\r\n    let lastError: unknown;\r\n    let delay = opts.initialDelayMs;\r\n\r\n    for (let attempt = 1; attempt <= opts.maxAttempts; attempt++) {\r\n        try {\r\n            return await fn();\r\n        } catch (error) {\r\n            lastError = error;\r\n\r\n            // Don't retry on auth errors\r\n            if (isAuthError(error)) {\r\n                console.warn('[Supabase] Auth error detected, not retrying:', error);\r\n                throw error;\r\n            }\r\n\r\n            // Last attempt - throw the error\r\n            if (attempt === opts.maxAttempts) {\r\n                console.error(`[Supabase] All ${opts.maxAttempts} attempts failed:`, error);\r\n                throw error;\r\n            }\r\n\r\n            // Log retry attempt with more context\r\n            const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n            const isNetwork = isNetworkError(error);\r\n            console.log(\r\n                `[Supabase] Attempt ${attempt}/${opts.maxAttempts} failed (${isNetwork ? 'network' : 'other'} error: ${errorMessage}), retrying in ${delay}ms...`\r\n            );\r\n\r\n            // Wait before retrying\r\n            await new Promise(resolve => setTimeout(resolve, delay));\r\n\r\n            // Increase delay for next attempt\r\n            delay = Math.min(delay * opts.backoffMultiplier, opts.maxDelayMs);\r\n        }\r\n    }\r\n\r\n    throw lastError;\r\n}\r\n\r\n/**\r\n * Wraps a Supabase operation with retry logic and graceful error handling\r\n * Returns null/empty array on failure instead of throwing (for non-critical operations)\r\n * Silently handles network errors to prevent user-facing error messages\r\n */\r\nasync function withGracefulRetry<T>(\r\n    fn: () => Promise<T>,\r\n    fallback: T,\r\n    operationName: string,\r\n    options: RetryOptions = {}\r\n): Promise<T> {\r\n    try {\r\n        return await withRetry(fn, options);\r\n    } catch (error) {\r\n        // Use console.warn for network errors to avoid alarming error messages\r\n        // These are expected during app startup or poor connectivity\r\n        if (isNetworkError(error)) {\r\n            console.warn(`[Supabase] ${operationName} failed (network issue), using fallback`);\r\n        } else {\r\n            console.warn(`[Supabase] ${operationName} failed after retries, using fallback`);\r\n        }\r\n        return fallback;\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// WORKOUT SESSIONS\r\n// ============================================================================\r\n\r\nexport async function fetchWorkoutSessions(userId: string): Promise<Workout[]> {\r\n    console.log('[Supabase] Fetching workout sessions for user:', userId);\r\n\r\n    return withGracefulRetry(\r\n        async () => {\r\n            const { data, error } = await supabaseClient\r\n                .from('workout_sessions')\r\n                .select('*')\r\n                .eq('user_id', userId)\r\n                .order('date', { ascending: false });\r\n\r\n            if (error) {\r\n                throw error;\r\n            }\r\n\r\n            console.log('[Supabase] Successfully fetched', data?.length ?? 0, 'workout sessions');\r\n\r\n            // Transform from DB format to app format and migrate exercise names\r\n            return (data || []).map((row) => ({\r\n                id: row.id,\r\n                planId: row.plan_id,\r\n                name: row.name,\r\n                date: row.date,\r\n                startTime: row.start_time,\r\n                endTime: row.end_time,\r\n                duration: row.duration,\r\n                exercises: migrateWorkoutExercises(row.exercises || []),\r\n            }));\r\n        },\r\n        [], // fallback to empty array\r\n        'fetchWorkoutSessions'\r\n    );\r\n}\r\n\r\nexport async function createWorkoutSession(userId: string, workout: Workout): Promise<string> {\r\n    return withRetry(async () => {\r\n        // Validate planId exists in the plans table before inserting\r\n        // planId could be a workout_templates.id which would violate the foreign key constraint\r\n        let validPlanId: string | null = null;\r\n\r\n        if (workout.planId) {\r\n            const { data: planExists } = await supabaseClient\r\n                .from('plans')\r\n                .select('id')\r\n                .eq('id', workout.planId)\r\n                .single();\r\n\r\n            if (planExists) {\r\n                validPlanId = workout.planId;\r\n            }\r\n        }\r\n\r\n        const { data, error } = await supabaseClient\r\n            .from('workout_sessions')\r\n            .insert({\r\n                user_id: userId,\r\n                plan_id: validPlanId,\r\n                name: workout.name,\r\n                date: workout.date,\r\n                start_time: workout.startTime,\r\n                end_time: workout.endTime,\r\n                duration: workout.duration,\r\n                exercises: workout.exercises,\r\n            })\r\n            .select('id')\r\n            .single();\r\n\r\n        if (error) {\r\n            console.error('[Supabase] Error creating workout session:', error);\r\n            throw error;\r\n        }\r\n\r\n        return data.id;\r\n    });\r\n}\r\n\r\nexport async function updateWorkoutSession(userId: string, workout: Workout): Promise<void> {\r\n    return withRetry(async () => {\r\n        // Validate planId exists in the plans table before updating\r\n        let validPlanId: string | null = null;\r\n\r\n        if (workout.planId) {\r\n            const { data: planExists } = await supabaseClient\r\n                .from('plans')\r\n                .select('id')\r\n                .eq('id', workout.planId)\r\n                .single();\r\n\r\n            if (planExists) {\r\n                validPlanId = workout.planId;\r\n            }\r\n        }\r\n\r\n        const { error } = await supabaseClient\r\n            .from('workout_sessions')\r\n            .update({\r\n                plan_id: validPlanId,\r\n                name: workout.name,\r\n                date: workout.date,\r\n                start_time: workout.startTime,\r\n                end_time: workout.endTime,\r\n                duration: workout.duration,\r\n                exercises: workout.exercises,\r\n            })\r\n            .eq('id', workout.id)\r\n            .eq('user_id', userId);\r\n\r\n        if (error) {\r\n            console.error('[Supabase] Error updating workout session:', error);\r\n            throw error;\r\n        }\r\n    });\r\n}\r\n\r\nexport async function deleteWorkoutSession(userId: string, workoutId: string): Promise<void> {\r\n    return withRetry(async () => {\r\n        const { error } = await supabaseClient\r\n            .from('workout_sessions')\r\n            .delete()\r\n            .eq('id', workoutId)\r\n            .eq('user_id', userId);\r\n\r\n        if (error) {\r\n            console.error('[Supabase] Error deleting workout session:', error);\r\n            throw error;\r\n        }\r\n    });\r\n}\r\n\r\n// ============================================================================\r\n// PLANS (User Programs)\r\n// ============================================================================\r\n\r\nexport async function fetchUserPlans(userId: string): Promise<UserPlan[]> {\r\n    console.log('[Supabase] Fetching user plans for user:', userId);\r\n\r\n    return withGracefulRetry(\r\n        async () => {\r\n            const { data: plansData, error: plansError } = await supabaseClient\r\n                .from('plans')\r\n                .select('*')\r\n                .eq('user_id', userId)\r\n                .order('created_at', { ascending: false });\r\n\r\n            if (plansError) {\r\n                throw plansError;\r\n            }\r\n\r\n            if (!plansData || plansData.length === 0) {\r\n                console.log('[Supabase] No plans found for user');\r\n                return [];\r\n            }\r\n\r\n            console.log('[Supabase] Found', plansData.length, 'plans, fetching workouts...');\r\n\r\n            // Fetch workouts for all plans\r\n            const planIds = plansData.map((p) => p.id);\r\n            const { data: workoutsData, error: workoutsError } = await supabaseClient\r\n                .from('plan_workouts')\r\n                .select('*')\r\n                .in('plan_id', planIds)\r\n                .order('order_index', { ascending: true });\r\n\r\n            if (workoutsError) {\r\n                throw workoutsError;\r\n            }\r\n\r\n            console.log('[Supabase] Successfully fetched', workoutsData?.length ?? 0, 'plan workouts');\r\n\r\n            // Group workouts by plan_id and migrate exercise names\r\n            const workoutsByPlan = (workoutsData || []).reduce((acc, workout) => {\r\n                if (!acc[workout.plan_id]) {\r\n                    acc[workout.plan_id] = [];\r\n                }\r\n                const exercises = workout.exercises || [];\r\n                // Migrate exercise names in the exercises array\r\n                const migratedExercises = exercises.map((ex: any) => ({\r\n                    ...ex,\r\n                    name: migrateExerciseName(ex.name),\r\n                }));\r\n                acc[workout.plan_id].push({\r\n                    id: workout.id,\r\n                    name: workout.name,\r\n                    exercises: migratedExercises,\r\n                    sourceWorkoutId: workout.source_workout_id,\r\n                });\r\n                return acc;\r\n            }, {} as Record<string, PlanWorkout[]>);\r\n\r\n            // Combine plans with their workouts\r\n            return plansData.map((plan) => ({\r\n                id: plan.id,\r\n                name: plan.name,\r\n                workouts: workoutsByPlan[plan.id] || [],\r\n                metadata: plan.metadata || {},\r\n                scheduleType: plan.schedule_type,\r\n                schedule: plan.schedule_config,\r\n                isPremade: false,\r\n                sourceId: plan.source_id,\r\n                createdAt: plan.created_at,\r\n                modifiedAt: plan.updated_at,\r\n                is_active: plan.is_active || false,\r\n                rotation_state: plan.rotation_state || null,\r\n            }));\r\n        },\r\n        [], // fallback to empty array\r\n        'fetchUserPlans'\r\n    );\r\n}\r\n\r\nexport async function createUserPlan(userId: string, plan: UserPlan): Promise<{ id: string; workouts: PlanWorkout[] }> {\r\n    return withRetry(async () => {\r\n        // Insert the plan (let Supabase generate UUID)\r\n        const { data: planData, error: planError } = await supabaseClient\r\n            .from('plans')\r\n            .insert({\r\n                user_id: userId,\r\n                name: plan.name,\r\n                metadata: plan.metadata,\r\n                schedule_type: plan.scheduleType,\r\n                schedule_config: plan.schedule,\r\n                is_active: false,\r\n                source_id: plan.sourceId,\r\n            })\r\n            .select('id')\r\n            .single();\r\n\r\n        if (planError) {\r\n            console.error('[Supabase] Error creating plan:', planError);\r\n            throw planError;\r\n        }\r\n\r\n        const newPlanId = planData.id;\r\n        let finalWorkouts: PlanWorkout[] = [];\r\n\r\n        // Insert workouts (let Supabase generate UUIDs)\r\n        if (plan.workouts && plan.workouts.length > 0) {\r\n            const workoutsToInsert = plan.workouts.map((workout, index) => ({\r\n                plan_id: newPlanId,\r\n                user_id: userId,\r\n                name: workout.name,\r\n                exercises: workout.exercises,\r\n                order_index: index,\r\n                source_workout_id: workout.sourceWorkoutId,\r\n            }));\r\n\r\n            const { data: insertedWorkouts, error: workoutsError } = await supabaseClient\r\n                .from('plan_workouts')\r\n                .insert(workoutsToInsert)\r\n                .select('*');\r\n\r\n            if (workoutsError) {\r\n                console.error('[Supabase] Error creating plan workouts:', workoutsError);\r\n                throw workoutsError;\r\n            }\r\n\r\n            if (insertedWorkouts) {\r\n                // Map temporary IDs to new UUIDs\r\n                const idMap = new Map<string, string>();\r\n\r\n                // Sort by order_index to match original array order\r\n                const sortedInserted = [...insertedWorkouts].sort((a, b) => a.order_index - b.order_index);\r\n\r\n                sortedInserted.forEach((row, index) => {\r\n                    const originalWorkout = plan.workouts[index];\r\n                    if (originalWorkout) {\r\n                        idMap.set(originalWorkout.id, row.id);\r\n                        finalWorkouts.push({\r\n                            id: row.id,\r\n                            name: row.name,\r\n                            exercises: row.exercises || [],\r\n                            sourceWorkoutId: row.source_workout_id,\r\n                        });\r\n                    }\r\n                });\r\n\r\n                // Crucial: Update the schedule_config in the DB if it contains original IDs\r\n                if (plan.schedule) {\r\n                    let updatedSchedule = JSON.parse(JSON.stringify(plan.schedule));\r\n                    let needsUpdate = false;\r\n\r\n                    if (updatedSchedule.rotation?.workoutOrder) {\r\n                        updatedSchedule.rotation.workoutOrder = updatedSchedule.rotation.workoutOrder.map(\r\n                            (id: string) => {\r\n                                const newId = idMap.get(id);\r\n                                if (newId) needsUpdate = true;\r\n                                return newId || id;\r\n                            }\r\n                        );\r\n                    }\r\n\r\n                    if (updatedSchedule.weekly) {\r\n                        Object.keys(updatedSchedule.weekly).forEach(day => {\r\n                            const oldId = updatedSchedule.weekly[day];\r\n                            if (oldId && idMap.has(oldId)) {\r\n                                updatedSchedule.weekly[day] = idMap.get(oldId);\r\n                                needsUpdate = true;\r\n                            }\r\n                        });\r\n                    }\r\n\r\n                    if (needsUpdate) {\r\n                        await supabaseClient\r\n                            .from('plans')\r\n                            .update({ schedule_config: updatedSchedule })\r\n                            .eq('id', newPlanId);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return { id: newPlanId, workouts: finalWorkouts };\r\n    });\r\n}\r\n\r\nexport async function updateUserPlan(userId: string, plan: UserPlan): Promise<void> {\r\n    return withRetry(async () => {\r\n        const { error } = await supabaseClient\r\n            .from('plans')\r\n            .update({\r\n                name: plan.name,\r\n                metadata: plan.metadata,\r\n                schedule_type: plan.scheduleType,\r\n                schedule_config: plan.schedule,\r\n                source_id: plan.sourceId,\r\n                updated_at: new Date().toISOString(),\r\n            })\r\n            .eq('id', plan.id)\r\n            .eq('user_id', userId);\r\n\r\n        if (error) {\r\n            console.error('[Supabase] Error updating plan:', error);\r\n            throw error;\r\n        }\r\n    });\r\n}\r\n\r\nexport async function deleteUserPlan(userId: string, planId: string): Promise<void> {\r\n    return withRetry(async () => {\r\n        // Workouts will be deleted automatically due to CASCADE\r\n        const { error } = await supabaseClient\r\n            .from('plans')\r\n            .delete()\r\n            .eq('id', planId)\r\n            .eq('user_id', userId);\r\n\r\n        if (error) {\r\n            console.error('[Supabase] Error deleting plan:', error);\r\n            throw error;\r\n        }\r\n    });\r\n}\r\n\r\nexport async function setActivePlan(userId: string, planId: string | null): Promise<void> {\r\n    return withRetry(async () => {\r\n        // First, set all plans to inactive\r\n        const { error: deactivateError } = await supabaseClient\r\n            .from('plans')\r\n            .update({ is_active: false })\r\n            .eq('user_id', userId);\r\n\r\n        if (deactivateError) {\r\n            console.error('[Supabase] Error deactivating plans:', deactivateError);\r\n            throw deactivateError;\r\n        }\r\n\r\n        // Then set the selected plan to active\r\n        if (planId) {\r\n            const { error } = await supabaseClient\r\n                .from('plans')\r\n                .update({ is_active: true })\r\n                .eq('id', planId)\r\n                .eq('user_id', userId);\r\n\r\n            if (error) {\r\n                console.error('[Supabase] Error setting active plan:', error);\r\n                throw error;\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n// ============================================================================\r\n// ROTATION STATE (stored in plans table)\r\n// ============================================================================\r\n\r\nexport interface RotationStateDB {\r\n    workoutSequence: string[];\r\n    currentIndex: number;\r\n    lastAdvancedAt: number;\r\n}\r\n\r\nexport async function updateRotationState(\r\n    userId: string,\r\n    planId: string,\r\n    rotationState: RotationStateDB | null\r\n): Promise<void> {\r\n    return withRetry(async () => {\r\n        const { error } = await supabaseClient\r\n            .from('plans')\r\n            .update({ rotation_state: rotationState })\r\n            .eq('id', planId)\r\n            .eq('user_id', userId);\r\n\r\n        if (error) {\r\n            console.error('[Supabase] Error updating rotation state:', error);\r\n            throw error;\r\n        }\r\n    });\r\n}\r\n\r\n// ============================================================================\r\n// WORKOUT TEMPLATES (standalone workout templates like \"Push Day\")\r\n// ============================================================================\r\n\r\nexport interface WorkoutTemplateDB {\r\n    id: string;\r\n    name: string;\r\n    exercises: { id: string; name: string; sets?: number }[];\r\n    source?: 'premade' | 'custom' | 'library' | 'recommended';\r\n    created_at: string;\r\n    updated_at: string;\r\n}\r\n\r\nexport async function fetchWorkoutTemplates(userId: string): Promise<WorkoutTemplateDB[]> {\r\n    console.log('[Supabase] Fetching workout templates for user:', userId);\r\n\r\n    return withGracefulRetry(\r\n        async () => {\r\n            const { data, error } = await supabaseClient\r\n                .from('workout_templates')\r\n                .select('*')\r\n                .eq('user_id', userId)\r\n                .order('created_at', { ascending: false });\r\n\r\n            if (error) {\r\n                throw error;\r\n            }\r\n\r\n            console.log('[Supabase] Successfully fetched', data?.length ?? 0, 'workout templates');\r\n\r\n            return (data || []).map((row) => {\r\n                // Validate and sanitize the data\r\n                const exercises = Array.isArray(row.exercises) ? row.exercises : [];\r\n                const sanitizedExercises = exercises.filter((ex: any) => {\r\n                    // Filter out invalid exercise objects\r\n                    if (!ex || typeof ex !== 'object') return false;\r\n                    if (typeof ex.id !== 'string') return false;\r\n                    return true;\r\n                }).map((ex: any) => ({\r\n                    id: String(ex.id),\r\n                    name: String(ex.name || ''),\r\n                    sets: typeof ex.sets === 'number' ? ex.sets : 3,\r\n                }));\r\n\r\n                return {\r\n                    id: String(row.id),\r\n                    name: String(row.name || 'Untitled'),\r\n                    exercises: sanitizedExercises,\r\n                    source: row.source,\r\n                    created_at: row.created_at,\r\n                    updated_at: row.updated_at,\r\n                };\r\n            });\r\n        },\r\n        [], // fallback to empty array\r\n        'fetchWorkoutTemplates'\r\n    );\r\n}\r\n\r\nexport async function createWorkoutTemplate(\r\n    userId: string,\r\n    template: { name: string; exercises: { id: string; name: string; sets?: number }[]; source?: 'premade' | 'custom' | 'library' | 'recommended' }\r\n): Promise<string> {\r\n    return withRetry(async () => {\r\n        const { data, error } = await supabaseClient\r\n            .from('workout_templates')\r\n            .insert({\r\n                user_id: userId,\r\n                name: template.name,\r\n                exercises: template.exercises,\r\n                source: template.source || 'custom',\r\n            })\r\n            .select('id')\r\n            .single();\r\n\r\n        if (error) {\r\n            console.error('[Supabase] Error creating workout template:', error);\r\n            throw error;\r\n        }\r\n\r\n        return data.id;\r\n    });\r\n}\r\n\r\nexport async function updateWorkoutTemplate(\r\n    userId: string,\r\n    templateId: string,\r\n    updates: { name?: string; exercises?: { id: string; name: string; sets?: number }[] }\r\n): Promise<void> {\r\n    console.log('[Supabase] updateWorkoutTemplate called with:', {\r\n        userId,\r\n        templateId,\r\n        updates: {\r\n            name: updates.name,\r\n            exerciseCount: updates.exercises?.length\r\n        }\r\n    });\r\n\r\n    return withRetry(async () => {\r\n        const { data, error } = await supabaseClient\r\n            .from('workout_templates')\r\n            .update({\r\n                ...updates,\r\n                updated_at: new Date().toISOString(),\r\n            })\r\n            .eq('id', templateId)\r\n            .eq('user_id', userId)\r\n            .select();\r\n\r\n        if (error) {\r\n            console.error('[Supabase] Error updating workout template:', error);\r\n            throw error;\r\n        }\r\n\r\n        if (!data || data.length === 0) {\r\n            console.warn('[Supabase] updateWorkoutTemplate: No rows matched!', { templateId, userId });\r\n        } else {\r\n            console.log('[Supabase] updateWorkoutTemplate success:', {\r\n                rowsUpdated: data.length,\r\n                exercisesInDB: data[0]?.exercises?.length\r\n            });\r\n        }\r\n    });\r\n}\r\n\r\nexport async function deleteWorkoutTemplate(userId: string, templateId: string): Promise<void> {\r\n    return withRetry(async () => {\r\n        const { error } = await supabaseClient\r\n            .from('workout_templates')\r\n            .delete()\r\n            .eq('id', templateId)\r\n            .eq('user_id', userId);\r\n\r\n        if (error) {\r\n            console.error('[Supabase] Error deleting workout template:', error);\r\n            throw error;\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Update an individual workout within a plan (stored in plan_workouts table)\r\n * This is the critical function for persisting workout edits within programs.\r\n */\r\nexport async function updatePlanWorkout(\r\n    userId: string,\r\n    workoutId: string,\r\n    updates: { name?: string; exercises?: { id: string; name: string; sets?: number }[] }\r\n): Promise<void> {\r\n    console.log('[Supabase] updatePlanWorkout called with:', {\r\n        userId,\r\n        workoutId,\r\n        updates: {\r\n            name: updates.name,\r\n            exerciseCount: updates.exercises?.length\r\n        }\r\n    });\r\n\r\n    return withRetry(async () => {\r\n        const { data, error, count } = await supabaseClient\r\n            .from('plan_workouts')\r\n            .update({\r\n                ...updates,\r\n                updated_at: new Date().toISOString(),\r\n            })\r\n            .eq('id', workoutId)\r\n            .eq('user_id', userId)\r\n            .select();\r\n\r\n        if (error) {\r\n            console.error('[Supabase] Error updating plan workout:', error);\r\n            throw error;\r\n        }\r\n\r\n        if (!data || data.length === 0) {\r\n            console.warn('[Supabase] updatePlanWorkout: No rows matched!', { workoutId, userId });\r\n        } else {\r\n            console.log('[Supabase] updatePlanWorkout success:', {\r\n                rowsUpdated: data.length,\r\n                exercisesInDB: data[0]?.exercises?.length\r\n            });\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Delete an individual workout from a plan (stored in plan_workouts table)\r\n */\r\nexport async function deletePlanWorkout(\r\n    userId: string,\r\n    workoutId: string\r\n): Promise<void> {\r\n    return withRetry(async () => {\r\n        const { error } = await supabaseClient\r\n            .from('plan_workouts')\r\n            .delete()\r\n            .eq('id', workoutId)\r\n            .eq('user_id', userId);\r\n\r\n        if (error) {\r\n            console.error('[Supabase] Error deleting plan workout:', error);\r\n            throw error;\r\n        }\r\n    });\r\n}\r\n\r\n// ============================================================================\r\n// SCHEDULES\r\n// ============================================================================\r\n\r\nexport interface ScheduleDataWeekly {\r\n    monday: string | null;\r\n    tuesday: string | null;\r\n    wednesday: string | null;\r\n    thursday: string | null;\r\n    friday: string | null;\r\n    saturday: string | null;\r\n    sunday: string | null;\r\n}\r\n\r\nexport interface RotatingDayDB {\r\n    id: string;\r\n    dayNumber: number;\r\n    planId: string | null;\r\n}\r\n\r\nexport interface ScheduleDataRotating {\r\n    days: RotatingDayDB[];\r\n    startDate: number | null;\r\n}\r\n\r\nexport interface ScheduleDataFull {\r\n    type: 'weekly' | 'rotating';\r\n    weekly?: ScheduleDataWeekly;\r\n    rotating?: ScheduleDataRotating;\r\n}\r\n\r\nexport interface ScheduleDB {\r\n    id: string;\r\n    name: string;\r\n    schedule_data: ScheduleDataFull | ScheduleDataWeekly;\r\n    is_active: boolean;\r\n    created_at: string;\r\n    updated_at: string;\r\n}\r\n\r\nexport async function fetchSchedules(userId: string): Promise<ScheduleDB[]> {\r\n    console.log('[Supabase] Fetching schedules for user:', userId);\r\n\r\n    return withGracefulRetry(\r\n        async () => {\r\n            const { data, error } = await supabaseClient\r\n                .from('schedules')\r\n                .select('*')\r\n                .eq('user_id', userId)\r\n                .order('created_at', { ascending: false });\r\n\r\n            if (error) {\r\n                throw error;\r\n            }\r\n\r\n            console.log('[Supabase] Successfully fetched', data?.length ?? 0, 'schedules');\r\n\r\n            return (data || []).map((row) => ({\r\n                id: row.id,\r\n                name: row.name,\r\n                schedule_data: row.schedule_data || {},\r\n                is_active: row.is_active || false,\r\n                created_at: row.created_at,\r\n                updated_at: row.updated_at,\r\n            }));\r\n        },\r\n        [], // fallback to empty array\r\n        'fetchSchedules'\r\n    );\r\n}\r\n\r\nexport async function createSchedule(\r\n    userId: string,\r\n    schedule: { name: string; scheduleData: ScheduleDataFull }\r\n): Promise<string> {\r\n    return withRetry(async () => {\r\n        const { data, error } = await supabaseClient\r\n            .from('schedules')\r\n            .insert({\r\n                user_id: userId,\r\n                name: schedule.name,\r\n                schedule_data: schedule.scheduleData,\r\n            })\r\n            .select('id')\r\n            .single();\r\n\r\n        if (error) {\r\n            console.error('[Supabase] Error creating schedule:', error);\r\n            throw error;\r\n        }\r\n\r\n        return data.id;\r\n    });\r\n}\r\n\r\nexport async function updateSchedule(\r\n    userId: string,\r\n    scheduleId: string,\r\n    updates: { name?: string; scheduleData?: ScheduleDataFull; is_active?: boolean }\r\n): Promise<void> {\r\n    return withRetry(async () => {\r\n        const updateData: Record<string, unknown> = {\r\n            updated_at: new Date().toISOString(),\r\n        };\r\n\r\n        if (updates.name !== undefined) updateData.name = updates.name;\r\n        if (updates.scheduleData !== undefined) updateData.schedule_data = updates.scheduleData;\r\n        if (updates.is_active !== undefined) updateData.is_active = updates.is_active;\r\n\r\n        const { error } = await supabaseClient\r\n            .from('schedules')\r\n            .update(updateData)\r\n            .eq('id', scheduleId)\r\n            .eq('user_id', userId);\r\n\r\n        if (error) {\r\n            console.error('[Supabase] Error updating schedule:', error);\r\n            throw error;\r\n        }\r\n    });\r\n}\r\n\r\nexport async function deleteSchedule(userId: string, scheduleId: string): Promise<void> {\r\n    return withRetry(async () => {\r\n        const { error } = await supabaseClient\r\n            .from('schedules')\r\n            .delete()\r\n            .eq('id', scheduleId)\r\n            .eq('user_id', userId);\r\n\r\n        if (error) {\r\n            console.error('[Supabase] Error deleting schedule:', error);\r\n            throw error;\r\n        }\r\n    });\r\n}\r\n\r\n// ============================================================================\r\n// CUSTOM EXERCISES\r\n// ============================================================================\r\n\r\nexport interface CustomExerciseDB {\r\n    id: string;\r\n    name: string;\r\n    exercise_type: string;\r\n    created_at: string;\r\n    updated_at: string;\r\n}\r\n\r\nexport async function fetchCustomExercises(userId: string): Promise<CustomExerciseDB[]> {\r\n    console.log('[Supabase] Fetching custom exercises for user:', userId);\r\n\r\n    return withGracefulRetry(\r\n        async () => {\r\n            const { data, error } = await supabaseClient\r\n                .from('custom_exercises')\r\n                .select('*')\r\n                .eq('user_id', userId)\r\n                .order('created_at', { ascending: false });\r\n\r\n            if (error) {\r\n                throw error;\r\n            }\r\n\r\n            console.log('[Supabase] Successfully fetched', data?.length ?? 0, 'custom exercises');\r\n\r\n            return (data || []).map((row) => ({\r\n                id: row.id,\r\n                name: row.name,\r\n                exercise_type: row.exercise_type,\r\n                created_at: row.created_at,\r\n                updated_at: row.updated_at,\r\n            }));\r\n        },\r\n        [],\r\n        'fetchCustomExercises'\r\n    );\r\n}\r\n\r\nexport async function createCustomExercise(\r\n    userId: string,\r\n    exercise: { name: string; exerciseType: string }\r\n): Promise<string> {\r\n    return withRetry(async () => {\r\n        const { data, error } = await supabaseClient\r\n            .from('custom_exercises')\r\n            .insert({\r\n                user_id: userId,\r\n                name: exercise.name,\r\n                exercise_type: exercise.exerciseType,\r\n            })\r\n            .select('id')\r\n            .single();\r\n\r\n        if (error) {\r\n            console.error('[Supabase] Error creating custom exercise:', error);\r\n            throw error;\r\n        }\r\n\r\n        return data.id;\r\n    });\r\n}\r\n\r\nexport async function deleteCustomExercise(userId: string, exerciseId: string): Promise<void> {\r\n    return withRetry(async () => {\r\n        const { error } = await supabaseClient\r\n            .from('custom_exercises')\r\n            .delete()\r\n            .eq('id', exerciseId)\r\n            .eq('user_id', userId);\r\n\r\n        if (error) {\r\n            console.error('[Supabase] Error deleting custom exercise:', error);\r\n            throw error;\r\n        }\r\n    });\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\providers\\AuthProvider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\providers\\PlanBuilderProvider.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'builderState'. Either include it or remove the dependency array.","line":44,"column":6,"nodeType":"ArrayExpression","endLine":44,"endColumn":48,"suggestions":[{"desc":"Update the dependencies array to be: [builderState, builderState.resetBuilder, editingPlanId]","fix":{"range":[1112,1154],"text":"[builderState, builderState.resetBuilder, editingPlanId]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'builderState'. Either include it or remove the dependency array.","line":51,"column":6,"nodeType":"ArrayExpression","endLine":51,"endColumn":33,"suggestions":[{"desc":"Update the dependencies array to be: [builderState]","fix":{"range":[1336,1363],"text":"[builderState]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'builderState'. Either include it or remove the dependency array.","line":56,"column":6,"nodeType":"ArrayExpression","endLine":56,"endColumn":33,"suggestions":[{"desc":"Update the dependencies array to be: [builderState]","fix":{"range":[1486,1513],"text":"[builderState]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * PlanBuilderProvider\r\n * Shares create-plan builder state across screens.\r\n */\r\nimport React, {\r\n  createContext,\r\n  useCallback,\r\n  useContext,\r\n  useEffect,\r\n  useMemo,\r\n  useState,\r\n  type ReactNode,\r\n} from 'react';\r\nimport { useCreatePlanBuilder } from '@/hooks/useCreatePlanBuilder';\r\n\r\ninterface PlanBuilderProviderProps {\r\n  children: ReactNode;\r\n}\r\n\r\ninterface PlanBuilderContextValue extends ReturnType<typeof useCreatePlanBuilder> {\r\n  editingPlanId: string | null;\r\n  setEditingPlanId: (planId: string | null) => void;\r\n  resetSession: () => void;\r\n  isLoading: boolean;\r\n  setIsLoading: (loading: boolean) => void;\r\n}\r\n\r\nconst PlanBuilderContext = createContext<PlanBuilderContextValue | null>(null);\r\n\r\nexport const PlanBuilderProvider: React.FC<PlanBuilderProviderProps> = ({ children }) => {\r\n  const [editingPlanId, setEditingPlanIdState] = useState<string | null>(null);\r\n\r\n  const builderState = useCreatePlanBuilder({\r\n    editingPlanId,\r\n    onSuccess: undefined,\r\n  });\r\n\r\n  useEffect(() => {\r\n    if (editingPlanId) {\r\n      return;\r\n    }\r\n\r\n    builderState.resetBuilder();\r\n  }, [builderState.resetBuilder, editingPlanId]);\r\n\r\n  const setEditingPlanId = useCallback((planId: string | null) => {\r\n    setEditingPlanIdState(planId);\r\n    if (planId) {\r\n      builderState.setIsLoading(true);\r\n    }\r\n  }, [builderState.setIsLoading]);\r\n\r\n  const resetSession = useCallback(() => {\r\n    setEditingPlanIdState(null);\r\n    builderState.resetBuilder();\r\n  }, [builderState.resetBuilder]);\r\n\r\n  const contextValue = useMemo<PlanBuilderContextValue>(\r\n    () => ({\r\n      ...builderState,\r\n      editingPlanId,\r\n      setEditingPlanId,\r\n      resetSession,\r\n      isLoading: builderState.isLoading || false,\r\n      setIsLoading: builderState.setIsLoading,\r\n    }),\r\n    [builderState, editingPlanId, resetSession, setEditingPlanId],\r\n  );\r\n\r\n  return <PlanBuilderContext.Provider value={contextValue}>{children}</PlanBuilderContext.Provider>;\r\n};\r\n\r\nexport const usePlanBuilderContext = (): PlanBuilderContextValue => {\r\n  const context = useContext(PlanBuilderContext);\r\n\r\n  if (!context) {\r\n    throw new Error('usePlanBuilderContext must be used within PlanBuilderProvider');\r\n  }\r\n\r\n  return context;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\providers\\ProgramBuilderProvider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\scripts\\migrateExerciseNames.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\scripts\\migrateExerciseNamesNode.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\services\\feedbackService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\services\\herculesAIService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\services\\notificationService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\store\\activeScheduleStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\store\\customExerciseStore.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":145,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":145,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * customExerciseStore\r\n * Zustand store managing user-created custom exercises.\r\n * \r\n * Custom exercises:\r\n * - Are created by users when the built-in exercise library doesn't have what they need\r\n * - Have a name and exercise type (for proper set tracking)\r\n * - Persist across sessions via Supabase\r\n * - Do NOT contribute to analytics/statistics\r\n * - Are user-specific\r\n * \r\n * Storage: Supabase (custom_exercises table)\r\n */\r\n\r\nimport { create } from 'zustand';\r\n\r\nimport { supabaseClient } from '@/lib/supabaseClient';\r\nimport {\r\n  fetchCustomExercises,\r\n  createCustomExercise,\r\n  deleteCustomExercise,\r\n} from '@/lib/supabaseQueries';\r\nimport type { ExerciseType } from '@/types/exercise';\r\nimport { exercises as baseExerciseCatalog } from '@/constants/exercises';\r\n\r\nexport interface CustomExercise {\r\n  id: string;\r\n  name: string;\r\n  exerciseType: ExerciseType;\r\n  isCustom: true;\r\n  createdAt: number;\r\n}\r\n\r\nexport interface CustomExerciseState {\r\n  customExercises: CustomExercise[];\r\n  isLoading: boolean;\r\n  addCustomExercise: (input: { name: string; exerciseType: ExerciseType }) => Promise<CustomExercise | null>;\r\n  removeCustomExercise: (id: string) => Promise<void>;\r\n  hydrateCustomExercises: (userId?: string) => Promise<void>;\r\n  getCustomExerciseByName: (name: string) => CustomExercise | undefined;\r\n}\r\n\r\nexport const useCustomExerciseStore = create<CustomExerciseState>((set, get) => ({\r\n  customExercises: [],\r\n  isLoading: false,\r\n\r\n  addCustomExercise: async ({ name, exerciseType }) => {\r\n    const trimmedName = name.trim();\r\n    if (!trimmedName) return null;\r\n\r\n    // Check for duplicate names (both custom and built-in)\r\n    const existingCustom = get().customExercises.find(\r\n      (e) => e.name.toLowerCase() === trimmedName.toLowerCase()\r\n    );\r\n    const existingBuiltIn = baseExerciseCatalog.find(\r\n      (e) => e.name.toLowerCase() === trimmedName.toLowerCase()\r\n    );\r\n\r\n    if (existingCustom || existingBuiltIn) {\r\n      console.warn('[customExerciseStore] Exercise with this name already exists');\r\n      return null;\r\n    }\r\n\r\n    try {\r\n      const { data: { user } } = await supabaseClient.auth.getUser();\r\n      if (!user) {\r\n        console.error('[customExerciseStore] No authenticated user');\r\n        return null;\r\n      }\r\n\r\n      const newId = await createCustomExercise(user.id, {\r\n        name: trimmedName,\r\n        exerciseType,\r\n      });\r\n\r\n      const customExercise: CustomExercise = {\r\n        id: newId,\r\n        name: trimmedName,\r\n        exerciseType,\r\n        isCustom: true,\r\n        createdAt: Date.now(),\r\n      };\r\n\r\n      set((state) => ({\r\n        customExercises: [customExercise, ...state.customExercises],\r\n      }));\r\n\r\n      console.log('[customExerciseStore] Custom exercise added with ID:', newId);\r\n      return customExercise;\r\n    } catch (error) {\r\n      console.error('[customExerciseStore] Failed to add custom exercise', error);\r\n      await get().hydrateCustomExercises();\r\n      return null;\r\n    }\r\n  },\r\n\r\n  removeCustomExercise: async (id) => {\r\n    try {\r\n      const { data: { user } } = await supabaseClient.auth.getUser();\r\n      if (!user) {\r\n        console.error('[customExerciseStore] No authenticated user');\r\n        return;\r\n      }\r\n\r\n      set((state) => ({\r\n        customExercises: state.customExercises.filter((e) => e.id !== id),\r\n      }));\r\n\r\n      await deleteCustomExercise(user.id, id);\r\n      console.log('[customExerciseStore] Custom exercise deleted');\r\n    } catch (error) {\r\n      console.error('[customExerciseStore] Failed to delete custom exercise', error);\r\n      await get().hydrateCustomExercises();\r\n    }\r\n  },\r\n\r\n  hydrateCustomExercises: async (userId?: string) => {\r\n    try {\r\n      set({ isLoading: true });\r\n\r\n      let uid = userId;\r\n      if (!uid) {\r\n        const { data: { user } } = await supabaseClient.auth.getUser();\r\n        uid = user?.id;\r\n      }\r\n\r\n      if (!uid) {\r\n        console.log('[customExerciseStore] No authenticated user, skipping hydration');\r\n        set({ customExercises: [], isLoading: false });\r\n        return;\r\n      }\r\n\r\n      const exercises = await fetchCustomExercises(uid);\r\n\r\n      const normalizedExercises: CustomExercise[] = exercises.map((item) => ({\r\n        id: item.id,\r\n        name: item.name,\r\n        exerciseType: item.exercise_type as ExerciseType,\r\n        isCustom: true,\r\n        createdAt: new Date(item.created_at).getTime(),\r\n      }));\r\n\r\n      set({ customExercises: normalizedExercises, isLoading: false });\r\n      console.log('[customExerciseStore] Hydrated', normalizedExercises.length, 'custom exercises');\r\n    } catch (error) {\r\n      console.warn('[customExerciseStore] Hydration failed, using empty state');\r\n      set({ customExercises: [], isLoading: false });\r\n    }\r\n  },\r\n\r\n  getCustomExerciseByName: (name: string) => {\r\n    return get().customExercises.find(\r\n      (e) => e.name.toLowerCase() === name.toLowerCase()\r\n    );\r\n  },\r\n}));\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\store\\devToolsStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\store\\navigationStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\store\\notificationStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\store\\personalRecordsStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\store\\plansStore.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useWorkoutSessionsStore' is defined but never used.","line":20,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":20,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":262,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":262,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * workoutsStore (formerly plansStore)\n * Zustand store managing user-created workout templates.\n * \n * TERMINOLOGY:\n * - Workout Template: A collection of exercises (e.g., \"Push Day\", \"Pull Day\")\n * - Plan/Program: A collection of workouts (e.g., \"PPL\", \"Bro Split\") - see programsStore\n * - Exercise: An individual movement (e.g., \"Bench Press\", \"Squat\")\n * \n * Note: The \"Plan\" type here is actually a Workout Template. This naming is legacy.\n * Use the Workout type alias for new code.\n * \n * Storage: Supabase (workout_templates table)\n */\nimport { create } from 'zustand';\n\nimport { exercises, type Exercise } from '@/constants/exercises';\nimport { canAddWorkout, getTotalUniqueWorkoutCount } from '@/utils/premiumLimits';\nimport { useProgramsStore } from '@/store/programsStore';\nimport { useWorkoutSessionsStore } from '@/store/workoutSessionsStore';\nimport { supabaseClient } from '@/lib/supabaseClient';\nimport {\n  fetchWorkoutTemplates,\n  createWorkoutTemplate,\n  updateWorkoutTemplate,\n  deleteWorkoutTemplate,\n} from '@/lib/supabaseQueries';\n\n/**\n * A Workout is a collection of exercises (e.g., \"Push Day\")\n * @deprecated The name \"Plan\" is misleading. Use Workout type alias instead.\n */\nexport interface Plan {\n  id: string;\n  name: string;\n  exercises: Exercise[];\n  createdAt: number;\n  source?: 'premade' | 'custom' | 'library' | 'recommended'; // Track workout source\n}\n\n/** A Workout is a collection of exercises (e.g., \"Push Day\", \"Pull Day\") */\nexport type Workout = Plan;\n\n/** @deprecated Use WorkoutsState instead */\nexport interface PlansState {\n  plans: Plan[];\n  isLoading: boolean;\n  addPlan: (input: { id?: string; name: string; exercises: Exercise[]; createdAt?: number; source?: 'premade' | 'custom' | 'library' | 'recommended' }) => Promise<void>;\n  updatePlan: (plan: Plan) => Promise<void>;\n  removePlan: (id: string) => Promise<void>;\n  hydratePlans: (userId?: string) => Promise<void>;\n}\n\nexport const usePlansStore = create<PlansState>((set, get) => ({\n  plans: [],\n  isLoading: false,\n\n  addPlan: async ({ id, name, exercises: exerciseList, source }: { id?: string; name: string; exercises: Exercise[]; source?: 'premade' | 'custom' | 'library' | 'recommended' }) => {\n    const trimmedName = name.trim();\n    if (!trimmedName) return;\n\n    try {\n      const { data: { user } } = await supabaseClient.auth.getUser();\n      if (!user) {\n        console.error('[plansStore] No authenticated user');\n        return;\n      }\n\n      // Free user limit: max 7 workouts (only for new workouts, not edits)\n      const isEditing = Boolean(id && get().plans.some(p => p.id === id));\n      if (!isEditing) {\n        // Count total unique workouts across both custom and program workouts\n        // This matches what the user sees in \"My Workouts\"\n        const currentWorkoutCount = getTotalUniqueWorkoutCount(\n          get().plans,\n          useProgramsStore.getState().userPrograms,\n        );\n        console.log('[plansStore] Workout limit check:', { \n          currentWorkoutCount, \n          customWorkouts: get().plans.length,\n          canAdd: canAddWorkout(currentWorkoutCount), \n          limit: 7 \n        });\n        if (!canAddWorkout(currentWorkoutCount)) {\n          console.log('[plansStore] Blocking workout creation - limit reached');\n          throw new Error('FREE_LIMIT_REACHED');\n        }\n      }\n\n      // Create in Supabase\n      const templateExercises = exerciseList.map(e => ({\n        id: e.id,\n        name: e.name,\n        sets: 3,\n      }));\n\n      const newId = await createWorkoutTemplate(user.id, {\n        name: trimmedName,\n        exercises: templateExercises,\n        source: source || 'custom',\n      });\n\n      // Update local state\n      const plan: Plan = {\n        id: newId,\n        name: trimmedName,\n        exercises: [...exerciseList],\n        createdAt: Date.now(),\n        source: source || 'custom',\n      };\n\n      set((state) => ({\n        plans: [plan, ...state.plans],\n      }));\n\n      console.log('[plansStore] Workout template added to Supabase with ID:', newId);\n    } catch (error: any) {\n      // Don't log FREE_LIMIT_REACHED errors - they're handled in the UI\n      if (error?.message !== 'FREE_LIMIT_REACHED') {\n        console.error('[plansStore] Failed to add workout template', error);\n      }\n      // Re-throw to let UI handle it\n      throw error;\n    }\n  },\n\n  updatePlan: async (updatedPlan) => {\n    const trimmedName = updatedPlan.name.trim();\n    if (!trimmedName) return;\n\n    try {\n      const { data: { user } } = await supabaseClient.auth.getUser();\n      if (!user) {\n        console.error('[plansStore] No authenticated user');\n        return;\n      }\n\n      // Optimistic update\n      const normalizedPlan: Plan = {\n        ...updatedPlan,\n        name: trimmedName,\n        exercises: [...updatedPlan.exercises],\n      };\n\n      set((state) => ({\n        plans: state.plans.map((plan) => (plan.id === normalizedPlan.id ? normalizedPlan : plan)),\n      }));\n\n      // Sync to Supabase\n      await updateWorkoutTemplate(user.id, updatedPlan.id, {\n        name: trimmedName,\n        exercises: updatedPlan.exercises.map(e => ({\n          id: e.id,\n          name: e.name,\n          sets: 3,\n        })),\n      });\n\n      console.log('[plansStore] Workout template updated in Supabase');\n    } catch (error) {\n      console.error('[plansStore] Failed to update workout template', error);\n      await get().hydratePlans();\n    }\n  },\n\n  removePlan: async (id) => {\n    try {\n      const { data: { user } } = await supabaseClient.auth.getUser();\n      if (!user) {\n        console.error('[plansStore] No authenticated user');\n        return;\n      }\n\n      // Optimistic update\n      set((state) => ({\n        plans: state.plans.filter((plan) => plan.id !== id),\n      }));\n\n      // Sync to Supabase\n      await deleteWorkoutTemplate(user.id, id);\n      console.log('[plansStore] Workout template deleted from Supabase');\n    } catch (error) {\n      console.error('[plansStore] Failed to delete workout template', error);\n      await get().hydratePlans();\n    }\n  },\n\n  hydratePlans: async (userId?: string) => {\n    try {\n      set({ isLoading: true });\n\n      // Use provided userId or fetch from auth\n      let uid = userId;\n      if (!uid) {\n        const { data: { user } } = await supabaseClient.auth.getUser();\n        uid = user?.id;\n      }\n      \n      if (!uid) {\n        console.log('[plansStore] No authenticated user, skipping hydration');\n        set({ plans: [], isLoading: false });\n        return;\n      }\n\n      const templates = await fetchWorkoutTemplates(uid);\n      console.log('[plansStore] HYDRATING PLANS from Supabase', templates);\n\n      const exerciseLookupById = exercises.reduce<Record<string, Exercise>>((acc, exercise) => {\n        acc[exercise.id] = exercise;\n        return acc;\n      }, {});\n\n      const exerciseLookupByName = exercises.reduce<Record<string, Exercise>>((acc, exercise) => {\n        acc[exercise.name.toLowerCase().trim()] = exercise;\n        return acc;\n      }, {});\n\n      const normalizedPlans: Plan[] = [];\n      \n      for (const template of templates) {\n        try {\n          // Skip templates with invalid data\n          if (!template || typeof template.name !== 'string' || !template.id) {\n            console.warn('[plansStore] Skipping invalid template:', template?.id);\n            continue;\n          }\n\n          // Ensure exercises is an array\n          const templateExercises = Array.isArray(template.exercises) ? template.exercises : [];\n          \n          const normalizedExercises = templateExercises\n            .filter((item) => {\n              // Filter out invalid exercise objects\n              return item && typeof item === 'object' && typeof item.id === 'string';\n            })\n            .map((item) => {\n              if (exerciseLookupById[item.id]) {\n                return exerciseLookupById[item.id];\n              }\n              const nameKey = item.name?.toLowerCase().trim();\n              if (nameKey && exerciseLookupByName[nameKey]) {\n                return exerciseLookupByName[nameKey];\n              }\n              return null;\n            })\n            .filter((exercise): exercise is Exercise => Boolean(exercise));\n\n          normalizedPlans.push({\n            id: template.id,\n            name: template.name,\n            exercises: normalizedExercises,\n            createdAt: new Date(template.created_at).getTime(),\n            source: template.source || 'custom',\n          });\n        } catch (templateError) {\n          console.warn('[plansStore] Error processing template:', template?.id, templateError);\n        }\n      }\n\n      set({ plans: normalizedPlans, isLoading: false });\n      console.log('[plansStore] Hydrated', normalizedPlans.length, 'workout templates from Supabase');\n    } catch (error) {\n      // Silently handle hydration failures - network issues are expected during app startup\n      console.warn('[plansStore] Hydration failed, using empty state');\n      set({ plans: [], isLoading: false });\n    }\n  },\n}));\n\n// Note: Hydration is now triggered by auth state changes, not on module load\n// This prevents hydration before the user is authenticated\n\n// Correctly-named exports (use these for new code)\n/** WorkoutsState - the state interface for the workouts store */\nexport type WorkoutsState = PlansState;\n/** useWorkoutsStore - hook to access the workouts store */\nexport const useWorkoutsStore = usePlansStore;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\store\\programsStore.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'canAddWorkout' is defined but never used.","line":38,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":38,"endColumn":35},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FREE_LIMITS' is defined but never used.","line":38,"column":58,"nodeType":null,"messageId":"unusedVar","endLine":38,"endColumn":69},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":196,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":196,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * programsStore\r\n * Zustand store managing training plans (programs).\r\n * \r\n * TERMINOLOGY:\r\n * - Plan/Program: A collection of workouts (e.g., \"PPL\", \"Bro Split\")\r\n * - Workout: A collection of exercises (e.g., \"Push Day\", \"Pull Day\")\r\n * - Exercise: An individual movement (e.g., \"Bench Press\", \"Squat\")\r\n * \r\n * Note: \"Program\" and \"Plan\" are used interchangeably in this codebase.\r\n * Both refer to a collection of workouts.\r\n */\r\nimport { create } from 'zustand';\r\nimport type {\r\n  PremadeProgram,\r\n  UserProgram,\r\n  RotationSchedule,\r\n  ProgramWorkout,\r\n  PremadeWorkout,\r\n  PlanScheduleConfig,\r\n  WeeklyScheduleConfig,\r\n} from '@/types/premadePlan';\r\nimport premadeData from '@/data/premadePrograms.json';\r\nimport premadeWorkoutsData from '@/data/premadeWorkouts.json';\r\nimport { supabaseClient } from '@/lib/supabaseClient';\r\nimport {\r\n  fetchUserPlans,\r\n  createUserPlan,\r\n  updateUserPlan,\r\n  deleteUserPlan,\r\n  setActivePlan as setActivePlanInDB,\r\n  updateRotationState,\r\n  updatePlanWorkout,\r\n  deletePlanWorkout,\r\n  type RotationStateDB,\r\n} from '@/lib/supabaseQueries';\r\nimport { usePlansStore } from '@/store/plansStore';\r\nimport { canAddPlan, canAddWorkout, getProgramLimitType, FREE_LIMITS, getTotalUniqueWorkoutCount } from '@/utils/premiumLimits';\r\n\r\ninterface ProgramsState {\r\n  premadePrograms: PremadeProgram[];\r\n  premadeWorkouts: PremadeWorkout[];\r\n  userPrograms: UserProgram[];\r\n  activeRotation: RotationSchedule | null;\r\n  isLoading: boolean;\r\n\r\n  // Actions\r\n  loadPremadePrograms: () => void;\r\n  addUserProgram: (program: UserProgram) => Promise<string | null>;\r\n  clonePremadeProgram: (premadeId: string) => Promise<UserProgram | null>;\r\n  updateUserProgram: (program: UserProgram) => Promise<void>;\r\n  deleteUserProgram: (id: string) => Promise<void>;\r\n  updateWorkoutInProgram: (programId: string, workoutId: string, workoutUpdates: Partial<ProgramWorkout>) => Promise<void>;\r\n  deleteWorkoutFromProgram: (programId: string, workoutId: string) => Promise<void>;\r\n  addWorkoutToProgram: (programId: string, workout: ProgramWorkout) => Promise<void>;\r\n  reorderWorkoutsInProgram: (programId: string, workoutIds: string[]) => Promise<void>;\r\n\r\n  // Schedule Management\r\n  updateProgramSchedule: (programId: string, schedule: PlanScheduleConfig) => Promise<void>;\r\n  getActivePlan: () => UserProgram | null;\r\n  setActivePlan: (programId: string | null) => Promise<void>;\r\n  getTodayWorkout: () => ProgramWorkout | null;\r\n\r\n  // Active Plan ID\r\n  activePlanId: string | null;\r\n\r\n  // Rotation Management\r\n  setActiveRotation: (rotation: RotationSchedule | null) => Promise<void>;\r\n  advanceRotation: () => Promise<void>;\r\n  getCurrentRotationWorkout: () => string | null; // Returns workout ID\r\n  updateWorkoutsByName: (name: string, workoutUpdates: Partial<ProgramWorkout>) => Promise<void>;\r\n\r\n  // Helper Functions\r\n  generateUniqueWorkoutName: (baseName: string) => string;\r\n\r\n  hydratePrograms: (userId?: string) => Promise<void>;\r\n}\r\n\r\nexport const useProgramsStore = create<ProgramsState>((set, get) => ({\r\n  premadePrograms: [],\r\n  premadeWorkouts: [],\r\n  userPrograms: [],\r\n  activeRotation: null,\r\n  activePlanId: null,\r\n  isLoading: false,\r\n\r\n  /**\r\n   * Generate a unique workout name by checking both custom workouts and program workouts.\r\n   * If name already exists, appends (2), (3), etc.\r\n   */\r\n  generateUniqueWorkoutName: (baseName: string): string => {\r\n    // Collect all existing workout names (case-insensitive)\r\n    const existingNames = new Set<string>();\r\n\r\n    // Add custom workout names from plansStore\r\n    const customPlans = usePlansStore.getState().plans;\r\n    customPlans.forEach(p => {\r\n      existingNames.add(p.name.trim().toLowerCase());\r\n    });\r\n\r\n    // Add program workout names\r\n    get().userPrograms.forEach(prog => {\r\n      prog.workouts.forEach(w => {\r\n        existingNames.add(w.name.trim().toLowerCase());\r\n      });\r\n    });\r\n\r\n    const trimmedBase = baseName.trim();\r\n    if (!existingNames.has(trimmedBase.toLowerCase())) {\r\n      return trimmedBase;\r\n    }\r\n\r\n    // Find unique suffix\r\n    let counter = 2;\r\n    let uniqueName = `${trimmedBase} (${counter})`;\r\n    while (existingNames.has(uniqueName.toLowerCase())) {\r\n      counter++;\r\n      uniqueName = `${trimmedBase} (${counter})`;\r\n    }\r\n\r\n    return uniqueName;\r\n  },\r\n\r\n  loadPremadePrograms: () => {\r\n    try {\r\n      // Deep clone premade data to prevent accidental mutations\r\n      // The premade library should ALWAYS show the original, unmodified versions\r\n      const clonedPrograms = JSON.parse(JSON.stringify(premadeData.programs || [])) as PremadeProgram[];\r\n      const clonedWorkouts = JSON.parse(JSON.stringify(premadeWorkoutsData.workouts || [])) as PremadeWorkout[];\r\n\r\n      // Validate data before setting\r\n      const validPrograms = clonedPrograms.filter(p => p && p.id && p.name && p.metadata);\r\n      const validWorkouts = clonedWorkouts.filter(w => w && w.id && w.name && w.metadata);\r\n\r\n      set({\r\n        premadePrograms: validPrograms,\r\n        premadeWorkouts: validWorkouts\r\n      });\r\n    } catch (error) {\r\n      console.error('[programsStore] Error loading premade programs:', error);\r\n      set({\r\n        premadePrograms: [],\r\n        premadeWorkouts: []\r\n      });\r\n    }\r\n  },\r\n\r\n  hydratePrograms: async (userId?: string) => {\r\n    try {\r\n      set({ isLoading: true });\r\n\r\n      // Load Premade\r\n      get().loadPremadePrograms();\r\n\r\n      // Use provided userId or fetch from auth\r\n      let uid = userId;\r\n      if (!uid) {\r\n        const { data: { user } } = await supabaseClient.auth.getUser();\r\n        uid = user?.id;\r\n      }\r\n\r\n      if (!uid) {\r\n        console.log('[programsStore] No authenticated user, skipping user programs');\r\n        set({ userPrograms: [], activePlanId: null, isLoading: false });\r\n        return;\r\n      }\r\n\r\n      const userPrograms = await fetchUserPlans(uid);\r\n\r\n      // Find active plan\r\n      const activePlan = userPrograms.find(p => (p as any).is_active);\r\n      const activePlanId = activePlan?.id || null;\r\n\r\n      // Load Active Rotation from the active plan's rotation_state\r\n      let activeRotation: RotationSchedule | null = null;\r\n      if (activePlan && (activePlan as any).rotation_state) {\r\n        const rotState = (activePlan as any).rotation_state as RotationStateDB;\r\n        activeRotation = {\r\n          id: `rot-${activePlan.id}`,\r\n          name: activePlan.name,\r\n          programId: activePlan.id,\r\n          workoutSequence: rotState.workoutSequence || [],\r\n          currentIndex: rotState.currentIndex || 0,\r\n          lastAdvancedAt: rotState.lastAdvancedAt,\r\n        };\r\n      }\r\n\r\n      set({\r\n        userPrograms,\r\n        activePlanId,\r\n        activeRotation,\r\n        isLoading: false\r\n      });\r\n\r\n      console.log('[programsStore] Hydrated successfully from Supabase');\r\n    } catch (error) {\r\n      // Silently handle hydration failures - network issues are expected during app startup\r\n      console.warn('[programsStore] Hydration failed, using empty state');\r\n      set({ userPrograms: [], activePlanId: null, activeRotation: null, isLoading: false });\r\n    }\r\n  },\r\n\r\n  addUserProgram: async (program): Promise<string | null> => {\r\n    try {\r\n      const { data: { user } } = await supabaseClient.auth.getUser();\r\n      if (!user) {\r\n        console.error('[programsStore] No authenticated user');\r\n        return null;\r\n      }\r\n\r\n      // Free user limit: max 1 plan\r\n      const currentPlanCount = get().userPrograms.length;\r\n      if (!canAddPlan(currentPlanCount)) {\r\n        throw new Error('FREE_LIMIT_REACHED');\r\n      }\r\n\r\n      // Create in Supabase and get the generated UUIDs\r\n      const { id: newPlanId, workouts: mappedWorkouts } = await createUserPlan(user.id, program);\r\n\r\n      // Create a map of old IDs to new IDs for schedule correction\r\n      const idMap = new Map<string, string>();\r\n      program.workouts.forEach((pw, idx) => {\r\n        if (mappedWorkouts[idx]) {\r\n          idMap.set(pw.id, mappedWorkouts[idx].id);\r\n        }\r\n      });\r\n\r\n      // Update schedule if it exists\r\n      let finalSchedule = program.schedule;\r\n      if (finalSchedule) {\r\n        finalSchedule = JSON.parse(JSON.stringify(finalSchedule));\r\n        if (finalSchedule && finalSchedule.rotation?.workoutOrder) {\r\n          finalSchedule.rotation.workoutOrder = finalSchedule.rotation.workoutOrder.map(\r\n            oldId => idMap.get(oldId) || oldId\r\n          );\r\n        }\r\n        if (finalSchedule && finalSchedule.weekly) {\r\n          Object.keys(finalSchedule.weekly).forEach(day => {\r\n            const oldId = finalSchedule!.weekly![day as keyof WeeklyScheduleConfig];\r\n            if (oldId && idMap.has(oldId)) {\r\n              (finalSchedule!.weekly as any)[day] = idMap.get(oldId);\r\n            }\r\n          });\r\n        }\r\n      }\r\n\r\n      // Update the program with the Supabase-generated IDs\r\n      const programWithId: UserProgram = {\r\n        ...program,\r\n        id: newPlanId,\r\n        workouts: mappedWorkouts,\r\n        schedule: finalSchedule\r\n      };\r\n\r\n      // Update local state\r\n      const nextPrograms = [programWithId, ...get().userPrograms];\r\n      set({ userPrograms: nextPrograms });\r\n\r\n      console.log('[programsStore] Program added to Supabase with ID:', newPlanId);\r\n      return newPlanId;\r\n    } catch (error: any) {\r\n      // Don't log FREE_LIMIT_REACHED errors - they're handled in the UI\r\n      if (error?.message !== 'FREE_LIMIT_REACHED') {\r\n        console.error('[programsStore] Failed to add program', error);\r\n        await get().hydratePrograms();\r\n      }\r\n      // Re-throw to let UI handle it\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  clonePremadeProgram: async (premadeId) => {\r\n    const premade = get().premadePrograms.find(p => p.id === premadeId);\r\n    if (!premade) return null;\r\n\r\n    // Check free user limits\r\n    const currentPlanCount = get().userPrograms.length;\r\n    const currentWorkoutCount = getTotalUniqueWorkoutCount(\r\n      usePlansStore.getState().plans,\r\n      get().userPrograms,\r\n    );\r\n    const programWorkoutCount = premade.workouts.filter(w => w.exercises.length > 0).length;\r\n\r\n    console.log('[programsStore] Program limit check:', {\r\n      currentPlanCount,\r\n      currentWorkoutCount,\r\n      programWorkoutCount,\r\n      totalAfterAdding: currentWorkoutCount + programWorkoutCount,\r\n      limit: 7\r\n    });\r\n\r\n    // Determine which limit would be exceeded\r\n    const limitType = getProgramLimitType(currentPlanCount, currentWorkoutCount, programWorkoutCount);\r\n    if (limitType === 'plan') {\r\n      throw new Error('FREE_LIMIT_REACHED');\r\n    } else if (limitType === 'workout') {\r\n      throw new Error('WORKOUT_LIMIT_REACHED');\r\n    }\r\n\r\n    // Auto-rename if duplicate program name\r\n    const existingProgramNames = new Set(get().userPrograms.map(p => p.name));\r\n    let newProgramName = premade.name;\r\n    let programSuffix = '';\r\n    let programCounter = 2;\r\n    while (existingProgramNames.has(newProgramName)) {\r\n      programSuffix = ` (${programCounter})`;\r\n      newProgramName = `${premade.name}${programSuffix}`;\r\n      programCounter++;\r\n    }\r\n\r\n    // Generate unique IDs for each workout to prevent ID collisions\r\n    // This ensures each cloned workout is independent from the premade source\r\n    const workoutIdMap = new Map<string, string>();\r\n    const workouts = premade.workouts.map(w => {\r\n      const newId = `workout-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;\r\n      workoutIdMap.set(w.id, newId);\r\n\r\n      // Generate unique name for each individual workout\r\n      const uniqueWorkoutName = get().generateUniqueWorkoutName(w.name);\r\n\r\n      return {\r\n        ...w,\r\n        id: newId,\r\n        name: uniqueWorkoutName,\r\n        sourceWorkoutId: w.id, // Keep reference to original for potential \"reset\" feature\r\n      };\r\n    });\r\n\r\n    // Build Schedule\r\n    let schedule: PlanScheduleConfig | undefined;\r\n    const programId = `prog-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;\r\n\r\n    if (premade.suggestedSchedule) {\r\n      if (premade.scheduleType === 'rotation' && premade.suggestedSchedule.rotation) {\r\n        const newOrder = premade.suggestedSchedule.rotation.map(oldId => workoutIdMap.get(oldId) || oldId);\r\n        schedule = {\r\n          type: 'rotation',\r\n          rotation: {\r\n            workoutOrder: newOrder,\r\n            startDate: Date.now(), // Default to today\r\n          },\r\n          currentRotationIndex: 0,\r\n          lastUsedAt: Date.now(),\r\n        };\r\n\r\n\r\n      } else if (premade.scheduleType === 'weekly' && premade.suggestedSchedule.weekly) {\r\n        const newWeekly: any = {};\r\n        for (const [day, oldId] of Object.entries(premade.suggestedSchedule.weekly)) {\r\n          if (oldId) {\r\n            newWeekly[day] = workoutIdMap.get(oldId) || oldId;\r\n          } else {\r\n            newWeekly[day] = null;\r\n          }\r\n        }\r\n        schedule = {\r\n          type: 'weekly',\r\n          weekly: newWeekly,\r\n          lastUsedAt: Date.now(),\r\n        };\r\n        // Clear active rotation if switching to weekly\r\n        await get().setActiveRotation(null);\r\n      }\r\n    }\r\n\r\n    const userProgram: UserProgram = {\r\n      ...premade,\r\n      name: newProgramName,\r\n      workouts,\r\n      id: programId, // Temporary - will be replaced\r\n      isPremade: false,\r\n      sourceId: premade.id,\r\n      createdAt: Date.now(),\r\n      modifiedAt: Date.now(),\r\n      schedule: schedule,\r\n    };\r\n\r\n    // Add to Supabase and get the real UUID\r\n    try {\r\n      const realProgramId = await get().addUserProgram(userProgram);\r\n\r\n      // Set as active using the real ID from Supabase\r\n      if (realProgramId) {\r\n        await get().setActivePlan(realProgramId);\r\n\r\n        // Set rotation with real ID if needed\r\n        if (premade.scheduleType === 'rotation' && premade.suggestedSchedule?.rotation && schedule) {\r\n          const rotationSchedule: RotationSchedule = {\r\n            id: `rot-${Date.now()}`,\r\n            name: newProgramName,\r\n            programId: realProgramId,\r\n            workoutSequence: schedule.rotation?.workoutOrder || [],\r\n            currentIndex: 0,\r\n            lastAdvancedAt: Date.now(),\r\n          };\r\n          await get().setActiveRotation(rotationSchedule);\r\n        }\r\n\r\n        return { ...userProgram, id: realProgramId };\r\n      }\r\n\r\n      return null;\r\n    } catch (error: any) {\r\n      // Re-throw to let UI handle it (don't log here, addUserProgram already handles it)\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  updateUserProgram: async (program) => {\r\n    try {\r\n      const { data: { user } } = await supabaseClient.auth.getUser();\r\n      if (!user) {\r\n        console.error('[programsStore] No authenticated user');\r\n        return;\r\n      }\r\n\r\n      const updatedProgram = { ...program, modifiedAt: Date.now() };\r\n      const nextPrograms = get().userPrograms.map(p =>\r\n        p.id === program.id ? updatedProgram : p\r\n      );\r\n      set({ userPrograms: nextPrograms });\r\n\r\n      await updateUserPlan(user.id, updatedProgram);\r\n      console.log('[programsStore] Program updated in Supabase');\r\n    } catch (error) {\r\n      console.error('[programsStore] Failed to update program', error);\r\n      await get().hydratePrograms();\r\n    }\r\n  },\r\n\r\n  deleteUserProgram: async (id) => {\r\n    try {\r\n      const { data: { user } } = await supabaseClient.auth.getUser();\r\n      if (!user) {\r\n        console.error('[programsStore] No authenticated user');\r\n        return;\r\n      }\r\n\r\n      const nextPrograms = get().userPrograms.filter(p => p.id !== id);\r\n      set({ userPrograms: nextPrograms });\r\n\r\n      // Clear active plan if it was the deleted one\r\n      if (get().activePlanId === id) {\r\n        await get().setActivePlan(null);\r\n      }\r\n\r\n      // Clear active rotation if it was the deleted one\r\n      if (get().activeRotation?.programId === id) {\r\n        await get().setActiveRotation(null);\r\n      }\r\n\r\n      await deleteUserPlan(user.id, id);\r\n      console.log('[programsStore] Program deleted from Supabase');\r\n    } catch (error) {\r\n      console.error('[programsStore] Failed to delete program', error);\r\n      await get().hydratePrograms();\r\n    }\r\n  },\r\n\r\n  updateWorkoutInProgram: async (programId, workoutId, workoutUpdates) => {\r\n    const programs = get().userPrograms;\r\n    const programIndex = programs.findIndex(p => p.id === programId);\r\n    if (programIndex === -1) return;\r\n\r\n    const program = programs[programIndex];\r\n    const workouts = program.workouts.map(w =>\r\n      w.id === workoutId ? { ...w, ...workoutUpdates } : w\r\n    );\r\n\r\n    // Update local state immediately\r\n    const updatedProgram = { ...program, workouts, modifiedAt: Date.now() };\r\n    const nextPrograms = get().userPrograms.map(p =>\r\n      p.id === programId ? updatedProgram : p\r\n    );\r\n    set({ userPrograms: nextPrograms });\r\n\r\n    // Persist workout changes to DB\r\n    try {\r\n      const { data: { user } } = await supabaseClient.auth.getUser();\r\n      if (user) {\r\n        // Build the exercises array in the format expected by the DB\r\n        const exercisesToSave = workoutUpdates.exercises?.map(e => ({\r\n          id: e.id,\r\n          name: e.name,\r\n          sets: 3,\r\n        }));\r\n\r\n        await updatePlanWorkout(user.id, workoutId, {\r\n          name: workoutUpdates.name,\r\n          exercises: exercisesToSave,\r\n        });\r\n        console.log('[programsStore] Workout updated in plan_workouts table');\r\n      }\r\n    } catch (error) {\r\n      console.error('[programsStore] Failed to update workout in DB', error);\r\n      await get().hydratePrograms();\r\n    }\r\n  },\r\n\r\n  deleteWorkoutFromProgram: async (programId, workoutId) => {\r\n    const programs = get().userPrograms;\r\n    const programIndex = programs.findIndex(p => p.id === programId);\r\n    if (programIndex === -1) return;\r\n\r\n    const program = programs[programIndex];\r\n    const workouts = program.workouts.filter(w => w.id !== workoutId);\r\n\r\n    // Update schedule to remove all references to this workout\r\n    let updatedSchedule = program.schedule;\r\n    if (updatedSchedule) {\r\n      updatedSchedule = JSON.parse(JSON.stringify(updatedSchedule));\r\n      if (updatedSchedule!.rotation?.workoutOrder) {\r\n        updatedSchedule!.rotation.workoutOrder = updatedSchedule!.rotation.workoutOrder.filter(id => id !== workoutId);\r\n      }\r\n      if (updatedSchedule!.weekly) {\r\n        Object.keys(updatedSchedule!.weekly).forEach(day => {\r\n          if (updatedSchedule!.weekly![day as keyof WeeklyScheduleConfig] === workoutId) {\r\n            (updatedSchedule!.weekly as any)[day] = null;\r\n          }\r\n        });\r\n      }\r\n    }\r\n\r\n    const updatedProgram = {\r\n      ...program,\r\n      workouts,\r\n      schedule: updatedSchedule,\r\n      modifiedAt: Date.now()\r\n    };\r\n\r\n    // Update local state immediately\r\n    const nextPrograms = get().userPrograms.map(p =>\r\n      p.id === programId ? updatedProgram : p\r\n    );\r\n    set({ userPrograms: nextPrograms });\r\n\r\n    // Delete from DB and update program\r\n    try {\r\n      const { data: { user } } = await supabaseClient.auth.getUser();\r\n      if (user) {\r\n        await deletePlanWorkout(user.id, workoutId);\r\n        await updateUserPlan(user.id, updatedProgram);\r\n        console.log('[programsStore] Workout deleted from plan_workouts table');\r\n      }\r\n    } catch (error) {\r\n      console.error('[programsStore] Failed to delete workout from DB', error);\r\n      await get().hydratePrograms();\r\n    }\r\n\r\n    // Also update rotation sequence if needed\r\n    const rotation = get().activeRotation;\r\n    if (rotation && rotation.programId === programId) {\r\n      const sequence = rotation.workoutSequence.filter(id => id !== workoutId);\r\n      const newIndex = rotation.currentIndex >= sequence.length ? 0 : rotation.currentIndex;\r\n      await get().setActiveRotation({ ...rotation, workoutSequence: sequence, currentIndex: newIndex });\r\n    }\r\n  },\r\n\r\n  addWorkoutToProgram: async (programId, workout) => {\r\n    const programs = get().userPrograms;\r\n    const programIndex = programs.findIndex(p => p.id === programId);\r\n    if (programIndex === -1) return;\r\n\r\n    const program = programs[programIndex];\r\n    const workouts = [...program.workouts, workout];\r\n\r\n    // Update schedule to include this workout in rotation by default\r\n    let updatedSchedule = program.schedule;\r\n    if (updatedSchedule && updatedSchedule.type === 'rotation' && updatedSchedule.rotation) {\r\n      updatedSchedule = {\r\n        ...updatedSchedule,\r\n        rotation: {\r\n          ...updatedSchedule.rotation,\r\n          workoutOrder: [...updatedSchedule.rotation.workoutOrder, workout.id]\r\n        }\r\n      };\r\n    }\r\n\r\n    const updatedProgram = {\r\n      ...program,\r\n      workouts,\r\n      schedule: updatedSchedule,\r\n      modifiedAt: Date.now(),\r\n      metadata: {\r\n        ...program.metadata,\r\n        daysPerWeek: workouts.length,\r\n      }\r\n    };\r\n    await get().updateUserProgram(updatedProgram);\r\n  },\r\n\r\n  reorderWorkoutsInProgram: async (programId, workoutIds) => {\r\n    const programs = get().userPrograms;\r\n    const programIndex = programs.findIndex(p => p.id === programId);\r\n    if (programIndex === -1) return;\r\n\r\n    const program = programs[programIndex];\r\n    // Reorder workouts according to workoutIds order\r\n    const reorderedWorkouts = workoutIds\r\n      .map(id => program.workouts.find(w => w.id === id))\r\n      .filter((w): w is ProgramWorkout => w !== undefined);\r\n\r\n    const updatedProgram = { ...program, workouts: reorderedWorkouts, modifiedAt: Date.now() };\r\n    await get().updateUserProgram(updatedProgram);\r\n\r\n    // Also update rotation sequence if this program is active\r\n    const rotation = get().activeRotation;\r\n    if (rotation && rotation.programId === programId) {\r\n      await get().setActiveRotation({ ...rotation, workoutSequence: workoutIds });\r\n    }\r\n  },\r\n\r\n  updateProgramSchedule: async (programId, schedule) => {\r\n    const programs = get().userPrograms;\r\n    const programIndex = programs.findIndex(p => p.id === programId);\r\n    if (programIndex === -1) return;\r\n\r\n    const program = programs[programIndex];\r\n    const updatedProgram = {\r\n      ...program,\r\n      schedule,\r\n      scheduleType: schedule.type,\r\n      modifiedAt: Date.now()\r\n    };\r\n    await get().updateUserProgram(updatedProgram);\r\n  },\r\n\r\n  getActivePlan: () => {\r\n    const activePlanId = get().activePlanId;\r\n    if (!activePlanId) return null;\r\n    return get().userPrograms.find(p => p.id === activePlanId) || null;\r\n  },\r\n\r\n  setActivePlan: async (programId) => {\r\n    try {\r\n      const { data: { user } } = await supabaseClient.auth.getUser();\r\n      if (!user) {\r\n        console.error('[programsStore] No authenticated user');\r\n        return;\r\n      }\r\n\r\n      set({ activePlanId: programId });\r\n      await setActivePlanInDB(user.id, programId);\r\n      console.log('[programsStore] Active plan set in Supabase');\r\n    } catch (error) {\r\n      console.error('[programsStore] Failed to set active plan', error);\r\n    }\r\n  },\r\n\r\n  getTodayWorkout: () => {\r\n    const activePlan = get().getActivePlan();\r\n    if (!activePlan || !activePlan.schedule) return null;\r\n\r\n    const schedule = activePlan.schedule;\r\n\r\n    if (schedule.type === 'weekly' && schedule.weekly) {\r\n      // Get today's day of the week\r\n      const days: (keyof WeeklyScheduleConfig)[] = [\r\n        'sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'\r\n      ];\r\n      const today = days[new Date().getDay()];\r\n      const workoutId = schedule.weekly[today];\r\n\r\n      if (!workoutId) return null;\r\n      return activePlan.workouts.find(w => w.id === workoutId) || null;\r\n    }\r\n\r\n    if (schedule.type === 'rotation' && schedule.rotation) {\r\n      // If no start date is set, use the stored index\r\n      if (!schedule.rotation.startDate) {\r\n        const currentIndex = schedule.currentRotationIndex || 0;\r\n        const workoutId = schedule.rotation.workoutOrder[currentIndex];\r\n        if (!workoutId) return null;\r\n        return activePlan.workouts.find(w => w.id === workoutId) || null;\r\n      }\r\n\r\n      // Calculate based on start date\r\n      const now = new Date();\r\n      const start = new Date(schedule.rotation.startDate);\r\n\r\n      // Reset to midnight to compare dates only\r\n      now.setHours(0, 0, 0, 0);\r\n      start.setHours(0, 0, 0, 0);\r\n\r\n      const diffTime = now.getTime() - start.getTime();\r\n      const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));\r\n\r\n      // If start date is in the future, return null (rest day)\r\n      if (diffDays < 0) {\r\n        return null;\r\n      }\r\n\r\n      // Calculate which day of the rotation we're on\r\n      const currentIndex = diffDays % schedule.rotation.workoutOrder.length;\r\n      const workoutId = schedule.rotation.workoutOrder[currentIndex];\r\n      if (!workoutId) return null;\r\n      return activePlan.workouts.find(w => w.id === workoutId) || null;\r\n    }\r\n\r\n    return null;\r\n  },\r\n\r\n  setActiveRotation: async (rotation) => {\r\n    set({ activeRotation: rotation });\r\n\r\n    try {\r\n      const { data: { user } } = await supabaseClient.auth.getUser();\r\n      if (!user) {\r\n        console.error('[programsStore] No authenticated user for rotation update');\r\n        return;\r\n      }\r\n\r\n      if (rotation) {\r\n        // Save rotation state to the plan's rotation_state column\r\n        // Skip if programId is temporary (starts with \"prog-\") - wait for real ID\r\n        if (rotation.programId.startsWith('prog-')) {\r\n          console.log('[programsStore] Skipping rotation sync for temporary program ID');\r\n          return;\r\n        }\r\n\r\n        const rotationState: RotationStateDB = {\r\n          workoutSequence: rotation.workoutSequence,\r\n          currentIndex: rotation.currentIndex,\r\n          lastAdvancedAt: rotation.lastAdvancedAt || Date.now(),\r\n        };\r\n        await updateRotationState(user.id, rotation.programId, rotationState);\r\n        console.log('[programsStore] Rotation state saved to Supabase');\r\n      } else {\r\n        // Clear rotation state from the active plan\r\n        const activePlanId = get().activePlanId;\r\n        if (activePlanId) {\r\n          await updateRotationState(user.id, activePlanId, null);\r\n          console.log('[programsStore] Rotation state cleared in Supabase');\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('[programsStore] Failed to save rotation state:', error);\r\n    }\r\n  },\r\n\r\n  advanceRotation: async () => {\r\n    const rotation = get().activeRotation;\r\n    if (!rotation) return;\r\n\r\n    const nextIndex = (rotation.currentIndex + 1) % rotation.workoutSequence.length;\r\n    const updatedRotation = {\r\n      ...rotation,\r\n      currentIndex: nextIndex,\r\n      lastAdvancedAt: Date.now()\r\n    };\r\n\r\n    await get().setActiveRotation(updatedRotation);\r\n  },\r\n\r\n  getCurrentRotationWorkout: () => {\r\n    const rotation = get().activeRotation;\r\n    if (!rotation || rotation.workoutSequence.length === 0) return null;\r\n    return rotation.workoutSequence[rotation.currentIndex];\r\n  },\r\n\r\n  updateWorkoutsByName: async (name, workoutUpdates) => {\r\n    const nameKey = name.trim().toLowerCase();\r\n    const programs = get().userPrograms;\r\n    const affectedWorkoutIds: string[] = [];\r\n    const affectedPrograms: UserProgram[] = [];\r\n\r\n    programs.forEach(prog => {\r\n      let hasChange = false;\r\n      const nextWorkouts = prog.workouts.map(w => {\r\n        if (w.name.trim().toLowerCase() === nameKey) {\r\n          hasChange = true;\r\n          affectedWorkoutIds.push(w.id);\r\n          return { ...w, ...workoutUpdates };\r\n        }\r\n        return w;\r\n      });\r\n\r\n      if (hasChange) {\r\n        affectedPrograms.push({ ...prog, workouts: nextWorkouts, modifiedAt: Date.now() });\r\n      }\r\n    });\r\n\r\n    // Update local state immediately\r\n    if (affectedPrograms.length > 0) {\r\n      const nextPrograms = get().userPrograms.map(p => {\r\n        const updated = affectedPrograms.find(ap => ap.id === p.id);\r\n        return updated || p;\r\n      });\r\n      set({ userPrograms: nextPrograms });\r\n    }\r\n\r\n    // Persist each workout change to DB\r\n    if (affectedWorkoutIds.length > 0) {\r\n      try {\r\n        const { data: { user } } = await supabaseClient.auth.getUser();\r\n        if (user) {\r\n          // Build the exercises array in the format expected by the DB\r\n          const exercisesToSave = workoutUpdates.exercises?.map(e => ({\r\n            id: e.id,\r\n            name: e.name,\r\n            sets: 3,\r\n          }));\r\n\r\n          await Promise.all(affectedWorkoutIds.map(id =>\r\n            updatePlanWorkout(user.id, id, {\r\n              name: workoutUpdates.name,\r\n              exercises: exercisesToSave,\r\n            })\r\n          ));\r\n          console.log(`[programsStore] Updated ${affectedWorkoutIds.length} workouts in plan_workouts table for: ${name}`);\r\n        }\r\n      } catch (error) {\r\n        console.error('[programsStore] Failed to update workouts by name in DB', error);\r\n        await get().hydratePrograms();\r\n      }\r\n    }\r\n  }\r\n}));\r\n\r\n// Note: Hydration is now triggered by auth state changes in _layout.tsx\r\n// This prevents hydration before the user is authenticated\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\store\\schedulesStore.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'RotatingScheduleConfig' is defined but never used.","line":9,"column":39,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":61},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":192,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":192,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * schedulesStore\n * Zustand store managing user workout schedules.\n * \n * Storage: Supabase (schedules table)\n */\nimport { create } from 'zustand';\n\nimport type { Schedule, ScheduleType, RotatingScheduleConfig } from '@/types/schedule';\nimport { supabaseClient } from '@/lib/supabaseClient';\nimport {\n  fetchSchedules,\n  createSchedule,\n  updateSchedule as updateScheduleDB,\n  deleteSchedule as deleteScheduleDB,\n  type ScheduleDataFull,\n} from '@/lib/supabaseQueries';\n\ninterface SchedulesState {\n  schedules: Schedule[];\n  isLoading: boolean;\n  addSchedule: (schedule: Schedule) => Promise<void>;\n  deleteSchedule: (id: string) => Promise<void>;\n  updateSchedule: (schedule: Schedule) => Promise<void>;\n  getSchedules: () => Schedule[];\n  hydrateSchedules: (userId?: string) => Promise<void>;\n}\n\nconst scheduleToDBFormat = (schedule: Schedule): ScheduleDataFull => {\n  return {\n    type: schedule.type,\n    weekly: schedule.type === 'weekly' ? schedule.weekdays : undefined,\n    rotating: schedule.type === 'rotating' ? schedule.rotating : undefined,\n  };\n};\n\nconst dbToScheduleFormat = (dbSchedule: any): Schedule => {\n  const scheduleData = dbSchedule.schedule_data;\n  \n  // Handle legacy format (direct weekday keys) or new format (type + weekly/rotating)\n  const isNewFormat = scheduleData && 'type' in scheduleData;\n  \n  if (isNewFormat) {\n    const type: ScheduleType = scheduleData.type || 'weekly';\n    return {\n      id: dbSchedule.id,\n      name: dbSchedule.name,\n      type,\n      weekdays: scheduleData.weekly || {\n        monday: null,\n        tuesday: null,\n        wednesday: null,\n        thursday: null,\n        friday: null,\n        saturday: null,\n        sunday: null,\n      },\n      rotating: scheduleData.rotating,\n    };\n  }\n  \n  // Legacy format: direct weekday keys\n  return {\n    id: dbSchedule.id,\n    name: dbSchedule.name,\n    type: 'weekly',\n    weekdays: {\n      monday: scheduleData?.monday ?? null,\n      tuesday: scheduleData?.tuesday ?? null,\n      wednesday: scheduleData?.wednesday ?? null,\n      thursday: scheduleData?.thursday ?? null,\n      friday: scheduleData?.friday ?? null,\n      saturday: scheduleData?.saturday ?? null,\n      sunday: scheduleData?.sunday ?? null,\n    },\n  };\n};\n\nexport const useSchedulesStore = create<SchedulesState>((set, get) => ({\n  schedules: [],\n  isLoading: false,\n\n  addSchedule: async (schedule) => {\n    try {\n      const { data: { user } } = await supabaseClient.auth.getUser();\n      if (!user) {\n        console.error('[schedulesStore] No authenticated user');\n        return;\n      }\n\n      // Create in Supabase\n      const newId = await createSchedule(user.id, {\n        name: schedule.name,\n        scheduleData: scheduleToDBFormat(schedule),\n      });\n\n      // Update local state with the new ID from Supabase\n      const scheduleWithId: Schedule = {\n        ...schedule,\n        id: newId,\n      };\n\n      set((state) => ({\n        schedules: [scheduleWithId, ...state.schedules],\n      }));\n\n      console.log('[schedulesStore] Schedule added to Supabase with ID:', newId);\n    } catch (error) {\n      console.error('[schedulesStore] Failed to add schedule', error);\n      await get().hydrateSchedules();\n    }\n  },\n\n  deleteSchedule: async (id) => {\n    try {\n      const { data: { user } } = await supabaseClient.auth.getUser();\n      if (!user) {\n        console.error('[schedulesStore] No authenticated user');\n        return;\n      }\n\n      // Optimistic update\n      set((state) => ({\n        schedules: state.schedules.filter((schedule) => schedule.id !== id),\n      }));\n\n      // Sync to Supabase\n      await deleteScheduleDB(user.id, id);\n      console.log('[schedulesStore] Schedule deleted from Supabase');\n    } catch (error) {\n      console.error('[schedulesStore] Failed to delete schedule', error);\n      await get().hydrateSchedules();\n    }\n  },\n\n  updateSchedule: async (schedule) => {\n    try {\n      const { data: { user } } = await supabaseClient.auth.getUser();\n      if (!user) {\n        console.error('[schedulesStore] No authenticated user');\n        return;\n      }\n\n      // Optimistic update\n      set((state) => ({\n        schedules: state.schedules.map((existing) =>\n          existing.id === schedule.id ? schedule : existing\n        ),\n      }));\n\n      // Sync to Supabase\n      await updateScheduleDB(user.id, schedule.id, {\n        name: schedule.name,\n        scheduleData: scheduleToDBFormat(schedule),\n      });\n\n      console.log('[schedulesStore] Schedule updated in Supabase');\n    } catch (error) {\n      console.error('[schedulesStore] Failed to update schedule', error);\n      await get().hydrateSchedules();\n    }\n  },\n\n  getSchedules: () => {\n    return get().schedules;\n  },\n\n  hydrateSchedules: async (userId?: string) => {\n    try {\n      set({ isLoading: true });\n\n      // Use provided userId or fetch from auth\n      let uid = userId;\n      if (!uid) {\n        const { data: { user } } = await supabaseClient.auth.getUser();\n        uid = user?.id;\n      }\n      \n      if (!uid) {\n        console.log('[schedulesStore] No authenticated user, skipping hydration');\n        set({ schedules: [], isLoading: false });\n        return;\n      }\n\n      console.log('[schedulesStore] HYDRATING SCHEDULES from Supabase');\n      const dbSchedules = await fetchSchedules(uid);\n\n      const schedules: Schedule[] = dbSchedules.map(dbToScheduleFormat);\n\n      set({ schedules, isLoading: false });\n      console.log('[schedulesStore] Hydrated', schedules.length, 'schedules from Supabase');\n    } catch (error) {\n      // Silently handle hydration failures - network issues are expected during app startup\n      console.warn('[schedulesStore] Hydration failed, using empty state');\n      set({ schedules: [], isLoading: false });\n    }\n  },\n}));\n\nexport type { SchedulesState };\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\store\\sessionStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\store\\settingsStore.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":221,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":221,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * settingsStore\r\n * Zustand store for user settings with AsyncStorage persistence.\r\n * Handles granular unit preferences for weight, distance, and size.\r\n */\r\n\r\nimport { create } from 'zustand';\r\nimport { persist, createJSONStorage } from 'zustand/middleware';\r\nimport AsyncStorage from '@react-native-async-storage/async-storage';\r\nimport { supabaseClient } from '@/lib/supabaseClient';\r\n\r\nexport type UnitSystem = 'imperial' | 'metric';\r\nexport type WeightUnit = 'lbs' | 'kg';\r\nexport type DistanceUnit = 'mi' | 'km';\r\nexport type SizeUnit = 'in' | 'cm';\r\nexport type ThemePreference = 'light' | 'dark' | 'system';\r\n\r\ninterface SettingsState {\r\n  /** Legacy unit system preference (for backward compatibility) */\r\n  unitSystem: UnitSystem;\r\n  /** Granular weight unit preference: 'lbs' or 'kg' */\r\n  weightUnit: WeightUnit;\r\n  /** Granular distance unit preference: 'mi' or 'km' */\r\n  distanceUnit: DistanceUnit;\r\n  /** Granular size unit preference: 'in' or 'cm' (for body height) */\r\n  sizeUnit: SizeUnit;\r\n  /** Theme preference: 'light', 'dark', or 'system' */\r\n  themePreference: ThemePreference;\r\n  /** Whether user has Hercules Pro access */\r\n  isPro: boolean;\r\n  /** Weekly cardio time goal in seconds (null = no goal set) */\r\n  weeklyCardioTimeGoal: number | null;\r\n  /** Weekly cardio distance goal in miles (null = no goal set) */\r\n  weeklyCardioDistanceGoal: number | null;\r\n  /** Set the legacy unit system preference (updates all granular units) */\r\n  setUnitSystem: (system: UnitSystem) => void;\r\n  /** Set theme preference */\r\n  setThemePreference: (preference: ThemePreference) => void;\r\n  /** Set individual weight unit preference */\r\n  setWeightUnit: (unit: WeightUnit) => void;\r\n  /** Set individual distance unit preference */\r\n  setDistanceUnit: (unit: DistanceUnit) => void;\r\n  /** Set individual size unit preference */\r\n  setSizeUnit: (unit: SizeUnit) => void;\r\n  /** Set Pro status */\r\n  setPro: (isPro: boolean) => void;\r\n  /** Set weekly cardio time goal (in seconds) */\r\n  setWeeklyCardioTimeGoal: (seconds: number | null) => void;\r\n  /** Set weekly cardio distance goal (in miles) */\r\n  setWeeklyCardioDistanceGoal: (miles: number | null) => void;\r\n  /** Whether haptics are enabled globally */\r\n  hapticsEnabled: boolean;\r\n  /** Set haptics enabled status */\r\n  setHapticsEnabled: (enabled: boolean) => void;\r\n  /** Get weight unit label */\r\n  getWeightUnit: () => string;\r\n  /** Get height unit label */\r\n  getHeightUnit: () => string;\r\n  /** Get distance unit label */\r\n  getDistanceUnit: () => string;\r\n  /** Get distance unit abbreviation (mi or km) */\r\n  getDistanceUnitShort: () => string;\r\n  /** Convert weight from lbs to current unit */\r\n  convertWeight: (lbs: number) => number;\r\n  /** Convert weight from current unit to lbs (for storage) */\r\n  convertWeightToLbs: (value: number) => number;\r\n  /** Convert distance from miles to current unit */\r\n  convertDistance: (miles: number) => number;\r\n  /** Convert distance from current unit to miles (for storage) */\r\n  convertDistanceToMiles: (value: number) => number;\r\n  /** Format weight with unit label (e.g., \"135 lbs\" or \"61.2 kg\") */\r\n  formatWeight: (lbs: number, decimals?: number) => string;\r\n  /** Format weight without unit (just the number) */\r\n  formatWeightValue: (lbs: number, decimals?: number) => string;\r\n  /** Format distance with unit label (e.g., \"3.5 mi\" or \"5.6 km\") */\r\n  formatDistance: (miles: number, decimals?: number) => string;\r\n  /** Format distance without unit (just the number) */\r\n  formatDistanceValue: (miles: number, decimals?: number) => string;\r\n  /** Format number with commas for better readability */\r\n  formatNumberWithCommas: (num: number) => string;\r\n  /** Get distance unit for a specific exercise (handles meter override for Rowing Machine) */\r\n  getDistanceUnitForExercise: (distanceUnit?: 'miles' | 'meters' | 'floors') => string;\r\n  /** Convert distance for display (handles meter override for Rowing Machine) */\r\n  convertDistanceForExercise: (miles: number, distanceUnit?: 'miles' | 'meters' | 'floors') => number;\r\n  /** Convert distance from display to storage (handles meter override for Rowing Machine) */\r\n  convertDistanceToMilesForExercise: (value: number, distanceUnit?: 'miles' | 'meters' | 'floors') => number;\r\n  /** Format distance with unit for a specific exercise (handles meter override) */\r\n  formatDistanceForExercise: (miles: number, distanceUnit?: 'miles' | 'meters' | 'floors', decimals?: number) => string;\r\n  /** Format distance value for a specific exercise (handles meter override) */\r\n  formatDistanceValueForExercise: (miles: number, distanceUnit?: 'miles' | 'meters' | 'floors', decimals?: number) => string;\r\n  /** Sync settings from Supabase */\r\n  syncFromSupabase: () => Promise<void>;\r\n}\r\n\r\n// Conversion constants\r\nconst LBS_TO_KG = 0.453592;\r\nconst KG_TO_LBS = 2.20462;\r\nconst MILES_TO_KM = 1.60934;\r\nconst KM_TO_MILES = 0.621371;\r\nconst MILES_TO_METERS = 1609.34;\r\nconst METERS_TO_MILES = 0.000621371;\r\n\r\nexport const useSettingsStore = create<SettingsState>()(\r\n  persist(\r\n    (set, get) => ({\r\n      unitSystem: 'imperial',\r\n      weightUnit: 'lbs',\r\n      distanceUnit: 'mi',\r\n      sizeUnit: 'in',\r\n      themePreference: 'light',\r\n      isPro: false,\r\n      weeklyCardioTimeGoal: null,\r\n      weeklyCardioDistanceGoal: null,\r\n\r\n      setUnitSystem: (system: UnitSystem) => {\r\n        // Update all granular units when legacy system is changed\r\n        set({\r\n          unitSystem: system,\r\n          weightUnit: system === 'metric' ? 'kg' : 'lbs',\r\n          distanceUnit: system === 'metric' ? 'km' : 'mi',\r\n          sizeUnit: system === 'metric' ? 'cm' : 'in',\r\n        });\r\n      },\r\n\r\n      setThemePreference: async (preference: ThemePreference) => {\r\n        set({ themePreference: preference });\r\n        try {\r\n          const { data: { user } } = await supabaseClient.auth.getUser();\r\n          if (user) {\r\n            await supabaseClient.from('profiles').update({ theme_preference: preference }).eq('id', user.id);\r\n          }\r\n        } catch (error) {\r\n          console.warn('Failed to sync theme preference to Supabase', error);\r\n        }\r\n      },\r\n\r\n      setWeightUnit: async (unit: WeightUnit) => {\r\n        set({ weightUnit: unit });\r\n        try {\r\n          const { data: { user } } = await supabaseClient.auth.getUser();\r\n          if (user) {\r\n            await supabaseClient.from('profiles').update({ weight_unit: unit }).eq('id', user.id);\r\n          }\r\n        } catch (error) {\r\n          console.warn('Failed to sync weight unit to Supabase', error);\r\n        }\r\n      },\r\n\r\n      setDistanceUnit: async (unit: DistanceUnit) => {\r\n        set({ distanceUnit: unit });\r\n        try {\r\n          const { data: { user } } = await supabaseClient.auth.getUser();\r\n          if (user) {\r\n            await supabaseClient.from('profiles').update({ distance_unit: unit }).eq('id', user.id);\r\n          }\r\n        } catch (error) {\r\n          console.warn('Failed to sync distance unit to Supabase', error);\r\n        }\r\n      },\r\n\r\n      setSizeUnit: async (unit: SizeUnit) => {\r\n        set({ sizeUnit: unit });\r\n        try {\r\n          const { data: { user } } = await supabaseClient.auth.getUser();\r\n          if (user) {\r\n            await supabaseClient.from('profiles').update({ size_unit: unit }).eq('id', user.id);\r\n          }\r\n        } catch (error) {\r\n          console.warn('Failed to sync size unit to Supabase', error);\r\n        }\r\n      },\r\n\r\n      setPro: async (isPro: boolean) => {\r\n        set({ isPro });\r\n        try {\r\n          const { data: { user } } = await supabaseClient.auth.getUser();\r\n          if (user) {\r\n            await supabaseClient.from('profiles').update({ is_pro: isPro }).eq('id', user.id);\r\n          }\r\n        } catch (error) {\r\n          console.warn('Failed to sync Pro status to Supabase', error);\r\n        }\r\n      },\r\n\r\n      setWeeklyCardioTimeGoal: async (seconds: number | null) => {\r\n        set({ weeklyCardioTimeGoal: seconds });\r\n        try {\r\n          const { data: { user } } = await supabaseClient.auth.getUser();\r\n          if (user) {\r\n            await supabaseClient.from('profiles').update({ weekly_cardio_time_goal: seconds }).eq('id', user.id);\r\n          }\r\n        } catch (error) {\r\n          console.warn('Failed to sync weekly cardio time goal to Supabase', error);\r\n        }\r\n      },\r\n\r\n      setWeeklyCardioDistanceGoal: async (miles: number | null) => {\r\n        set({ weeklyCardioDistanceGoal: miles });\r\n        try {\r\n          const { data: { user } } = await supabaseClient.auth.getUser();\r\n          if (user) {\r\n            await supabaseClient.from('profiles').update({ weekly_cardio_distance_goal: miles }).eq('id', user.id);\r\n          }\r\n        } catch (error) {\r\n          console.warn('Failed to sync weekly cardio distance goal to Supabase', error);\r\n        }\r\n      },\r\n\r\n      hapticsEnabled: true,\r\n\r\n      setHapticsEnabled: async (enabled: boolean) => {\r\n        set({ hapticsEnabled: enabled });\r\n        try {\r\n          const { data: { user } } = await supabaseClient.auth.getUser();\r\n          if (user) {\r\n            // Check if column exists or handle error silently if it doesn't\r\n            // For now assuming we might not have a DB column yet, so just local persist is fine\r\n            // But if we want to sync, we can try:\r\n            await supabaseClient.from('profiles').update({ haptics_enabled: enabled }).eq('id', user.id);\r\n          }\r\n        } catch (error) {\r\n          // console.warn('Failed to sync haptics to Supabase', error);\r\n        }\r\n      },\r\n\r\n      syncFromSupabase: async () => {\r\n        try {\r\n          const { data: { user } } = await supabaseClient.auth.getUser();\r\n          if (user) {\r\n            const { data, error } = await supabaseClient\r\n              .from('profiles')\r\n              .select('unit_system, weight_unit, distance_unit, size_unit, theme_preference, is_pro, weekly_cardio_time_goal, weekly_cardio_distance_goal')\r\n              .eq('id', user.id)\r\n              .single();\r\n\r\n            if (data && !error) {\r\n              set({\r\n                // Only update if value exists in DB\r\n                unitSystem: (data.unit_system as UnitSystem) || get().unitSystem,\r\n                weightUnit: (data.weight_unit as WeightUnit) || get().weightUnit,\r\n                distanceUnit: (data.distance_unit as DistanceUnit) || get().distanceUnit,\r\n                sizeUnit: (data.size_unit as SizeUnit) || get().sizeUnit,\r\n                themePreference: (data.theme_preference as ThemePreference) || get().themePreference,\r\n                isPro: (data.is_pro as boolean) ?? get().isPro,\r\n                weeklyCardioTimeGoal: (data.weekly_cardio_time_goal as number | null) ?? get().weeklyCardioTimeGoal,\r\n                weeklyCardioDistanceGoal: (data.weekly_cardio_distance_goal as number | null) ?? get().weeklyCardioDistanceGoal,\r\n                // hapticsEnabled: (data.haptics_enabled as boolean) ?? get().hapticsEnabled,\r\n              });\r\n            }\r\n          }\r\n        } catch (error) {\r\n          console.warn('Failed to sync settings from Supabase', error);\r\n        }\r\n      },\r\n\r\n      getWeightUnit: () => {\r\n        return get().weightUnit === 'kg' ? 'kg' : 'lbs';\r\n      },\r\n\r\n      getHeightUnit: () => {\r\n        return get().sizeUnit === 'cm' ? 'cm' : 'in';\r\n      },\r\n\r\n      getDistanceUnit: () => {\r\n        return get().distanceUnit === 'km' ? 'kilometers' : 'miles';\r\n      },\r\n\r\n      getDistanceUnitShort: () => {\r\n        return get().distanceUnit === 'km' ? 'km' : 'mi';\r\n      },\r\n\r\n      convertWeight: (lbs: number) => {\r\n        if (get().weightUnit === 'kg') {\r\n          return Math.round(lbs * LBS_TO_KG * 10) / 10; // Round to 1 decimal\r\n        }\r\n        return lbs;\r\n      },\r\n\r\n      convertWeightToLbs: (value: number) => {\r\n        if (get().weightUnit === 'kg') {\r\n          return Math.round(value * KG_TO_LBS * 10) / 10;\r\n        }\r\n        return value;\r\n      },\r\n\r\n      convertDistance: (miles: number) => {\r\n        if (get().distanceUnit === 'km') {\r\n          return Math.round(miles * MILES_TO_KM * 100) / 100; // Round to 2 decimals\r\n        }\r\n        return miles;\r\n      },\r\n\r\n      convertDistanceToMiles: (value: number) => {\r\n        if (get().distanceUnit === 'km') {\r\n          return Math.round(value * KM_TO_MILES * 100) / 100;\r\n        }\r\n        return value;\r\n      },\r\n\r\n      formatWeight: (lbs: number, decimals?: number) => {\r\n        const unit = get().getWeightUnit();\r\n        const value = get().convertWeight(lbs);\r\n        let formatted: string;\r\n\r\n        if (decimals !== undefined) {\r\n          formatted = value.toFixed(decimals);\r\n        } else {\r\n          // Show up to 1 decimal place if it's not a whole number, otherwise show whole number\r\n          formatted = value % 1 === 0 ? value.toFixed(0) : value.toFixed(1);\r\n        }\r\n\r\n        // Add commas for better readability\r\n        formatted = get().formatNumberWithCommas(parseFloat(formatted));\r\n\r\n        return `${formatted} ${unit}`;\r\n      },\r\n\r\n      formatWeightValue: (lbs: number, decimals?: number) => {\r\n        const value = get().convertWeight(lbs);\r\n\r\n        if (decimals !== undefined) {\r\n          return get().formatNumberWithCommas(parseFloat(value.toFixed(decimals)));\r\n        }\r\n\r\n        const formatted = value % 1 === 0 ? value.toFixed(0) : value.toFixed(1);\r\n        return get().formatNumberWithCommas(parseFloat(formatted));\r\n      },\r\n\r\n      formatNumberWithCommas: (num: number): string => {\r\n        return num.toLocaleString('en-US');\r\n      },\r\n\r\n      formatDistance: (miles: number, decimals: number = 1) => {\r\n        const unit = get().getDistanceUnitShort();\r\n        const value = get().convertDistance(miles);\r\n        const formatted = value.toFixed(decimals);\r\n        return `${get().formatNumberWithCommas(parseFloat(formatted))} ${unit}`;\r\n      },\r\n\r\n      formatDistanceValue: (miles: number, decimals: number = 1) => {\r\n        const value = get().convertDistance(miles);\r\n        const formatted = value.toFixed(decimals);\r\n        return get().formatNumberWithCommas(parseFloat(formatted));\r\n      },\r\n\r\n      getDistanceUnitForExercise: (distanceUnit?: 'miles' | 'meters' | 'floors') => {\r\n        if (distanceUnit === 'meters') {\r\n          return 'm';\r\n        }\r\n        if (distanceUnit === 'floors') {\r\n          return 'floors';\r\n        }\r\n        return get().getDistanceUnitShort();\r\n      },\r\n\r\n      convertDistanceForExercise: (miles: number, distanceUnit?: 'miles' | 'meters' | 'floors') => {\r\n        if (distanceUnit === 'meters') {\r\n          return Math.round(miles * MILES_TO_METERS);\r\n        }\r\n        if (distanceUnit === 'floors') {\r\n          return miles;\r\n        }\r\n        return get().convertDistance(miles);\r\n      },\r\n\r\n      convertDistanceToMilesForExercise: (value: number, distanceUnit?: 'miles' | 'meters' | 'floors') => {\r\n        if (distanceUnit === 'meters') {\r\n          return Math.round(value * METERS_TO_MILES * 100) / 100;\r\n        }\r\n        if (distanceUnit === 'floors') {\r\n          return value;\r\n        }\r\n        return get().convertDistanceToMiles(value);\r\n      },\r\n\r\n      formatDistanceForExercise: (miles: number, distanceUnit?: 'miles' | 'meters' | 'floors', decimals?: number) => {\r\n        const unit = get().getDistanceUnitForExercise(distanceUnit);\r\n        const value = get().convertDistanceForExercise(miles, distanceUnit);\r\n        let formatted: string;\r\n\r\n        if (distanceUnit === 'meters') {\r\n          formatted = Math.round(value).toString();\r\n        } else if (decimals !== undefined) {\r\n          formatted = value.toFixed(decimals);\r\n        } else {\r\n          formatted = value.toFixed(1);\r\n        }\r\n\r\n        return `${get().formatNumberWithCommas(parseFloat(formatted))} ${unit}`;\r\n      },\r\n\r\n      formatDistanceValueForExercise: (miles: number, distanceUnit?: 'miles' | 'meters' | 'floors', decimals?: number) => {\r\n        const value = get().convertDistanceForExercise(miles, distanceUnit);\r\n        let formatted: string;\r\n\r\n        if (distanceUnit === 'meters') {\r\n          formatted = Math.round(value).toString();\r\n        } else if (decimals !== undefined) {\r\n          formatted = value.toFixed(decimals);\r\n        } else {\r\n          formatted = value.toFixed(1);\r\n        }\r\n\r\n        return get().formatNumberWithCommas(parseFloat(formatted));\r\n      },\r\n    }),\r\n    {\r\n      name: 'hercules-settings',\r\n      storage: createJSONStorage(() => AsyncStorage),\r\n      partialize: (state) => ({\r\n        unitSystem: state.unitSystem,\r\n        weightUnit: state.weightUnit,\r\n        distanceUnit: state.distanceUnit,\r\n        sizeUnit: state.sizeUnit,\r\n        themePreference: state.themePreference,\r\n        isPro: state.isPro,\r\n        hapticsEnabled: state.hapticsEnabled,\r\n        weeklyCardioTimeGoal: state.weeklyCardioTimeGoal,\r\n        weeklyCardioDistanceGoal: state.weeklyCardioDistanceGoal,\r\n      }),\r\n    }\r\n  )\r\n);\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\store\\userProfileStore.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":78,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":78,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * userProfileStore\r\n * Zustand store for centralized user profile state management.\r\n * Ensures real-time updates across the app when profile data changes.\r\n */\r\n\r\nimport { create } from 'zustand';\r\nimport { supabaseClient } from '@/lib/supabaseClient';\r\n\r\ninterface UserProfile {\r\n  firstName: string;\r\n  lastName: string;\r\n  fullName: string;\r\n  // Body metrics for analytics\r\n  heightFeet?: number;\r\n  heightInches?: number;\r\n  weightLbs?: number;\r\n}\r\n\r\ninterface UserProfileState {\r\n  /** User profile data */\r\n  profile: UserProfile | null;\r\n  /** Loading state for initial fetch */\r\n  isLoading: boolean;\r\n  /** Fetch profile from database */\r\n  fetchProfile: (userId: string) => Promise<void>;\r\n  /** Update profile in store and database */\r\n  updateProfile: (firstName: string, lastName: string) => Promise<void>;\r\n  /** Update body metrics (height/weight) */\r\n  updateBodyMetrics: (heightFeet: number, heightInches: number, weightLbs: number) => Promise<void>;\r\n  /** Clear profile (on logout) */\r\n  clearProfile: () => void;\r\n  /** Get user initial (first letter of first name) */\r\n  getUserInitial: () => string | null;\r\n  /** Get body weight in lbs for volume calculations */\r\n  getBodyWeightLbs: () => number | null;\r\n}\r\n\r\nexport const useUserProfileStore = create<UserProfileState>((set, get) => ({\r\n  profile: null,\r\n  isLoading: false,\r\n\r\n  fetchProfile: async (userId: string) => {\r\n    set({ isLoading: true });\r\n\r\n    try {\r\n      // Note: height_feet, height_inches, weight_lbs columns may not exist yet in Supabase\r\n      // Fetch only the columns that are guaranteed to exist\r\n      const { data, error } = await supabaseClient\r\n        .from('profiles')\r\n        .select('first_name, last_name, full_name, height_feet, height_inches, weight_lbs')\r\n        .eq('id', userId)\r\n        .single();\r\n\r\n      if (error) {\r\n        // Silently handle fetch failures - network issues are expected during app startup\r\n        console.warn('[UserProfileStore] Profile fetch failed, continuing with empty profile');\r\n        set({ profile: null, isLoading: false });\r\n        return;\r\n      }\r\n\r\n      if (data) {\r\n        set({\r\n          profile: {\r\n            firstName: data.first_name || '',\r\n            lastName: data.last_name || '',\r\n            fullName: data.full_name || '',\r\n            // Body metrics\r\n            heightFeet: data.height_feet,\r\n            heightInches: data.height_inches,\r\n            weightLbs: data.weight_lbs,\r\n          },\r\n          isLoading: false,\r\n        });\r\n      } else {\r\n        set({ profile: null, isLoading: false });\r\n      }\r\n    } catch (error) {\r\n      // Silently handle fetch failures - network issues are expected during app startup\r\n      console.warn('[UserProfileStore] Profile fetch failed, continuing with empty profile');\r\n      set({ profile: null, isLoading: false });\r\n    }\r\n  },\r\n\r\n  updateProfile: async (firstName: string, lastName: string) => {\r\n    const currentProfile = get().profile;\r\n    const fullName = `${firstName} ${lastName}`.trim();\r\n\r\n    // Optimistically update local state for immediate UI response\r\n    set({\r\n      profile: {\r\n        firstName,\r\n        lastName,\r\n        fullName,\r\n        // Preserve existing body metrics\r\n        heightFeet: currentProfile?.heightFeet,\r\n        heightInches: currentProfile?.heightInches,\r\n        weightLbs: currentProfile?.weightLbs,\r\n      },\r\n    });\r\n  },\r\n\r\n  updateBodyMetrics: async (heightFeet: number, heightInches: number, weightLbs: number) => {\r\n    const currentProfile = get().profile;\r\n\r\n    // Update local state (stored in memory for now)\r\n    // TODO: Add height_feet, height_inches, weight_lbs columns to Supabase profiles table\r\n    // then uncomment the Supabase persistence below\r\n    set({\r\n      profile: {\r\n        firstName: currentProfile?.firstName || '',\r\n        lastName: currentProfile?.lastName || '',\r\n        fullName: currentProfile?.fullName || '',\r\n        heightFeet,\r\n        heightInches,\r\n        weightLbs,\r\n      },\r\n    });\r\n\r\n    try {\r\n      const { data: { user } } = await supabaseClient.auth.getUser();\r\n      if (user) {\r\n        const { error } = await supabaseClient\r\n          .from('profiles')\r\n          .update({\r\n            height_feet: heightFeet,\r\n            height_inches: heightInches,\r\n            weight_lbs: weightLbs,\r\n          })\r\n          .eq('id', user.id);\r\n\r\n        if (error) {\r\n          console.error('[UserProfileStore] Error updating body metrics in Supabase:', error);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('[UserProfileStore] Error updating body metrics:', error);\r\n    }\r\n  },\r\n\r\n  clearProfile: () => {\r\n    set({ profile: null, isLoading: false });\r\n  },\r\n\r\n  getUserInitial: () => {\r\n    const { profile } = get();\r\n    if (profile?.firstName && profile.firstName.length > 0) {\r\n      return profile.firstName.charAt(0).toUpperCase();\r\n    }\r\n    return null;\r\n  },\r\n\r\n  getBodyWeightLbs: () => {\r\n    const { profile } = get();\r\n    return profile?.weightLbs ?? null;\r\n  },\r\n}));\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\store\\workoutSessionsStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\store\\workoutsStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\types\\activeSchedule.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\types\\analytics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\types\\dashboard.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\types\\exercise.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\types\\herculesAI.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\types\\plan.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\types\\planQuickBuilder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\types\\premadePlan.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\types\\schedule.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\types\\user.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\types\\workout.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\utils\\chartUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\utils\\clearCorruptedData.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\utils\\dashboard.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\utils\\date.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\utils\\environment.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\utils\\exerciseDisplayTags.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\utils\\exerciseFilters.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'DifficultyLevel' is defined but never used.","line":8,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FilterMuscleGroup' is defined but never used.","line":15,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'MuscleGroup' is defined but never used.","line":16,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * exerciseFilters\r\n * Helper utilities for plan builder exercise filtering logic.\r\n */\r\n\r\nimport hierarchyData from '@/data/hierarchy.json';\r\nimport type {\r\n  DifficultyLevel,\r\n  EquipmentType,\r\n  Exercise,\r\n  ExerciseFilters,\r\n  ExerciseType,\r\n  FilterDifficulty,\r\n  FilterEquipment,\r\n  FilterMuscleGroup,\r\n  MuscleGroup,\r\n} from '@/types/exercise';\r\nimport { EXERCISE_TYPE_LABELS } from '@/types/exercise';\r\n\r\nconst MUSCLE_HIERARCHY = hierarchyData.muscle_hierarchy as unknown as Record<string, { muscles: Record<string, any> }>;\r\n\r\nexport const createDefaultExerciseFilters = (): ExerciseFilters => ({\r\n  muscleGroups: [],\r\n  specificMuscles: [],\r\n  equipment: [],\r\n  difficulty: [],\r\n  bodyweightOnly: false,\r\n  compoundOnly: false,\r\n  exerciseTypes: [],\r\n});\r\n\r\nexport const toggleFilterValue = <T extends string>(values: T[], value: T): T[] => {\r\n  if (values.includes(value)) {\r\n    return values.filter((item) => item !== value);\r\n  }\r\n\r\n  return [...values, value];\r\n};\r\n\r\nconst matchesArrayFilter = <T extends string>(selected: T[], predicate: () => boolean): boolean => {\r\n  if (selected.length === 0) {\r\n    return true;\r\n  }\r\n\r\n  return predicate();\r\n};\r\n\r\nconst matchesMuscleGroup = (exercise: Exercise, filters: ExerciseFilters): boolean => {\r\n  const { muscleGroups, specificMuscles } = filters;\r\n  \r\n  // If no broad groups selected, verify if any specific muscles selected (if filter logic allows specific without broad, though UI might prevent this).\r\n  // If specific muscles are selected but no broad groups, standard OR logic for specific muscles.\r\n  if (muscleGroups.length === 0) {\r\n    return matchesArrayFilter(specificMuscles, () => {\r\n       return specificMuscles.includes(exercise.muscleGroup) || \r\n              exercise.secondaryMuscleGroups.some(m => specificMuscles.includes(m));\r\n    });\r\n  }\r\n\r\n  // If broad groups are selected, we apply the \"Refinement\" logic:\r\n  // For each selected broad group (e.g. Upper Body):\r\n  //   - If ANY specific muscles belonging to this broad group are selected (e.g. Chest), match ONLY those specific muscles.\r\n  //   - If NO specific muscles of this broad group are selected, match the WHOLE broad group.\r\n  // The result is the UNION of matches for each selected broad group.\r\n  \r\n  return muscleGroups.some(broadGroup => {\r\n    // 1. Does this exercise belong to this broad group?\r\n    if (exercise.filterMuscleGroup !== broadGroup) {\r\n      return false;\r\n    }\r\n    \r\n    // 2. Get specific muscles for this broad group from hierarchy\r\n    const hierarchyMuscles = Object.keys(MUSCLE_HIERARCHY[broadGroup]?.muscles || {});\r\n    \r\n    // 3. Check if any of these are selected in specificMuscles\r\n    const selectedSpecificsForGroup = specificMuscles.filter(m => hierarchyMuscles.includes(m));\r\n    \r\n    if (selectedSpecificsForGroup.length > 0) {\r\n      // Refined: Exercise must match one of the selected specific muscles\r\n      return selectedSpecificsForGroup.includes(exercise.muscleGroup) ||\r\n             exercise.secondaryMuscleGroups.some(m => selectedSpecificsForGroup.includes(m));\r\n    }\r\n    \r\n    // Unrefined: Match because it's in the broad group (checked in step 1)\r\n    return true;\r\n  });\r\n};\r\n\r\nconst matchesEquipment = (exercise: Exercise, selected: FilterEquipment[]): boolean => {\r\n  return matchesArrayFilter(selected, () => {\r\n    return selected.some((filter) => {\r\n      // Direct match for explicitly listed equipment\r\n      if (exercise.equipment.includes(filter as EquipmentType)) {\r\n        return true;\r\n      }\r\n      \r\n      // Special handling for Squat Rack (inferred from Barbell + Movement Pattern)\r\n      if (filter === 'Squat Rack') {\r\n        const needsRackPatterns = ['Squat', 'Lunge', 'Hinge', 'Vertical Push'];\r\n        const hasBarbell = exercise.equipment.includes('Barbell');\r\n        const hasRackPattern = needsRackPatterns.includes(exercise.movementPattern);\r\n        return (hasBarbell && hasRackPattern) || exercise.equipment.includes('Smith Machine');\r\n      }\r\n      \r\n      return false;\r\n    });\r\n  });\r\n};\r\n\r\nconst matchesDifficulty = (exercise: Exercise, selected: FilterDifficulty[]): boolean => {\r\n  return matchesArrayFilter(selected, () => selected.includes(exercise.difficulty as FilterDifficulty));\r\n};\r\n\r\nconst matchesExerciseType = (exercise: Exercise, selected: ExerciseType[]): boolean => {\r\n  if (selected.length === 0) return true;\r\n  return selected.includes(exercise.exerciseType);\r\n};\r\n\r\nexport const matchesExerciseFilters = (exercise: Exercise, filters: ExerciseFilters): boolean => {\r\n  if (filters.bodyweightOnly && !exercise.isBodyweight) {\r\n    return false;\r\n  }\r\n\r\n  if (filters.compoundOnly && !exercise.isCompound) {\r\n    return false;\r\n  }\r\n\r\n  if (!matchesMuscleGroup(exercise, filters)) {\r\n    return false;\r\n  }\r\n\r\n  if (!matchesEquipment(exercise, filters.equipment)) {\r\n    return false;\r\n  }\r\n\r\n  if (!matchesDifficulty(exercise, filters.difficulty)) {\r\n    return false;\r\n  }\r\n\r\n  if (!matchesExerciseType(exercise, filters.exerciseTypes)) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nexport const countActiveFilters = (filters: ExerciseFilters): number => {\r\n  let count = 0;\r\n  count += filters.muscleGroups.length;\r\n  count += filters.equipment.length;\r\n  count += filters.difficulty.length;\r\n  count += filters.exerciseTypes.length;\r\n  if (filters.bodyweightOnly) count += 1;\r\n  if (filters.compoundOnly) count += 1;\r\n  return count;\r\n};\r\n\r\nexport const getActiveFilterLabels = (filters: ExerciseFilters): string[] => {\r\n  const labels: string[] = [];\r\n  labels.push(...filters.muscleGroups);\r\n  labels.push(...filters.specificMuscles);\r\n  labels.push(...filters.equipment);\r\n  labels.push(...filters.difficulty);\r\n  labels.push(...filters.exerciseTypes.map(t => EXERCISE_TYPE_LABELS[t]));\r\n  if (filters.bodyweightOnly) labels.push('Bodyweight');\r\n  if (filters.compoundOnly) labels.push('Compound');\r\n  return labels;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\utils\\exerciseHistory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\utils\\exerciseMigration.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'UserPlan' is defined but never used.","line":10,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Exercise Name Migration Utility\r\n * \r\n * This utility handles updating exercise names throughout the app when they change in exercises.json.\r\n * It updates workout sessions, plans, and any other data that stores exercise names.\r\n */\r\n\r\nimport { supabaseClient } from '@/lib/supabaseClient';\r\nimport type { Workout, WorkoutExercise } from '@/types/workout';\r\nimport type { UserPlan } from '@/types/premadePlan';\r\n\r\n/**\r\n * Map of old exercise names to new exercise names.\r\n * Add entries here whenever you rename an exercise in exercises.json.\r\n */\r\nconst EXERCISE_NAME_MIGRATIONS: Record<string, string> = {\r\n  // Format: 'Old Name': 'New Name'\r\n  'Thigh Adductor': 'Hip Adductor',\r\n  'Thigh Abductor': 'Hip Abductor',\r\n};\r\n\r\n/**\r\n * Gets the current exercise name, handling legacy names.\r\n * Returns the new name if a migration exists, otherwise returns the original name.\r\n */\r\nexport function migrateExerciseName(exerciseName: string): string {\r\n  return EXERCISE_NAME_MIGRATIONS[exerciseName] ?? exerciseName;\r\n}\r\n\r\n/**\r\n * Migrates exercise names in a workout's exercises array.\r\n */\r\nexport function migrateWorkoutExercises(exercises: WorkoutExercise[]): WorkoutExercise[] {\r\n  return exercises.map(exercise => ({\r\n    ...exercise,\r\n    name: migrateExerciseName(exercise.name),\r\n  }));\r\n}\r\n\r\n/**\r\n * Migrates exercise names in a single workout session.\r\n */\r\nexport function migrateWorkout(workout: Workout): Workout {\r\n  return {\r\n    ...workout,\r\n    exercises: migrateWorkoutExercises(workout.exercises),\r\n  };\r\n}\r\n\r\n/**\r\n * Updates all workout sessions in the database for a user, migrating old exercise names.\r\n */\r\nexport async function migrateUserWorkoutSessions(userId: string): Promise<number> {\r\n  console.log('[Migration] Starting workout session migration for user:', userId);\r\n  \r\n  try {\r\n    // Fetch all workout sessions\r\n    const { data: sessions, error: fetchError } = await supabaseClient\r\n      .from('workout_sessions')\r\n      .select('*')\r\n      .eq('user_id', userId);\r\n\r\n    if (fetchError) {\r\n      console.error('[Migration] Error fetching workout sessions:', fetchError);\r\n      throw fetchError;\r\n    }\r\n\r\n    if (!sessions || sessions.length === 0) {\r\n      console.log('[Migration] No workout sessions to migrate');\r\n      return 0;\r\n    }\r\n\r\n    let updateCount = 0;\r\n\r\n    // Process each session\r\n    for (const session of sessions) {\r\n      const exercises = session.exercises as WorkoutExercise[];\r\n      if (!exercises || exercises.length === 0) continue;\r\n\r\n      // Check if any exercise needs migration\r\n      const needsMigration = exercises.some(\r\n        exercise => EXERCISE_NAME_MIGRATIONS[exercise.name] !== undefined\r\n      );\r\n\r\n      if (!needsMigration) continue;\r\n\r\n      // Migrate exercise names\r\n      const migratedExercises = migrateWorkoutExercises(exercises);\r\n\r\n      // Update in database\r\n      const { error: updateError } = await supabaseClient\r\n        .from('workout_sessions')\r\n        .update({ exercises: migratedExercises })\r\n        .eq('id', session.id);\r\n\r\n      if (updateError) {\r\n        console.error('[Migration] Error updating workout session:', session.id, updateError);\r\n        continue;\r\n      }\r\n\r\n      updateCount++;\r\n    }\r\n\r\n    console.log('[Migration] Successfully migrated', updateCount, 'workout sessions');\r\n    return updateCount;\r\n  } catch (error) {\r\n    console.error('[Migration] Unexpected error during workout migration:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Updates all plans in the database for a user, migrating old exercise names.\r\n */\r\nexport async function migrateUserPlans(userId: string): Promise<number> {\r\n  console.log('[Migration] Starting plan migration for user:', userId);\r\n  \r\n  try {\r\n    // Fetch all plans\r\n    const { data: plans, error: fetchError } = await supabaseClient\r\n      .from('plans')\r\n      .select('*')\r\n      .eq('user_id', userId);\r\n\r\n    if (fetchError) {\r\n      console.error('[Migration] Error fetching plans:', fetchError);\r\n      throw fetchError;\r\n    }\r\n\r\n    if (!plans || plans.length === 0) {\r\n      console.log('[Migration] No plans to migrate');\r\n      return 0;\r\n    }\r\n\r\n    let updateCount = 0;\r\n\r\n    // Process each plan\r\n    for (const plan of plans) {\r\n      const exercises = plan.exercises as { id: string; name: string; sets: number }[];\r\n      if (!exercises || exercises.length === 0) continue;\r\n\r\n      // Check if any exercise needs migration\r\n      const needsMigration = exercises.some(\r\n        exercise => EXERCISE_NAME_MIGRATIONS[exercise.name] !== undefined\r\n      );\r\n\r\n      if (!needsMigration) continue;\r\n\r\n      // Migrate exercise names\r\n      const migratedExercises = exercises.map(exercise => ({\r\n        ...exercise,\r\n        name: migrateExerciseName(exercise.name),\r\n      }));\r\n\r\n      // Update in database\r\n      const { error: updateError } = await supabaseClient\r\n        .from('plans')\r\n        .update({ exercises: migratedExercises })\r\n        .eq('id', plan.id);\r\n\r\n      if (updateError) {\r\n        console.error('[Migration] Error updating plan:', plan.id, updateError);\r\n        continue;\r\n      }\r\n\r\n      updateCount++;\r\n    }\r\n\r\n    console.log('[Migration] Successfully migrated', updateCount, 'plans');\r\n    return updateCount;\r\n  } catch (error) {\r\n    console.error('[Migration] Unexpected error during plan migration:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Runs all exercise name migrations for a user.\r\n * Call this function when the user logs in or when you need to ensure all data is up to date.\r\n */\r\nexport async function runExerciseMigrations(userId: string): Promise<{\r\n  workoutSessions: number;\r\n  plans: number;\r\n}> {\r\n  console.log('[Migration] Running all exercise migrations for user:', userId);\r\n  \r\n  const results = {\r\n    workoutSessions: await migrateUserWorkoutSessions(userId),\r\n    plans: await migrateUserPlans(userId),\r\n  };\r\n\r\n  console.log('[Migration] Migration complete:', results);\r\n  return results;\r\n}\r\n\r\n/**\r\n * Checks if there are any pending migrations that haven't been run.\r\n * This is useful for showing a migration status to the user.\r\n */\r\nexport function hasPendingMigrations(): boolean {\r\n  return Object.keys(EXERCISE_NAME_MIGRATIONS).length > 0;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\utils\\exerciseSearch.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\utils\\haptics.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":70,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":70,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Platform } from 'react-native';\r\nimport * as Haptics from 'expo-haptics';\r\nimport { useSettingsStore } from '@/store/settingsStore';\r\n\r\nconst HAPTIC_THROTTLE_MS = 80;\r\n\r\nexport type HapticPattern = 'selection' | 'light' | 'medium' | 'heavy' | 'success' | 'warning' | 'error';\r\n\r\nconst impactMap: Record<Exclude<HapticPattern, 'selection' | 'success' | 'warning' | 'error'>, Haptics.ImpactFeedbackStyle> = {\r\n  light: Haptics.ImpactFeedbackStyle.Light,\r\n  medium: Haptics.ImpactFeedbackStyle.Medium,\r\n  heavy: Haptics.ImpactFeedbackStyle.Heavy,\r\n};\r\n\r\nconst notificationMap: Record<Extract<HapticPattern, 'success' | 'warning' | 'error'>, Haptics.NotificationFeedbackType> = {\r\n  success: Haptics.NotificationFeedbackType.Success,\r\n  warning: Haptics.NotificationFeedbackType.Warning,\r\n  error: Haptics.NotificationFeedbackType.Error,\r\n};\r\n\r\nlet lastTriggerTimestamp = 0;\r\n\r\nconst isSupportedPlatform = Platform.OS === 'ios' || Platform.OS === 'android';\r\n\r\nconst resolvePattern = (pattern: HapticPattern): HapticPattern => {\r\n  if (Platform.OS === 'android' && pattern === 'light') {\r\n    return 'selection';\r\n  }\r\n\r\n  return pattern;\r\n};\r\n\r\nexport const triggerHaptic = (pattern: HapticPattern = 'selection'): void => {\r\n  if (!isSupportedPlatform) {\r\n    return;\r\n  }\r\n\r\n  // Check global setting\r\n  const hapticsEnabled = useSettingsStore.getState().hapticsEnabled;\r\n  if (!hapticsEnabled) {\r\n    return;\r\n  }\r\n\r\n  const now = Date.now();\r\n  if (now - lastTriggerTimestamp < HAPTIC_THROTTLE_MS) {\r\n    return;\r\n  }\r\n\r\n  lastTriggerTimestamp = now;\r\n\r\n  try {\r\n    const resolvedPattern = resolvePattern(pattern);\r\n\r\n    if (resolvedPattern === 'selection') {\r\n      void Haptics.selectionAsync();\r\n      return;\r\n    }\r\n\r\n    if (['success', 'warning', 'error'].includes(resolvedPattern)) {\r\n      const notificationType = notificationMap[resolvedPattern as keyof typeof notificationMap];\r\n      void Haptics.notificationAsync(notificationType);\r\n      return;\r\n    }\r\n\r\n    // Default to impact\r\n    const impactStyle = impactMap[resolvedPattern as keyof typeof impactMap];\r\n    if (impactStyle) {\r\n      void Haptics.impactAsync(impactStyle);\r\n    }\r\n  } catch (error) {\r\n    // If haptics fail, we don't want to crash the app, but we reset timestamp\r\n    // just in case it was a temporary glitch\r\n    lastTriggerTimestamp = 0;\r\n  }\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\utils\\markdownRenderer.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'StyleSheet' is defined but never used.","line":7,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":42},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Text' is defined but never used.","line":8,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Custom Markdown Renderer for React Native\r\n * Parses and renders markdown with proper formatting\r\n */\r\n\r\nimport React from 'react';\r\nimport { View, Text as RNText, StyleSheet } from 'react-native';\r\nimport { Text } from '@/components/atoms/Text';\r\nimport { spacing, radius, typography } from '@/constants/theme';\r\n\r\ninterface MarkdownStyles {\r\n  text: {\r\n    primary: string;\r\n    secondary: string;\r\n  };\r\n  accent: {\r\n    primary: string;\r\n  };\r\n  surface: {\r\n    elevated: string;\r\n  };\r\n  border: {\r\n    medium: string;\r\n  };\r\n}\r\n\r\ninterface MarkdownElement {\r\n  type: 'text' | 'bold' | 'italic' | 'code' | 'heading' | 'list' | 'paragraph' | 'codeblock' | 'blockquote';\r\n  content: string | MarkdownElement[];\r\n  level?: number;\r\n  ordered?: boolean;\r\n}\r\n\r\nexport const parseMarkdown = (text: string): MarkdownElement[] => {\r\n  const lines = text.split('\\n');\r\n  const elements: MarkdownElement[] = [];\r\n  let i = 0;\r\n  let inCodeBlock = false;\r\n  let codeBlockContent: string[] = [];\r\n\r\n  while (i < lines.length) {\r\n    const line = lines[i];\r\n\r\n    // Code blocks (```)\r\n    if (line.trim().startsWith('```')) {\r\n      if (inCodeBlock) {\r\n        elements.push({\r\n          type: 'codeblock',\r\n          content: codeBlockContent.join('\\n'),\r\n        });\r\n        codeBlockContent = [];\r\n        inCodeBlock = false;\r\n      } else {\r\n        inCodeBlock = true;\r\n      }\r\n      i++;\r\n      continue;\r\n    }\r\n\r\n    if (inCodeBlock) {\r\n      codeBlockContent.push(line);\r\n      i++;\r\n      continue;\r\n    }\r\n\r\n    // Headings\r\n    const headingMatch = line.match(/^(#{1,3})\\s+(.+)$/);\r\n    if (headingMatch) {\r\n      elements.push({\r\n        type: 'heading',\r\n        level: headingMatch[1].length,\r\n        content: headingMatch[2],\r\n      });\r\n      i++;\r\n      continue;\r\n    }\r\n\r\n    // Bullet lists\r\n    if (line.match(/^[\\s]*[-*]\\s+(.+)$/)) {\r\n      const listItems: string[] = [];\r\n      while (i < lines.length && lines[i].match(/^[\\s]*[-*]\\s+(.+)$/)) {\r\n        const match = lines[i].match(/^[\\s]*[-*]\\s+(.+)$/);\r\n        if (match) listItems.push(match[1]);\r\n        i++;\r\n      }\r\n      elements.push({\r\n        type: 'list',\r\n        ordered: false,\r\n        content: listItems.join('\\n'),\r\n      });\r\n      continue;\r\n    }\r\n\r\n    // Numbered lists\r\n    if (line.match(/^[\\s]*\\d+\\.\\s+(.+)$/)) {\r\n      const listItems: string[] = [];\r\n      while (i < lines.length && lines[i].match(/^[\\s]*\\d+\\.\\s+(.+)$/)) {\r\n        const match = lines[i].match(/^[\\s]*\\d+\\.\\s+(.+)$/);\r\n        if (match) listItems.push(match[1]);\r\n        i++;\r\n      }\r\n      elements.push({\r\n        type: 'list',\r\n        ordered: true,\r\n        content: listItems.join('\\n'),\r\n      });\r\n      continue;\r\n    }\r\n\r\n    // Blockquotes\r\n    if (line.startsWith('>')) {\r\n      elements.push({\r\n        type: 'blockquote',\r\n        content: line.substring(1).trim(),\r\n      });\r\n      i++;\r\n      continue;\r\n    }\r\n\r\n    // Regular paragraph\r\n    if (line.trim()) {\r\n      elements.push({\r\n        type: 'paragraph',\r\n        content: line,\r\n      });\r\n    }\r\n\r\n    i++;\r\n  }\r\n\r\n  return elements;\r\n};\r\n\r\nconst parseInlineMarkdown = (text: string): (string | { type: string; content: string })[] => {\r\n  const parts: (string | { type: string; content: string })[] = [];\r\n  let current = '';\r\n  let i = 0;\r\n\r\n  while (i < text.length) {\r\n    // Bold **text**\r\n    if (text[i] === '*' && text[i + 1] === '*') {\r\n      if (current) {\r\n        parts.push(current);\r\n        current = '';\r\n      }\r\n      i += 2;\r\n      let boldText = '';\r\n      while (i < text.length && !(text[i] === '*' && text[i + 1] === '*')) {\r\n        boldText += text[i];\r\n        i++;\r\n      }\r\n      if (boldText) parts.push({ type: 'bold', content: boldText });\r\n      i += 2;\r\n      continue;\r\n    }\r\n\r\n    // Italic *text*\r\n    if (text[i] === '*' && text[i + 1] !== '*') {\r\n      if (current) {\r\n        parts.push(current);\r\n        current = '';\r\n      }\r\n      i += 1;\r\n      let italicText = '';\r\n      while (i < text.length && text[i] !== '*') {\r\n        italicText += text[i];\r\n        i++;\r\n      }\r\n      if (italicText) parts.push({ type: 'italic', content: italicText });\r\n      i += 1;\r\n      continue;\r\n    }\r\n\r\n    // Inline code `text`\r\n    if (text[i] === '`') {\r\n      if (current) {\r\n        parts.push(current);\r\n        current = '';\r\n      }\r\n      i += 1;\r\n      let codeText = '';\r\n      while (i < text.length && text[i] !== '`') {\r\n        codeText += text[i];\r\n        i++;\r\n      }\r\n      if (codeText) parts.push({ type: 'code', content: codeText });\r\n      i += 1;\r\n      continue;\r\n    }\r\n\r\n    current += text[i];\r\n    i++;\r\n  }\r\n\r\n  if (current) parts.push(current);\r\n  return parts;\r\n};\r\n\r\nexport const renderMarkdown = (elements: MarkdownElement[], theme: MarkdownStyles) => {\r\n  return elements.map((element, index) => {\r\n    switch (element.type) {\r\n      case 'heading':\r\n        const headingSize = element.level === 1 ? 24 : element.level === 2 ? 20 : 18;\r\n        const headingWeight = element.level === 1 ? '700' : '600';\r\n        return (\r\n          <RNText\r\n            key={index}\r\n            style={{\r\n              fontSize: headingSize,\r\n              fontWeight: headingWeight,\r\n              color: theme.text.primary,\r\n              marginTop: spacing.md,\r\n              marginBottom: spacing.sm,\r\n              lineHeight: headingSize + 8,\r\n            }}\r\n          >\r\n            {element.content as string}\r\n          </RNText>\r\n        );\r\n\r\n      case 'paragraph':\r\n        const inlineParts = parseInlineMarkdown(element.content as string);\r\n        return (\r\n          <RNText\r\n            key={index}\r\n            style={{\r\n              fontSize: typography.body.fontSize,\r\n              color: theme.text.primary,\r\n              lineHeight: 24,\r\n              marginBottom: spacing.sm,\r\n            }}\r\n          >\r\n            {inlineParts.map((part, i) => {\r\n              if (typeof part === 'string') {\r\n                return <RNText key={i}>{part}</RNText>;\r\n              }\r\n              if (part.type === 'bold') {\r\n                return (\r\n                  <RNText key={i} style={{ fontWeight: '700' }}>\r\n                    {part.content}\r\n                  </RNText>\r\n                );\r\n              }\r\n              if (part.type === 'italic') {\r\n                return (\r\n                  <RNText key={i} style={{ fontStyle: 'italic' }}>\r\n                    {part.content}\r\n                  </RNText>\r\n                );\r\n              }\r\n              if (part.type === 'code') {\r\n                return (\r\n                  <RNText\r\n                    key={i}\r\n                    style={{\r\n                      backgroundColor: theme.surface.elevated,\r\n                      color: theme.accent.primary,\r\n                      fontFamily: 'monospace',\r\n                      fontSize: 14,\r\n                      paddingHorizontal: 6,\r\n                      paddingVertical: 2,\r\n                      borderRadius: 4,\r\n                    }}\r\n                  >\r\n                    {part.content}\r\n                  </RNText>\r\n                );\r\n              }\r\n              return null;\r\n            })}\r\n          </RNText>\r\n        );\r\n\r\n      case 'list':\r\n        const items = (element.content as string).split('\\n');\r\n        return (\r\n          <View key={index} style={{ marginBottom: spacing.sm }}>\r\n            {items.map((item, i) => {\r\n              const inlineParts = parseInlineMarkdown(item);\r\n              return (\r\n                <View key={i} style={{ flexDirection: 'row', marginBottom: spacing.xs }}>\r\n                  <RNText\r\n                    style={{\r\n                      color: theme.accent.primary,\r\n                      fontSize: 16,\r\n                      marginRight: spacing.sm,\r\n                      lineHeight: 24,\r\n                      fontWeight: element.ordered ? '600' : 'normal',\r\n                    }}\r\n                  >\r\n                    {element.ordered ? `${i + 1}.` : ''}\r\n                  </RNText>\r\n                  <RNText\r\n                    style={{\r\n                      flex: 1,\r\n                      fontSize: typography.body.fontSize,\r\n                      color: theme.text.primary,\r\n                      lineHeight: 24,\r\n                    }}\r\n                  >\r\n                    {inlineParts.map((part, j) => {\r\n                      if (typeof part === 'string') {\r\n                        return <RNText key={j}>{part}</RNText>;\r\n                      }\r\n                      if (part.type === 'bold') {\r\n                        return (\r\n                          <RNText key={j} style={{ fontWeight: '700' }}>\r\n                            {part.content}\r\n                          </RNText>\r\n                        );\r\n                      }\r\n                      if (part.type === 'italic') {\r\n                        return (\r\n                          <RNText key={j} style={{ fontStyle: 'italic' }}>\r\n                            {part.content}\r\n                          </RNText>\r\n                        );\r\n                      }\r\n                      if (part.type === 'code') {\r\n                        return (\r\n                          <RNText\r\n                            key={j}\r\n                            style={{\r\n                              backgroundColor: theme.surface.elevated,\r\n                              color: theme.accent.primary,\r\n                              fontFamily: 'monospace',\r\n                              fontSize: 14,\r\n                            }}\r\n                          >\r\n                            {part.content}\r\n                          </RNText>\r\n                        );\r\n                      }\r\n                      return null;\r\n                    })}\r\n                  </RNText>\r\n                </View>\r\n              );\r\n            })}\r\n          </View>\r\n        );\r\n\r\n      case 'codeblock':\r\n        return (\r\n          <View\r\n            key={index}\r\n            style={{\r\n              backgroundColor: theme.surface.elevated,\r\n              padding: spacing.md,\r\n              borderRadius: radius.md,\r\n              marginVertical: spacing.sm,\r\n            }}\r\n          >\r\n            <RNText\r\n              style={{\r\n                fontFamily: 'monospace',\r\n                fontSize: 14,\r\n                color: theme.text.primary,\r\n                lineHeight: 20,\r\n              }}\r\n            >\r\n              {element.content as string}\r\n            </RNText>\r\n          </View>\r\n        );\r\n\r\n      case 'blockquote':\r\n        return (\r\n          <View\r\n            key={index}\r\n            style={{\r\n              backgroundColor: theme.surface.elevated,\r\n              borderLeftWidth: 4,\r\n              borderLeftColor: theme.accent.primary,\r\n              paddingLeft: spacing.md,\r\n              paddingVertical: spacing.sm,\r\n              marginVertical: spacing.sm,\r\n              borderRadius: radius.sm,\r\n            }}\r\n          >\r\n            <RNText\r\n              style={{\r\n                fontSize: typography.body.fontSize,\r\n                color: theme.text.primary,\r\n                lineHeight: 24,\r\n              }}\r\n            >\r\n              {element.content as string}\r\n            </RNText>\r\n          </View>\r\n        );\r\n\r\n      default:\r\n        return null;\r\n    }\r\n  });\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\utils\\messageSanitizer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\utils\\premiumLimits.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\utils\\scheduleStorage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\utils\\storage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\utils\\strings.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\utils\\workout.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\owenr\\Desktop\\Windsurf_Projects\\Hercules\\frontend\\src\\utils\\workoutSessionStorage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]